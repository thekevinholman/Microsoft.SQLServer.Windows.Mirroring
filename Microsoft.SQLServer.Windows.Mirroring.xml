<?xml version="1.0" encoding="utf-8"?><ManagementPack ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <Manifest>
    <Identity>
      <ID>Microsoft.SQLServer.Windows.Mirroring</ID>
      <Version>7.0.20.20</Version>
    </Identity>
    <Name>Microsoft.SQLServer.Windows.Mirroring</Name>
    <References>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>	  
      <Reference Alias="Health">
        <ID>System.Health.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSCL">
        <ID>Microsoft.SQLServer.Core.Library</ID>
        <Version>7.0.20.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSWD">
        <ID>Microsoft.SQLServer.Windows.Discovery</ID>
        <Version>7.0.20.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <EntityTypes>
      <ClassTypes>
        <ClassType ID="Microsoft.SQLServer.Windows.Mirroring.Database" Accessibility="Public" Abstract="false" Base="MSWD!Microsoft.SQLServer.Windows.Database" Hosted="true" Singleton="false" Extension="false">
          <Property ID="MirroringGUID" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="MirroringRole" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="Level" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="Partner" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="Witness" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Microsoft.SQLServer.Windows.Mirroring.WitnessRole" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.ApplicationComponent" Hosted="true" Singleton="false" Extension="false" />
        <ClassType ID="Microsoft.SQLServer.Windows.Mirroring.Witness" Accessibility="Public" Abstract="false" Base="Windows!Microsoft.Windows.ApplicationComponent" Hosted="true" Singleton="false" Extension="false">
          <Property ID="DatabaseName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="Principal" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="Mirror" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="Level" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="MirroringGUID" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Microsoft.SQLServer.Windows.Mirroring.Group" Accessibility="Public" Abstract="false" Base="System!System.ComputerRole" Hosted="false" Singleton="false" Extension="false">
          <Property ID="Level" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="PrincipalComputerName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="PrincipalInstanceName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="MirrorComputerName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="MirrorInstanceName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="DatabaseName" Type="string" AutoIncrement="false" Key="false" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
          <Property ID="MirroringGUID" Type="string" AutoIncrement="false" Key="true" CaseSensitive="false" MaxLength="256" MinLength="0" Required="false" Scale="0" />
        </ClassType>
        <ClassType ID="Microsoft.SQLServer.Windows.Mirroring.Service" Accessibility="Public" Abstract="false" Base="System!System.Group" Hosted="false" Singleton="true" Extension="false" />
      </ClassTypes>
      <RelationshipTypes>
        <RelationshipType ID="Microsoft.SQLServer.Windows.Mirroring.DBEngineHostsWitnessRole" Accessibility="Public" Abstract="false" Base="System!System.Hosting">
          <Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="MSWD!Microsoft.SQLServer.Windows.DBEngine" />
          <Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.WitnessRole" />
        </RelationshipType>
        <RelationshipType ID="Microsoft.SQLServer.Windows.Mirroring.WitnessRoleHostsWitness" Accessibility="Public" Abstract="false" Base="System!System.Hosting">
          <Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.WitnessRole" />
          <Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Witness" />
        </RelationshipType>
        <RelationshipType ID="Microsoft.SQLServer.Windows.Mirroring.GroupContainsDatabase" Accessibility="Public" Abstract="false" Base="System!System.Containment">
          <Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Group" />
          <Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Database" />
        </RelationshipType>
        <RelationshipType ID="Microsoft.SQLServer.Windows.Mirroring.GroupContainsWitness" Accessibility="Public" Abstract="false" Base="System!System.Containment">
          <Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Group" />
          <Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Witness" />
        </RelationshipType>
        <RelationshipType ID="Microsoft.SQLServer.Windows.Mirroring.ServiceContainsGroup" Accessibility="Public" Abstract="false" Base="System!System.Containment">
          <Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Service" />
          <Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Group" />
        </RelationshipType>
        <RelationshipType ID="Microsoft.SQLServer.Windows.Mirroring.PrincipalReferencesMirror" Accessibility="Public" Abstract="false" Base="System!System.Reference">
          <Source ID="Source" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Database" />
          <Target ID="Target" MinCardinality="0" MaxCardinality="2147483647" Type="Microsoft.SQLServer.Windows.Mirroring.Database" />
        </RelationshipType>
      </RelationshipTypes>
    </EntityTypes>
    <ModuleTypes>
      <DataSourceModuleType ID="Microsoft.SQLServer.Windows.Mirroring.ScriptedStateProvider.DSTwoLevelHostTcp.DS" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ConnectionString" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MachineName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TcpPorts" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Version" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="ScriptBody" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedScript.PropertyBagProvider">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <ScriptName>$Config/ScriptName$</ScriptName>
                <Arguments>"$Config/ConnectionString$" "$Config/MachineName$" "$Config/InstanceName$" "$Config/TcpPorts$" "$Config/Version$"</Arguments>
                <ScriptBody>&apos;#Include File:Common.vbs
Option Explicit
SetLocale(&quot;en-us&quot;)

Const ManagementGroupName = &quot;$Target/ManagementGroup/Name$&quot;
Const SQL_DEFAULT = &quot;MSSQLSERVER&quot;
Const DEBUG_MODE = False
Const MANAGEMENT_PACK_VERSION = &quot;7.0.20.0&quot;
Const EVENT_TYPE_ERROR = 1
Const MAX_DRIVER_VERSION_STR = &quot;99999999.99999999.99999999.99999999&quot;
Const DriverSelector_DEFAULT_DRIVER_NAME = &quot;SQL Server&quot;

Dim oArgs
Set oArgs = WScript.Arguments
Dim ConnectionString, MachineName, InstanceName, sTcpPort, SQLVersion
ConnectionString = oArgs(0)
MachineName = oArgs(1)
InstanceName = oArgs(2)
sTcpPort = oArgs(3)
SQLVersion = oArgs(4)

Dim SQLVersionArr, SQLMajorVersion, SQL_WMI_NAMESPACE
SQLVersionArr = split(SQLVersion,&quot;.&quot;)
SQLMajorVersion = SQLVersionArr(0)
SQL_WMI_NAMESPACE = &quot;ComputerManagement&quot; &amp; SQLMajorVersion

Dim GlobalErrorList: Set GlobalErrorList = New ArrayList

Dim StartTime,EndTime,sTime
&apos;Capture script start time
StartTime = Now

Dim oAPI
Set oAPI = MOMCreateObject(&quot;MOM.ScriptAPI&quot;)

&apos;Call oAPI.LogScriptEvent("$Config/ScriptName$", 4006, 0, "Starting script. ConnectionString: " &amp; ConnectionString &amp; ". MachineName: " &amp; MachineName &amp; ". InstanceName: " &amp; InstanceName &amp; ". sTcpPort: " &amp; sTcpPort &amp; ". Version: " &amp; SQLVersion &amp; ". SQL_WMI_NAMESPACE: " &amp; SQL_WMI_NAMESPACE)

Function MomCreateObject(ByVal sProgramId)
    Dim oError
    Set oError = New Error
    
	On Error Resume Next
	Set MomCreateObject = CreateObject(sProgramId)
	oError.Save
	On Error Goto 0
	
	If oError.Number &lt;&gt; 0 Then ThrowScriptError &quot;Unable to create automation object &apos;&quot; &amp; sProgramId &amp; &quot;&apos;&quot;, oError
End Function

Public Function GetSQLServiceName(sInstance)
    If sInstance = SQL_DEFAULT Then
        GetSQLServiceName = SQL_DEFAULT
    Else
        GetSQLServiceName = &quot;MSSQL$&quot; &amp; sInstance
    End If
End Function

Function GetServiceState( sTargetComputer, sServiceName)
    On Error Resume Next    

    Dim sNamespace, sQuery, oWMI, objClasses, sState
    sNamespace = &quot;winmgmts://&quot; &amp; sTargetComputer &amp; &quot;/root/cimv2&quot;
    sQuery = &quot;SELECT State FROM Win32_Service where  Name = &quot;&quot;&quot; &amp; EscapeWQLString(sServiceName) &amp; &quot;&quot;&quot;&quot;
    
    Set oWMI = GetObject(sNamespace)
    Set objClasses = oWMI.ExecQuery(sQuery)

    if objClasses.Count &gt;= 1 Then
        sState = GetFirstItemFromWMIQuery(objClasses).Properties_.Item(&quot;State&quot;)
    End If
    
    If Err.number &lt;&gt; 0 Or objClasses.Count = 0 Then
        sState = &quot;Unknown&quot;
    End If 

    Err.Clear
    GetServiceState = sState
End Function

Class Error
    Private m_lNumber
    Private m_sSource
    Private m_sDescription
    Private m_sHelpContext
    Private m_sHelpFile

    Public Sub Save()
        m_lNumber = Err.Number
        m_sSource = Err.Source
        m_sDescription = Err.Description
        m_sHelpContext = Err.HelpContext
        m_sHelpFile = Err.HelpFile
    End Sub

    Public Sub Raise()
        Err.Raise m_lNumber, m_sSource, m_sDescription, m_sHelpFile, m_sHelpContext
    End Sub

    Public Sub Clear()
        m_lNumber = 0
        m_sSource = &quot;&quot;
        m_sDescription = &quot;&quot;
        m_sHelpContext = &quot;&quot;
        m_sHelpFile = &quot;&quot;
    End Sub

    Public Default Property Get Number()
        Number = m_lNumber
    End Property
    Public Property Get Source()
        Source = m_sSource
    End Property
    Public Property Get Description()
        Description = m_sDescription
    End Property
    Public Property Get HelpContext()
        HelpContext = m_sHelpContext
    End Property
    Public Property Get HelpFile()
        HelpFile = m_sHelpFile
    End Property    
End Class

Class ArrayList
    Private m_itemArray

    Private Sub Class_Initialize()
        Me.Clear
    End Sub

    Private Sub AddItemToArray(ByRef itemArray, ByVal item)
        ReDim Preserve itemArray(UBound(itemArray) + 1) 
        itemArray(UBound(itemArray)) = item
    End Sub

    Public Sub Clear()
        m_itemArray = Array()
    End Sub

    Public Sub Add(item)
        AddItemToArray m_itemArray, item
    End Sub

    Public Sub RemoveAt(index)
        If index &lt; 0 Or index &gt; UBound(m_itemArray) Then
            Exit Sub
        End If
        Dim newArr: newArr = Array()
        Dim i
        For i = 0 To UBound(m_itemArray)
            If i &lt;&gt; index Then
                Call AddItemToArray(newArr, m_itemArray(i))
            End If
        Next
        m_itemArray = newArr
    End Sub

    Public Property Get Count()
        Count = UBound(m_itemArray) + 1
    End Property

    Public Property Get ItemsArray()
        ItemsArray = m_itemArray
    End Property

    Public Property Get IsEmpty()
        IsEmpty = UBound(m_itemArray) &lt; 0
    End Property
End Class

Class ScriptLogger
    Dim sourceLogEvent
    
    Private Sub Class_Initialize()
        sourceLogEvent = &quot;Management Group: &quot; + ManagementGroupName + &quot;. Script: &quot; + WScript.ScriptName + &quot;. Version: &quot; + MANAGEMENT_PACK_VERSION
    End Sub
    
    Private Sub Class_Terminate()
    End Sub
    
    Public Property Get ErrorEventType
        ErrorEventType = 1
    End Property
    
    Public Property Get WarningEventType
        WarningEventType = 2
    End Property
    
    Public Property Get InfoEventType
        InfoEventType = 4
    End Property

    Private Function LogEvent (message, eventType)
        On Error Resume Next
        Dim oAPI
        Set oAPI = CreateObject(&quot;MOM.ScriptAPI&quot;)
        Call oAPI.LogScriptEvent(sourceLogEvent, SCRIPT_EVENT_ID, eventType, message)
    End Function

    Public Function LogDebug(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
            LogEvent message, Me.InfoEventType
        End If
    End Function
    
    Public Function LogError(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.ErrorEventType
    End Function
    
    Public Function LogWarning(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.WarningEventType
    End Function
    
    Public Function LogFormattedError(customMessage)
        If Err.number &lt;&gt; 0 Then
            Me.LogError FormatErrorMessage(customMessage, &quot;&quot;)
        End If
    End Function
    
    Private Function ScriptInfo()
        Dim commandLineInfo  : commandLineInfo = WScript.ScriptFullName
        Dim argument
        For Each argument In WScript.Arguments
            commandLineInfo = commandLineInfo &amp; &quot; &quot;&quot;&quot; &amp; argument &amp; &quot;&quot;&quot;&quot;
        Next
        ScriptInfo = commandLineInfo
    End Function
End Class

Function FormatErrorMessage(customMessage, instanceName)
    FormatErrorMessage = customMessage
    If Err.number &lt;&gt; 0 Then
        Dim msg
        msg =_
        &quot; Error Number: &quot; &amp; CStr(Err.number) &amp; VbCrLf &amp; _
        &quot; Description: &quot; &amp; Err.Description

        If Not IsEmpty(instanceName) And instanceName &lt;&gt; &quot;&quot; Then
            msg = msg &amp; VbCrLf &amp; &quot; Instance: &quot; &amp; instanceName
        End If
        If customMessage &lt;&gt; &quot;&quot; Then
            msg = customMessage &amp; VbCrLf &amp; msg &amp; VbCrLf
        End If       
        FormatErrorMessage = msg
    End If
End Function

Function FormatDbErrorMessage(message, instanceName, dbName)
    FormatDbErrorMessage = message &amp; VbCrLf &amp; _
    &quot; Instance: &quot; &amp; instanceName &amp; VbCrLf &amp; _
    &quot; Database: &quot; &amp; dbName
End Function

Function ThrowScriptErrorNoAbort(ByVal sMessage, ByVal oErr)
    On Error Resume Next
    Dim errorText: errorText =  sMessage &amp; &quot;: &quot; &amp; oErr.Description
    GlobalErrorList.Add errorText
End Function

Function ThrowScriptError(Byval sMessage, ByVal oErr)
    On Error Resume Next
    ThrowScriptErrorNoAbort sMessage, oErr
    GlobalErrorListToEventLog()
    Quit()
End Function

Sub HandleError(customMessage)
    Dim localLogger
    If Err.number &lt;&gt; 0 Then
        Set localLogger = new ScriptLogger
        Call localLogger.LogFormattedError(customMessage)
        Call Wscript.Quit(0)
    End If
End Sub

Function HandleErrorContinue(customMessage)
    HandleErrorContinue = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinue = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, &quot;&quot;))
        Call Err.Clear()
    End If
End Function

Function HandleErrorContinueEx(customMessage, instanceName)
    HandleErrorContinueEx = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinueEx = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, instanceName))
        Call Err.Clear()
    End If
End Function

Function HandleSqlErrorContinue(adoConnection, customMessage, instanceName)
    HandleSqlErrorContinue = True   
    If Err.Number &lt;&gt; 0 Then
        HandleSqlErrorContinue = False
        Dim sqlErr
        Dim e: Set e = new Error
        e.Save
        On Error Resume Next
        If adoConnection.Errors.Count &gt; 0 Then
            Set sqlErr = adoConnection.Errors(0)
            adoConnection.Errors.Clear
            Call Err.Raise(sqlErr.Number, sqlErr.Source, sqlErr.Description)
        Else
            Call e.Raise()
        End If
        Call HandleErrorContinueEx(customMessage, instanceName)
    End If
End Function

Function GetGlobalErrorListEventString()
    GetGlobalErrorListEventString = &quot;&quot;
    If Not GlobalErrorList.IsEmpty Then
        GetGlobalErrorListEventString = &quot;The next errors occurred:&quot;&amp; vbNewLine &amp; Join(GlobalErrorList.ItemsArray, vbNewLine &amp; vbNewLine)
    End If
End Function

Function GlobalErrorListToEventLog()
    On Error Resume Next
    If Not GlobalErrorList.IsEmpty Then
        Dim localLogger: Set localLogger = New ScriptLogger
        localLogger.LogWarning GetGlobalErrorListEventString()
    End If
End Function

Function Quit()
    WScript.Quit()
End Function

Function EscapeWQLString (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function ConnectToWMI(ComputerName, strNamespace)
    Set ConnectToWMI = Nothing
	Set ConnectToWMI = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; ComputerName &amp; &quot;\&quot; &amp; strNamespace)
End Function

Function WMIGetProperty(oWmi, sPropName, nCIMType, ErrAction)
    Dim sValue, oWmiProp
    
    If Not IsValidObject(oWmi) Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;Accessing property on invalid WMI object.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        Exit Function
    End If
    
    On Error Resume Next
    Set oWmiProp = oWmi.Properties_.Item(sPropName)
    If Err.Number &lt;&gt; 0 Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
    End If
    On Error GoTo 0
    
    If IsValidObject(oWmiProp) Then
        sValue = oWmiProp.Value
        
        If IsNull(sValue) Then
            &apos;
            &apos; If value is null, return blank to avoid any issues
            &apos;
            WMIGetProperty = &quot;&quot;
            
        Else
            
            Select Case (oWmiProp.CIMType)
                Case wbemCimtypeString, wbemCimtypeSint16, wbemCimtypeSint32, wbemCimtypeReal32, wbemCimtypeReal64, wbemCimtypeSint8, wbemCimtypeUint8, wbemCimtypeUint16, wbemCimtypeUint32, wbemCimtypeSint64, wbemCimtypeUint64:
                    If Not oWmiProp.IsArray Then
                        WMIGetProperty = Trim(CStr(sValue))
                    Else
                        WMIGetProperty = Join(sValue, &quot;, &quot;)
                    End If

                Case wbemCimtypeBoolean:
                    If sValue = 1 Or UCase(sValue) = &quot;TRUE&quot; Then
                        WMIGetProperty = &quot;True&quot;
                    Else
                        WMIGetProperty = &quot;False&quot;
                    End If

                Case wbemCimtypeDatetime:
                    Dim sTmpStrDate
                
                    &apos;
                    &apos; First attempt to convert the whole wmi date string
                    &apos;
                    sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                  Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                  Left(sValue, 4) &amp; &quot; &quot; &amp; _
                                  Mid (sValue, 9, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 11, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 13, 2)
                    If IsDate(sTmpStrDate) Then
                        WMIGetProperty = CDate(sTmpStrDate)
                    Else
                    
                        &apos;
                        &apos; Second, attempt just to convert the YYYYMMDD
                        &apos;
                        sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                      Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                      Left(sValue, 4)
                        If IsDate(sTmpStrDate) Then
                            WMIGetProperty = CDate(sTmpStrDate)
                        Else
                            &apos;
                            &apos; Nothing works - return passed in string
                            &apos;
                            WMIGetProperty = sValue
                        End If
                    
                    End If
                
                Case Else:
                    WMIGetProperty = &quot;&quot;
            End Select
        End If
    Else
        
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        
    End If
    
    
    If (ErrAction And ErrAction_Trace) = ErrAction_Trace Then _
        WScript.Echo &quot;  + &quot; &amp; sPropName &amp; &quot; :: &apos;&quot; &amp; WMIGetProperty &amp; &quot;&apos;&quot;
    
End Function

Function WMIExecQuery(ByVal sNamespace, ByVal sQuery)
    &apos;
    &apos; WMIExecQuery :: Executes the WMI query and returns the result set.
    &apos;
    &apos;
    Dim oWMI, oQuery, nInstanceCount
    Dim e
    Set e = New Error
    On Error Resume Next
    Set oWMI = GetObject(sNamespace)
    e.Save
    On Error GoTo 0
    If IsEmpty(oWMI) Then
        ThrowScriptErrorNoAbort &quot;Unable to open WMI Namespace &apos;&quot; &amp; sNamespace &amp; &quot;&apos;.  Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists.&quot;, e
        ThrowEmptyDiscoveryData
    End If
    
    On Error Resume Next
        Set oQuery = oWMI.ExecQuery(sQuery)
        e.Save
    On Error GoTo 0
    If IsEmpty(oQuery) Or e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; returned an invalid result set.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    &apos;Determine if we queried a valid WMI class - Count will return 0 or empty
    On Error Resume Next
    nInstanceCount = oQuery.Count
    e.Save
    On Error GoTo 0
    If e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; did not return any valid instances.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    Set WMIExecQuery = oQuery
    
End Function

Function GetFirstItemFromWMIQuery(ByRef oQuery)
    ON ERROR RESUME NEXT
    Err.Clear
    Dim oResult: Set oResult = Nothing
    Set oResult = oQuery.ItemIndex(0)
    if Err.number &lt;&gt; 0 then
        Err.Clear
        Dim oObject
        For Each oObject in oQuery 
            Set oResult = oObject
            Exit For
        Next    
    end if
    Set GetFirstItemFromWMIQuery = oResult
End Function
&apos;#Include File:Registry.vbs

Class Registry
    Public HKEY_CLASSES_ROOT
    Public HKEY_CURRENT_USER
    Public HKEY_LOCAL_MACHINE
    Public HKEY_USERS
    Public HKEY_CURRENT_CONFIG
    Public HKEY_DYN_DATA 

    Public ERROR_ACCESS_DENIED
    Public ERROR_KEY_NOT_FOUND
    Public ERROR_VALUE_NOT_FOUND
    Public SUCCESS
    
    Private m_oReg
    Private m_lHive
    
    Private Sub Class_Initialize()
        HKEY_CLASSES_ROOT = &amp;H80000000
        HKEY_CURRENT_USER = &amp;H80000001 
        HKEY_LOCAL_MACHINE = &amp;H80000002
        HKEY_USERS = &amp;H80000003 
        HKEY_CURRENT_CONFIG = &amp;H80000005
        HKEY_DYN_DATA = &amp;H80000006
        
        ERROR_ACCESS_DENIED = 5
        ERROR_KEY_NOT_FOUND = 2
        ERROR_VALUE_NOT_FOUND = 1
        SUCCESS = 0
        
        m_lHive = HKEY_LOCAL_MACHINE
    End Sub
    
    Public Sub Connect(ByVal sHostName)
        Set m_oReg = GetObject(&quot;winmgmts://&quot; &amp; sHostName &amp; &quot;/root/default:StdRegProv&quot;)
    End Sub
    
    Public Property Get Hive()
        Hive = m_lHive
    End Property
    
    Public Property Let Hive(ByVal lHive)
        m_lHive = lHive
    End Property
    
    Public Function ReadDWORDValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim lValue
        lResult = m_oReg.GetDWORDValue(m_lHive, sKeyPath, sValueName, lValue)
        ReadDWORDValue = lValue
    End Function
    
    Public Function ReadStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim sValue
        lResult = m_oReg.GetStringValue(m_lHive, sKeyPath, sValueName, sValue)
        ReadStringValue = sValue
    End Function
    
    Public Function ReadMultiStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aValues
        lResult = m_oReg.GetMultiStringValue(m_lHive, sKeyPath, sValueName, aValues)
        ReadMultiStringValue = aValues
    End Function
    
    Public Function EnumKeys(ByVal sKeyPath, ByRef lResult)
        Dim aSubKeys
        lResult = m_oReg.EnumKey(m_lHive, sKeyPath, aSubKeys)
        EnumKeys = aSubKeys
    End Function

    Public Function EnumValues(ByVal sKeyPath, ByRef lResult)
        Dim aNames, aTypes
        lResult = m_oReg.EnumValues(m_lHive, sKeyPath, aNames, aTypes)
        EnumValues = aNames
    End Function
    
    Public Function CreateKey(ByVal sKeyPath)
        CreateKey = m_oReg.CreateKey(m_lHive, sKeyPath)
    End Function
    
    Public Function WriteStringValue(ByVal sKeyPath, ByVal sValueName, ByVal sValue)
        WriteStringValue = m_oReg.SetStringValue(m_lHive, sKeyPath, sValueName, sValue)
    End Function
    
    Public Function DeleteValue(ByVal sKeyPath, ByVal sValueName)
        DeleteValue = m_oReg.DeleteValue(m_lHive, sKeyPath, sValueName)
    End Function
    
    Public Function ReadBinaryValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aData
        lResult = m_oReg.GetBinaryValue(m_lHive, sKeyPath, sValueName, aData)
        ReadBinaryValue = aData
    End Function

End Class

Function ArraysAreIntersected(ByRef arrA, ByRef arrB)
    Dim itemA, itemB
    ArraysAreIntersected = False
    For Each itemA in arrA
        For Each itemB in arrB
            If itemA = itemB Then
                ArraysAreIntersected = True
                Exit Function
            End If
        Next
    Next
End Function

Function ArrayContains(ByRef arr, ByRef searchItem)
    ArrayContains = False
    Dim item
    For Each item In arr
        If item = searchItem Then
            ArrayContains = True
            Exit Function
        End If
    Next
End Function

Function GetDriverVersionObj(oVersion)
    Dim tpName, vVersion
    tpName = TypeName(oVersion)
    Select Case tpName
    Case &quot;DriverVersion&quot;
        Set vVersion = oVersion
    Case &quot;String&quot;
        Set vVersion = (new DriverVersion)(oVersion)
    Case Else
        Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Parameter is not an instance of type DriverVersion.&quot;)
    End Select
    Set GetDriverVersionObj = vVersion
End Function

Class DriverVersion
    Private m_major
    Private m_minor
    Private m_build
    Private m_revision
    
    Public Default Function Init(versionStr)
        Parse(versionStr)
        Set Init = Me
    End Function

    Private Sub Parse(vStr)
        Dim parts, versionRegex, oRegex, matches
        Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{1,8})(.\d{1,8}){0,3}$&quot;
        Set matches = oRegex.Execute(vStr)
        If matches.Count = 0 Then
            Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Invalid version string.&quot;)
        End If
        parts = Split(vStr, &quot;.&quot;)
        m_major = CLng(parts(0))
        m_minor = 0
        m_build = 0
        m_revision = 0
        IF UBound(parts) &gt;= 1 Then
            m_minor = CLng(parts(1))
            If UBound(parts) &gt;= 2 Then
                m_build = CLng(parts(2))
                If UBound(parts) &gt;= 3 Then
                    m_revision = CLng(parts(3))
                End If
            End If
        End If
    End Sub

    Public Function CompareTo(v)
        Dim d
        d = m_major - v.Major
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_minor - v.Minor
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_build - v.Build
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_revision - v.Revision
        CompareTo = d
    End Function
    
    Public Function ToString()
        ToString = &quot;&quot; &amp; m_major &amp; &quot;.&quot; &amp; m_minor &amp; &quot;.&quot; &amp; m_build &amp; &quot;.&quot; &amp; m_revision
    End Function

    Public Property Get Major()
        Major = m_major
    End Property

    Public Property Get Minor()
       Minor = m_minor
    End Property

    Public Property Get Build()
       Build = m_build
    End Property

    Public Property Get Revision()
       Revision = m_revision
    End Property
End Class

Class VersionRange
    Private m_startVersion
    Private m_endVersion

    Public Default Function Init(sStartVersion, sEndVersion)
        Set m_startVersion = GetDriverVersionObj(sStartVersion)
        Set m_endVersion = GetDriverVersionObj(sEndVersion)
        Set Init = Me
    End Function

    Public Property Get StartVersion()
        Set StartVersion = m_startVersion
    End Property

    Public Property Get EndVersion()
        Set EndVersion = m_endVersion
    End Property
End Class

Class DriverItem
    Private m_name
    Private m_nameVersion
    Private m_driverVersion
    Private m_parseObject

    Public Default Function Init(sName, oNameVersion, oDriverVersion, ByRef oParseObject)
        m_Name = sName
        Set m_nameVersion = GetDriverVersionObj(oNameVersion)
        Set m_driverVersion = GetDriverVersionObj(oDriverVersion)
        Set m_parseObject = oParseObject
        Set Init = Me
    End Function 

    Public Property Get Name()
        Name = m_name
    End Property

    Public Property Get NameVersion()
        Set NameVersion = m_nameVersion
    End Property

    Public Property Get DriverVersion()
        Set DriverVersion = m_driverVersion
    End Property
    
    Public Property Get ParseObject()
        Set ParseObject = m_parseObject
    End Property
End Class

Class DriverSelectorRule
    Private m_nameRegexStr
    Private m_nameRegex
    Private m_versionRegexStr
    Private m_versionRegex
    Private m_nameMinVersion
    Private m_nameMaxVersion
    Private m_computerId
    Private m_driverVersionArr

    Public DriverCollection
    Public IsNativeClient

    Public Default Function Init(sNameRegex, sVersionRegex, sNameMinVersion, sNameMaxVersion, oVersionRangeArray)
        m_computerId = &quot;.&quot;
        m_nameRegexStr = sNameRegex
        Set m_nameRegex = New RegExp
        m_nameRegex.Pattern = m_nameRegexStr
        m_versionRegexStr = sVersionRegex
        If Not IsNull(m_versionRegexStr) Then
            If Len(m_versionRegexStr) &gt; 0 Then
                Set m_versionRegex = New RegExp
                m_versionRegex.Pattern = m_versionRegexStr
                m_versionRegex.Global = True
            End If
        End If
        Set m_nameMinVersion = GetDriverVersionObj(sNameMinVersion)
        Set m_nameMaxVersion = GetDriverVersionObj(sNameMaxVersion)
        m_driverVersionArr = oVersionRangeArray

        DriverCollection = Array()
        IsNativeClient = False
        Set Init = Me
    End Function

     Private Function CheckVersion(oVersion, vMinVersion, vMaxVersion)
        Dim vVersion: Set vVersion = GetDriverVersionObj(oVersion)
        CheckVersion = vVersion.CompareTo(vMinVersion) &gt;= 0 And (vVersion.ToString() = MAX_DRIVER_VERSION_STR Or vMinVersion.CompareTo(vMaxVersion) = 0 Or vVersion.CompareTo(vMaxVersion) &lt; 0)
    End Function

    Public Function MatchName(sDriverName)
        Dim matches
        Set matches = m_nameRegex.Execute(sDriverName)
        If matches.Count &gt; 0 Then
            MatchName = True
            Exit Function
        End If
        MatchName = False
    End Function

    Public Function GetNameVersion(sDriverName)
        Dim sVersion, matches
        If Not IsNull(m_versionRegexStr) Then
            Set matches = m_versionRegex.Execute(sDriverName)
            If matches.Count &gt; 0 Then
                sVersion = matches(0).Value
            End If   
        End If
        If Not IsNull(sVersion) Then
            Set GetNameVersion = GetDriverVersionObj(sVersion)
        Else
            Set GetNameVersion = GetDriverVersionObj(&quot;0&quot;)
        End If
    End Function

    Public Function CheckNameVersion(oVersion)
        CheckNameVersion = CheckVersion(oVersion, m_nameMinVersion, m_nameMaxVersion)
    End Function

    Public Function CheckDriverVersion(oVersion)
        CheckDriverVersion = False
        Dim driverVersionItem
        For Each driverVersionItem In m_driverVersionArr
             If CheckVersion(oVersion, driverVersionItem.StartVersion, driverVersionItem.EndVersion) Then
                CheckDriverVersion = True
                Exit For
            End If
        Next
    End Function

    Public Function GetDriverVersion(sDriverName)
        Dim computerId, driverPath, sDllVersion, objFSO, oRegistry
        Dim HKEY_LOCAL_MACHINE: HKEY_LOCAL_MACHINE = &amp;H80000002
        Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\&quot; &amp; sDriverName, &quot;Driver&quot;, driverPath   
        Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;) 
        sDllVersion =  objFSO.GetFileVersion(driverPath)
        Set GetDriverVersion = (new DriverVersion)(sDllVersion)
    End Function

    Public Sub AddDriver(ByRef oDriver)
        ReDim Preserve DriverCollection(UBound(DriverCollection) + 1) 
        Set DriverCollection(UBound(DriverCollection)) = oDriver
    End Sub

    Public Sub ResetState()
        DriverCollection = Array()
    End Sub

    Public Property Get DriverNameRegex()
        DriverNameRegex = m_nameRegexStr
    End Property

    Public Property Get NameMinVersion()
        Set NameMinVersion= m_nameMinVersion
    End Property

    Public Property Get NameMaxVersion()
        Set NameMaxVersion = m_nameMaxVersion
    End Property

    Public Property Get VersionRangeCollection()
        VersionRangeCollection = m_driverVersionArr
    End Property

    Public Property Get CollectionIsEmpty()
        CollectionIsEmpty = UBound(DriverCollection) &lt; 0
    End Property
End Class

Class DriverSelector
	Private m_computerId
    Private m_selectorRules(3)
    Private m_selectedDriverName
    Private m_processed
    Private HKEY_LOCAL_MACHINE
    Private m_defaultDriverName

    Private m_ncli_ForceProtocolEncryption
    Private m_ncli_TrustServerCertificate

    Private m_ncli_tcpProtocolEnabled
    Private m_ncli_smProtocolEnabled

    Public ErrorCollection

    Private Sub Class_Initialize()
        Set m_selectorRules(0) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;,&quot;\d{1,8}(\.\d{1,8})?$&quot;, &quot;11.0&quot;, &quot;11.0&quot;,_
            Array(_
               (new VersionRange)(&quot;2011.110.6020.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2011.110.5592.0&quot;, &quot;2011.110.6000.0&quot;),_
               (new VersionRange)(&quot;2011.110.5347.0&quot;, &quot;2011.110.5522.0&quot;)))
        m_selectorRules(0).IsNativeClient = True
        Set m_selectorRules(1) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;11.0&quot;, MAX_DRIVER_VERSION_STR,_
            Array(_
               (new VersionRange)(&quot;2014.120.4219.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2014.120.2546.0&quot;, &quot;2014.120.4000.0&quot;)))
        Set m_selectorRules(2) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;, &quot;\d{1,8}(\.\d{1,8})?$&quot;,&quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
        m_selectorRules(2).IsNativeClient = True
        Set m_selectorRules(3) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
		
        m_computerId = &quot;.&quot;
        m_defaultDriverName = &quot;SQL Server&quot;
        HKEY_LOCAL_MACHINE = &amp;H80000002
        m_ncli_ForceProtocolEncryption = False
        m_ncli_TrustServerCertificate = False
        m_ncli_tcpProtocolEnabled  = True
        m_processed = False
        Call ResetState()
    End Sub

    &apos; Select most appropriate driver from filtered installed system (ODBC) drivers.
    &apos; select all available drivers
    &apos; Filter by driver name and version
    &apos; Intersected: check client and server have shared protocols
    &apos; tcp and np (Named Pipes) can work by network, sm can work only locally
    &apos; driver priorities: sm, tcp; np not used
    &apos; 
    &apos; For native client need common client and server protocols
    &apos; 
    &apos; Select latest namespace with highest version
    &apos; Select client protocols
    &apos; Select server protocols (enabled)
    &apos; Intersect client and server protocols
    &apos; Select odbc drivers related to inresected protocols
    &apos; We have 3 possible drivers:
    &apos; - ODBC (all protocols enabled)
    &apos; - Native Client (tcp, sm, np protocols)
    &apos;      only native client can choose protocols through registry settings
    &apos; - Microsoft SQL Server (all protocols enabled)
	Public Sub ProcessDrivers(enabledServerProtocols)
        Dim ri, i, isSelected, currentSelect, oError
        Set oError = New Error
        Call ResetState()
        On Error Resume Next

        Dim client: Set client = GetClientParameters()

        Dim ncProtocolsAreIntersected: ncProtocolsAreIntersected = ArraysAreIntersected(enabledServerProtocols, client.Protocols)
		Call ProcessSystemOdbcDrivers(ncProtocolsAreIntersected)

        oError.Save
        If oError.Number &lt;&gt; 0 Then
            Call AddError(oError)
            m_selectedDriverName = m_defaultDriverName
            m_processed = true
            Exit Sub
        End If
        On Error GoTo 0
        
        Dim driver: Set driver = SelectFreshDriver(m_selectorRules)

        If Not driver Is Nothing Then
            If driver.ParseObject.IsNativeClient Then
                client.IsTcpProtocolEnabled = ArrayContains(client.Protocols, &quot;tcp&quot;)
                client.IsSharedMemoryProtocolEnabled = ArrayContains(client.Protocols, &quot;sm&quot;)
            End If
        End If

        If Not driver Is Nothing Then
            client.DriverName = driver.Name
        End If

        &apos; for compatibility fill deprecated
        m_selectedDriverName = client.DriverName
        m_ncli_ForceProtocolEncryption = client.IsForceProtocolEncryption
        m_ncli_TrustServerCertificate = client.IsTrustServerCertificate
        m_ncli_tcpProtocolEnabled = client.IsTcpProtocolEnabled
        m_ncli_smProtocolEnabled = client.IsSharedMemoryProtocolEnabled

        m_processed = True
	End Sub

    Private Function SelectFreshDriver(rules)
        Set SelectFreshDriver = Nothing
        Dim selected: Set selected = Nothing
        Dim rule: Set selected = Nothing
        Dim driver: Set selected = Nothing

        For Each rule In rules
            For Each driver In rule.DriverCollection
                &apos; select first if not selected
                If selected Is Nothing Then
                    Set selected = driver
                Else
                    &apos; select fresh, compare driver with selected by name and
                    &apos; version
                    if driver.NameVersion.CompareTo(selected.NameVersion) &gt;= 0 And _
                        driver.DriverVersion.CompareTo(selected.DriverVersion) &gt;= 0 Then
                        Set selected = driver
                    End If
                End If
            Next

            &apos; all rules have order by priority, if rule contains drivers, then
            &apos; selected with high priority
            if Not selected Is Nothing Then
                Exit For
            End If
        Next

        Set SelectFreshDriver = selected
    End Function

    Private Function GetClientParameters()
        Set GetClientParameters = Nothing
        Dim params: Set params = (New ConnectionParams)(&quot;.&quot;)
        params.Namespace = GetNsNameWithHighestVersion()
        Call GetNativeClientSettings(params.Namespace, params)
        params.Protocols = GetEnabledNativeClientProtocols(params.Namespace)
        Set GetClientParameters = params
    End Function
	
    Private Sub ProcessOdbcDriver(driverName, protocolsAreIntersected)
        Dim isInstalled, oRegistry, oNameVersion, oDriverVersion
        Set oRegistry = GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)
        
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverName, isInstalled 
        Dim selectorRule
        For Each selectorRule In m_selectorRules
            If (isInstalled &lt;&gt; &quot;Installed&quot;) Then
                Exit For
            End If
            If selectorRule.MatchName(driverName) Then
                If (Not selectorRule.IsNativeClient) Or (selectorRule.IsNativeClient And protocolsAreIntersected) Then
                    Set oNameVersion = selectorRule.GetNameVersion(driverName)
                    If (selectorRule.CheckNameVersion(oNameVersion)) Then
                        Set oDriverVersion = selectorRule.GetDriverVersion(driverName)
                        If (selectorRule.CheckDriverVersion(oDriverVersion)) Then
                            selectorRule.AddDriver((new DriverItem)(driverName, oNameVersion, oDriverVersion, selectorRule))
                            Exit For
                        End If
                    End If
                End If
            End If
        Next
    End Sub

    &apos; Get available drivers in the system and fill rules drivers
    &apos; TODO: rename method
	Private Sub ProcessSystemOdbcDrivers(protocolsAreIntersected)
        Dim oRegistry, driverNames, paramValueTypes, i, oError
        Set oError = New Error
		Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
		Call oRegistry.EnumValues(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverNames, paramValueTypes)
		On Error Resume Next

        Dim driverName
        For Each driverName In driverNames
            oError.Clear
            Call ProcessOdbcDriver(driverName, protocolsAreIntersected)
            oError.Save
            If oError.Number &lt;&gt; 0 Then
                Call AddError(oError)
            End If
		Next
	End Sub
	
    Private Function GetNsNameWithHighestVersion()
        Dim rootNs: rootNs = &quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\Microsoft\SqlServer&quot;
        Dim oWMI: Set oWMI = GetObject(rootNs)
        Dim namespaces: Set namespaces = oWMI.ExecQuery(&quot;SELECT Name FROM __NAMESPACE WHERE Name LIKE &apos;ComputerManagement%&apos;&quot;)
        Dim currentName: currentName = &quot;&quot;
        Dim objItem
	    For Each objItem In namespaces
            If objItem.Name &gt; currentName Then
                currentName = objItem.Name
            End If
        Next
        GetNsNameWithHighestVersion = rootNs &amp; &quot;\&quot; &amp; currentName
    End Function

    Private Sub GetNativeClientSettings(namespaceFullName, params)
        On Error Resume Next
        Err.Clear

        Dim sNamespace, oWMI, objClasses, sState, sTargetComputer
        Set oWMI = GetObject(namespaceFullName)
        Set objClasses = Nothing

        &apos; query can fail, because native client not supported
        Set objClasses = oWMI.ExecQuery(&quot;SELECT FlagName, FlagValue FROM ClientSettingsGeneralFlag&quot;)

        &apos; do nothing, its ok, just skip this settings
        If (Err.Number &lt;&gt; 0) Or (objClasses Is Nothing) Then
            Exit Sub
        End If

        Dim objItem
        For Each objItem in objClasses
            Select Case objItem.FlagName
            Case &quot;Force protocol encryption&quot;
                &apos;m_ncli_ForceProtocolEncryption = objItem.FlagValue
                params.IsForceProtocolEncryption = objItem.FlagValue
            Case &quot;Trust Server Certificate&quot;
                &apos;m_ncli_TrustServerCertificate = objItem.FlagValue
                params.IsTrustServerCertificate = objItem.FlagValue
            End Select
        Next
    End Sub   

    Private Function GetEnabledNativeClientProtocols(namespaceFullName)
        On Error Resume Next
        Err.Clear

        Dim oWMI: Set oWMI = GetObject(namespaceFullName)  
        Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, ProtocolOrder FROM ClientNetworkProtocol&quot;)

        If (oQuery.Count &gt; 0) And (Err.Number Is 0) Then
            Dim protocolsArr: Set protocolsArr = New ArrayList
            Dim protocolItem
            For Each protocolItem In oQuery
                If protocolItem.ProtocolOrder &gt; 0 Then
                    protocolsArr.Add LCase(protocolItem.ProtocolName)
                End If
            Next
            GetEnabledNativeClientProtocols = protocolsArr.ItemsArray
        Else
            GetEnabledNativeClientProtocols = Array()
        End If
    End Function

    Private Sub AddError(oError)
        Dim newSize
        newSize = UBound(ErrorCollection) + 1
        ReDim Preserve ErrorCollection(newSize)
        ErrorCollection(newSize) = &quot;[&quot; &amp; (oError.Number and 65535) &amp; &quot;][&quot; &amp; oError.Source &amp; &quot;] &quot; &amp; oError.Description 
    End Sub

    Private Sub ResetState()
        Dim pr
        ErrorCollection = Array()
        For Each pr In m_selectorRules
            pr.ResetState()
        Next
    End Sub

    Private Sub ThrowIfNotProcessed()
        If Not m_processed Then
            Call Err.Raise(SCRIPT_EVENT_ID, &quot;&quot;, &quot;Drivers are not processed. Call &apos;ProcessDrivers&apos; first.&quot;)
        End If
    End Sub

    Public Property Get HasErrors()
        HasErrors = UBound(ErrorCollection) &gt;= 0
    End Property

    Public Property Get DriverName()
        ThrowIfNotProcessed
        DriverName = m_selectedDriverName
    End Property 

    Public Property Get UseFqdn()
        ThrowIfNotProcessed
        UseFqdn = m_ncli_ForceProtocolEncryption And Not m_ncli_TrustServerCertificate
    End Property

    Public Property Get ClientTcpProtocolEnabled()
        ThrowIfNotProcessed
        ClientTcpProtocolEnabled = m_ncli_tcpProtocolEnabled
    End Property

    Public Property Get ClientSharedMemoryProtocolEnabled()
        ThrowIfNotProcessed
        ClientSharedMemoryProtocolEnabled = m_ncli_smProtocolEnabled
    End Property
End Class

Class ConnectionParams
    Public ComputerName
    Public DriverName
    Public Namespace
    Public IsForceProtocolEncryption
    Public IsTrustServerCertificate
    Public IsTcpProtocolEnabled
    Public IsSharedMemoryProtocolEnabled
    Public Protocols

    Public Default Function Init(sComputerName)
        ComputerName = sComputerName
        DriverName = DriverSelector_DEFAULT_DRIVER_NAME
        Namespace = &quot;&quot;
        IsForceProtocolEncryption = False
        IsTrustServerCertificate = False
        IsTcpProtocolEnabled = True
        IsSharedMemoryProtocolEnabled = True
        Set Init = Me
    End Function
End Class

Class UniqueCollection
    Private m_dict

    Public Default Function Init()
        Set m_dict = CreateObject(&quot;Scripting.Dictionary&quot;)
        Set Init = Me
    End Function

    Public Sub PutItem(item)
       If Not m_dict.Exists(item) Then
            m_dict.add item, &quot;&quot;
       End If
    End Sub
	
	Public Function Exists(item)
		Exists = m_dict.Exists(item)
	End Function
	
    Public Function GetItems()
        GetItems = m_dict.Keys()
    End Function

    Public Sub Clear()
        m_dict.RemoveAll()
    End Sub
End Class

Class SqlServerTcpIpSettings
    Private m_listenAllIPs
    Private m_ipSettings

    Public Default Function Init(listenAllIps, ipSettings)
        m_listenAllIPs = listenAllIps
        Set m_ipSettings = ipSettings
        Set Init = Me
    End Function

    Public Property Get ListenAllIPs()
        ListenAllIPs = m_listenAllIPs
    End Property

    Public Property Get IpSettings()
        Set IpSettings = m_ipSettings
    End Property
End Class

Function EscapeConnStringValue (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeConnStringValue  = &quot;{&quot; + Replace(strValue, &quot;}&quot;, &quot;}}&quot;) + &quot;}&quot;
End Function

Function EscapeWQLString (ByVal strValue)
	ON ERROR RESUME NEXT
	Err.Clear

	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function furlEncode(vString,vEncDec)
    Dim i
    Dim aReserved(24,1)
    &apos;column 1
    aReserved(0,0) = &quot;%&quot; &apos;25
    aReserved(1,0) = &quot;;&quot; &apos;3B
    aReserved(2,0) = &quot;/&quot; &apos;2F
    aReserved(3,0) = &quot;?&quot; &apos;3F
    aReserved(4,0) = &quot;:&quot; &apos;3A
    aReserved(5,0) = &quot;@&quot; &apos;40
    aReserved(6,0) = &quot;&amp;&quot; &apos;26
    aReserved(7,0) = &quot;=&quot; &apos;3D
    aReserved(8,0) = &quot;+&quot; &apos;2B
    aReserved(9,0) = &quot;$&quot; &apos;24
    aReserved(10,0) = &quot;,&quot; &apos;2C
    aReserved(11,0) = &quot; &quot; &apos;20
    aReserved(12,0) = &quot;&quot;&quot;&quot; &apos;22
    aReserved(13,0) = &quot;&lt;&quot; &apos;3C
    aReserved(14,0) = &quot;&gt;&quot; &apos;3E
    aReserved(15,0) = &quot;#&quot; &apos;23
    aReserved(16,0) = &quot;{&quot; &apos;7B
    aReserved(17,0) = &quot;}&quot; &apos;7D
    aReserved(18,0) = &quot;|&quot; &apos;7C
    aReserved(19,0) = &quot;\&quot; &apos;5C
    aReserved(20,0) = &quot;^&quot; &apos;5E
    aReserved(21,0) = &quot;~&quot; &apos;7E
    aReserved(22,0) = &quot;[&quot; &apos;5B
    aReserved(23,0) = &quot;]&quot; &apos;5D
    aReserved(24,0) = &quot;`&quot; &apos;60
    &apos;column 2
    aReserved(0,1) = &quot;%25&quot;
    aReserved(1,1) = &quot;%3B&quot;
    aReserved(2,1) = &quot;%2F&quot;
    aReserved(3,1) = &quot;%3F&quot;
    aReserved(4,1) = &quot;%3A&quot;
    aReserved(5,1) = &quot;%40&quot;
    aReserved(6,1) = &quot;%26&quot;
    aReserved(7,1) = &quot;%3D&quot;
    aReserved(8,1) = &quot;%2B&quot;
    aReserved(9,1) = &quot;%24&quot;
    aReserved(10,1) = &quot;%2C&quot;
    aReserved(11,1) = &quot;%20&quot;
    aReserved(12,1) = &quot;%22&quot;
    aReserved(13,1) = &quot;%3C&quot;
    aReserved(14,1) = &quot;%3E&quot;
    aReserved(15,1) = &quot;%23&quot;
    aReserved(16,1) = &quot;%7B&quot;
    aReserved(17,1) = &quot;%7D&quot;
    aReserved(18,1) = &quot;%7C&quot;
    aReserved(19,1) = &quot;%5C&quot;
    aReserved(20,1) = &quot;%5E&quot;
    aReserved(21,1) = &quot;%7E&quot;
    aReserved(22,1) = &quot;%5B&quot;
    aReserved(23,1) = &quot;%5D&quot;
    aReserved(24,1) = &quot;%60&quot;

    For i = 0 to Ubound(aReserved)
        If vEncDec = &quot;enc&quot; Then
        vString = Replace(vString,aReserved(i,0),aReserved(i,1))
        End If
        If vEncDec = &quot;dec&quot; Then
        vString = Replace(vString,aReserved(i,1),aReserved(i,0))
        End If
    Next

    furlEncode = vString
End Function

Class UtcDateOperations
    Private m_wbemDate

    Private Sub Class_Initialize()
        Set m_wbemDate = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
    End Sub

    Public Function DateToIso8601UtcString(objDate)
        DateToIso8601UtcString = _
            DatePart(&quot;yyyy&quot;, objDate) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;m&quot;, objDate), 2) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;d&quot;, objDate), 2) &amp;_
            &quot;T&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;h&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;n&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;s&quot;, objDate), 2) &amp;_
            &quot;Z&quot;
    End Function

    Public Function Iso8601UtcStringToDate(sDate)
        Dim oRegex: Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{4})-(\d\d)-(\d\d)(?:T|\s)(\d\d):(\d\d):(\d\d)Z$&quot; 
        
        Dim matches: Set matches = oRegex.Execute(sDate)
        If matches.Count = 0 Then
            Err.Raise 4000, &quot;&quot;, &quot;Input date string is in invalid format&quot;
        End If
        
        Dim year: year = CInt(matches(0).SubMatches(0))
        Dim month: month = CInt(matches(0).SubMatches(1))
        Dim day: day = CInt(matches(0).SubMatches(2))

        Dim hour: hour = CInt(matches(0).SubMatches(3))
        Dim minute: minute = CInt(matches(0).SubMatches(4))
        Dim second: second = CInt(matches(0).SubMatches(5))

        Dim resDate: resDate = DateSerial(year, month, day)
        resDate = DateAdd(&quot;h&quot;, hour, resDate)
        resDate = DateAdd(&quot;n&quot;, minute, resDate)
        resDate = DateAdd(&quot;s&quot;, second, resDate)

        Iso8601UtcStringToDate = resDate
    End Function

    Public Function GetUtcNow()
        m_wbemDate.SetVarDate(Now())
        GetUtcNow = CDate(m_wbemDate.GetVarDate(false))
    End function

    Public Function CheckSecondsElapsed(sDate, nSeconds)
        Dim utcNow: utcNow = Me.GetUtcNow
        Dim utcDate: utcDate = Iso8601UtcStringToDate(sDate)
        CheckSecondsElapsed = DateDiff(&quot;s&quot;,utcDate,utcNow) &gt; nSeconds
    End function
End Class

Function GetCacheKey(stateMpPrefix, sKeyName)
    Dim oApi: Set oApi = CreateObject(&quot;MOM.ScriptAPI&quot;)
    Dim regKey: regKey = oAPI.GetScriptStateKeyPath(ManagementGroupID)
    regKey = regKey &amp; &quot;\&quot; &amp; stateMpPrefix &amp; &quot;\&quot; &amp; sKeyName
    GetCacheKey = regKey
End Function

Function GetStringValueFromCache(sKeyName, sValueName, cacheExpirationTime)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)
        
    Dim lErrCode
    Dim sDate: sDate = oReg.ReadStringValue(regKey, sDateValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    Dim sValue: sValue = oReg.ReadStringValue(regKey, sValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    If udo.CheckSecondsElapsed(sDate, cacheExpirationTime) Then
        Exit Function
    End If

    GetStringValueFromCache = sValue
End Function

Function PutStringValueToCache(sKeyName, sValueName, sValue)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    Dim dUtcNow: dUtcNow = udo.GetUtcNow()

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)

    Call oReg.CreateKey(regKey)

    Dim lErrCode
    
    Call oReg.WriteStringValue(regKey, sValueName, sValue)
    Call oReg.WriteStringValue(regKey, sDateValueName, udo.DateToIso8601UtcString(dUtcNow))
End Function

Function GetWMISingleValue(wmiProvider, query, propertyName)
    Dim oQuery: Set oQuery = wmiProvider.ExecQuery(query)
    If oQuery.Count = 0 Then
        Err.Raise 4000, &quot;&quot;, &quot;Query &apos;&quot; &amp; query &amp; &quot;&apos; didn&apos;t return any objects&quot;
    End If
    Dim colSettings: Set colSettings = GetFirstItemFromWMIQuery(oQuery)
    GetWMISingleValue = colSettings.Properties_.Item(propertyName).Value
End Function

Class HostNameData
    Public HostName
    Public IsClustered

    Public Default Function Init(sHostName, bIsClustered)
        Me.HostName = sHostName
        Me.IsClustered = bIsClustered
        Set Init = Me
    End function
End Class

Function GetSqlServerHostName(strDNSComputerName, instanceName, namespace)
    Set GetSqlServerHostName = Nothing
    Dim serviceName: serviceName = GetSQLServiceName(instanceName)
    Dim escapedServiceName: escapedServiceName = EscapeWQLString(serviceName)
    
    Dim wmiProvider: Set wmiProvider = ConnectToWMI(strDNSComputerName, &quot;ROOT\Microsoft\SqlServer\&quot; + namespace)

    Dim isClustered: isClustered = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyNumValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;CLUSTERED&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyNumValue&quot;)

    Dim hostName
    If isClustered = 0 Then
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT HostName FROM SqlService WHERE SQLServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;HostName&quot;)
    Else
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyStrValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;VSNAME&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyStrValue&quot;)
    End If

    Set GetSqlServerHostName = (New HostNameData)(hostName, CBool(isClustered))
End Function

Function EscapeCacheValueName(name)
    EscapeCacheValueName = Replace(name, &quot;_&quot;, &quot;__&quot;)
End Function

Function GetSqlServerHostNameEx(strDNSComputerName, instanceName, namespace)
    Set GetSqlServerHostNameEx = Nothing
    Dim cacheExpirationTime: cacheExpirationTime = 7200
    Dim hostValueName: hostValueName = EscapeCacheValueName(strDNSComputerName)
    Dim isClusteredValueName: isClusteredValueName = hostValueName &amp; &quot;_IsClustered&quot;
    Dim isClusteredStr

    On Error Resume Next
    Call Err.Clear()
    Dim hostName: hostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    If Err.Number = 0 And Not IsEmpty(hostName) Then
        isClusteredStr = GetStringValueFromCache(&quot;SqlHostNames&quot;, isClusteredValueName, cacheExpirationTime)
        If Err.Number = 0 And Not IsEmpty(isClusteredStr) Then
            If isClusteredStr = &quot;0&quot; Or isClusteredStr = &quot;1&quot; Then
                Set GetSqlServerHostNameEx = (New HostNameData)(hostName, CBool(isClusteredStr))
                Exit Function
            End If
        End If
    End If
    Call Err.Clear()

    On Error GoTo 0
    Dim hostNameData: Set hostNameData = GetSqlServerHostName(strDNSComputerName, instanceName, namespace)

    If hostNameData.IsClustered Then 
        isClusteredStr = &quot;1&quot;
    Else 
        isClusteredStr = &quot;0&quot;
    End If

    On Error Resume Next
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, hostValueName, hostNameData.HostName)
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, isClusteredValueName, isClusteredStr)
    
    Call Err.Clear()

    Set GetSqlServerHostNameEx = hostNameData
End function

Function GetLocalHostName()
    Dim wshShell: Set wshShell = CreateObject( &quot;WScript.Shell&quot; )
    GetLocalHostName = wshShell.ExpandEnvironmentStrings(&quot;%COMPUTERNAME%&quot;)
End Function

Function DelimitSqlIdentifier(identifier)
    DelimitSqlIdentifier = &quot;[&quot; + Replace(identifier, &quot;]&quot;, &quot;]]&quot;) + &quot;]&quot;
End Function

Function SqlTcpPortIsEmpty(tcpPort)
    SqlTcpPortIsEmpty = (IsEmpty(tcpPort) Or tcpPort = &quot;&quot; Or tcpPort = &quot;0&quot;)
End Function

Function GetDataSource(server, tcpPort)
    Dim dataSource : dataSource = server
    If Not SqlTcpPortIsEmpty(tcpPort) Then
        Dim nameParts : nameParts = Split(dataSource, &quot;\&quot;)
        dataSource = nameParts(0) &amp; &quot;,&quot; &amp; tcpPort
    End If
    GetDataSource = dataSource
End Function

Function BuildDataSourceFromParts(computerName, instanceName, tcpPort)
    Dim dataSource : dataSource = computerName
    If instanceName &lt;&gt; &quot;MSSQLSERVER&quot; Then
        dataSource = computerName &amp; &quot;\&quot; &amp; instanceName
    End If
    BuildDataSourceFromParts = GetDataSource(dataSource, tcpPort)
End Function

Function GetConnectionString(driverName, dataSource, databaseName, intent)
    GetConnectionString = &quot;Driver=&quot; &amp; EscapeConnStringValue(driverName) &amp; &quot;;Server=&quot; &amp; EscapeConnStringValue(dataSource) &amp; &quot;;Database=&quot; &amp; EscapeConnStringValue(databaseName) &amp; &quot;;Trusted_Connection=yes;ApplicationIntent=&quot; &amp; intent
End Function

Function GetEnabledSqlServerProtocols(namespaceName, computerName, instanceName)
    Dim oWMI: Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot; &amp; namespaceName)  
    Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, Enabled FROM ServerNetworkProtocol WHERE InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos;&quot;)
    If oQuery.Count &gt; 0 Then
        Dim protocolsArr: Set protocolsArr = New ArrayList
        Dim protocolItem
        For Each protocolItem In oQuery
            If protocolItem.Enabled Then
                protocolsArr.Add LCase(protocolItem.ProtocolName)
            End If
        Next
        GetEnabledSqlServerProtocols = protocolsArr.ItemsArray
    Else
        GetEnabledSqlServerProtocols = Array()
    End If
End Function

Function GetSqlServerTcpIpSettings(instanceName, computerName)
    ON ERROR RESUME NEXT
    Dim oWMI, oQuery, tcpItem
    Dim i, j
    Dim uc: Set uc = (new UniqueCollection)()
    Dim isListenAll: isListenAll = False
    Dim ipSettings: Set ipSettings = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot;&amp; SQL_WMI_NAMESPACE)  

    Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND PropertyName = &apos;ListenOnAllIPs&apos;&quot;)

    If oQuery.Count &gt;0 Then
        Dim isListenAllObj: Set isListenAllObj = GetFirstItemFromWMIQuery(oQuery)
        If isListenAllObj.PropertyNumVal = 1 Then
            isListenAll  = True
        End If
    End If

    Dim tcpPorts, tcpPort, processedPort
        
    If isListenAll Then
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;IPAll&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
        If oQuery.Count &gt; 0 Then
            For Each tcpItem In oQuery
                tcpPorts = Split(tcpItem.PropertyStrVal,&quot;,&quot;)
                For Each tcpPort In tcpPorts
            	    processedPort = Trim(tcpPort)
            	    If Not SqlTcpPortIsEmpty(processedPort) Then
                	    uc.PutItem(processedPort)
                    End If
                Next
            Next
            ipSettings.add &quot;IPAll&quot;, uc.GetItems()
        End If
    Else
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName &lt;&gt; &apos;&apos; AND PropertyName = &apos;Enabled&apos; AND PropertyNumVal = 1&quot;) 
        Dim ipItem
        If oQuery.Count &gt; 0 Then
            For Each ipItem In oQuery
                Dim ipAddressName : ipAddressName = ipItem.IPAddressName
                Dim oQuery2 : Set oQuery2 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot; &amp; EscapeWQLString(instanceName) &amp; &quot;&apos; AND IPAddressName = &apos;&quot; &amp; EscapeWQLString(ipAddressName) &amp; &quot;&apos; AND PropertyName = &apos;IpAddress&apos; AND PropertyStrVal != &apos;&apos;&quot;)
                If oQuery2.Count &gt; 0 Then
                    Dim ipAddress : ipAddress = GetFirstItemFromWMIQuery(oQuery2).PropertyStrVal
                    Dim oQuery3: Set oQuery3 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;&quot;&amp; EscapeWQLString(ipAddressName) &amp;&quot;&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
                    If oQuery3.Count &gt; 0 Then 
                        uc.Clear()
                        Dim portItem
                        For Each portItem In oQuery3
                            tcpPorts = Split(portItem.PropertyStrVal,&quot;,&quot;)
                            For Each tcpPort In tcpPorts
                            	processedPort = Trim(tcpPort)
                                If Not SqlTcpPortIsEmpty(processedPort) Then
				                	uc.PutItem(processedPort)
				                End If
                            Next
                            ipSettings.add ipAddress, uc.GetItems()
                        Next
                    End If
                End If
            Next
        End If
    End If
    Set GetSqlServerTcpIpSettings = (new SqlServerTcpIpSettings)(isListenAll, ipSettings)
End Function

Function GetTcpPortsString(ByVal inputDataSource)
    On Error Resume Next
	Dim computerName, instanceName, pathArray
	
	pathArray = Split(inputDataSource, &quot;\&quot;)
    computerName = pathArray(0)
    instanceName = &quot;MSSQLSERVER&quot;
	If (UBound(pathArray) &gt; 0) Then
	    instanceName = pathArray(1)
	End If

    Dim tcpIpSettings: Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, computerName)
    Dim upc : Set upc = (new UniqueCollection)()
    Dim ip, port
    For Each ip In tcpIpSettings.IpSettings.Keys 
        For Each port In tcpIpSettings.IpSettings.Item(ip)
            upc.PutItem port
        Next
    Next
    GetTcpPortsString = Join(upc.GetItems(),&quot;, &quot;)
End Function

Public Sub SqlTestDestination(dbConnection, hostName, instanceName, isADODB)
    Dim queryServerName, queryInstanceName
    Dim destinationTestQuery: destinationTestQuery = &quot;select CAST(SERVERPROPERTY(&apos;MachineName&apos;) AS nvarchar(128)) as ServerName, @@servicename as InstanceName&quot;
    On Error Goto 0
    If 0 = Err.number Then
        Dim queryResult
        If isADODB Then
            Set queryResult = dbConnection.ExecuteQueryTE(destinationTestQuery)
        Else
            Set queryResult = dbConnection.Execute(destinationTestQuery)
        End If
        If Not queryResult.EOF Then
            queryServerName = UCase(queryResult(&quot;ServerName&quot;).Value)
            queryInstanceName = UCase(queryResult(&quot;InstanceName&quot;).Value)
            If (UCase(hostName) = queryServerName) And (UCase(instanceName) = queryInstanceName) Then
                Exit Sub
            End If
        End If
        dbConnection.Close() 
        Err.Raise 16389, &quot;&quot;, &quot;Connection target check failed: connected to &quot; &amp; hostName &amp; &quot;\&quot; &amp; instanceName &amp; &quot;, but got &quot; &amp; queryServerName &amp; &quot;\&quot; &amp; queryInstanceName &amp; &quot;.&quot;
    End If
End Sub

Sub TryToConnectAndValidate(connectionObj, connectionString, timeout, hostName, instanceName, isADODB)
    On Error GoTo 0
    
    If isADODB Then
        connectionObj.Open connectionString, &quot;&quot;, timeout
    Else
        if (connectionObj.Mode &lt;&gt; 0) then
          connectionObj.Close()
        end if
        connectionObj.ConnectionTimeout = timeout
        connectionObj.Open connectionString
    End If
    SqlTestDestination connectionObj, hostName, instanceName, isADODB
End Sub

Function FormatConnectionErrorMessage(dataSource, lastError)
    FormatConnectionErrorMessage = &quot;Connection to data source &apos;&quot; &amp; dataSource &amp; &quot;&apos; failed: &quot; &amp; lastError.Description
End Function

Function SmartConnectWithoutSQLADODB(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName)    
    Set SmartConnectWithoutSQLADODB = SmartConnectWithoutSQLADODBIntent(inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectWithoutSQLADODBIntent(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName, ByVal intent)
    On Error Resume Next
    Set SmartConnectWithoutSQLADODBIntent = Nothing
    Dim dbMasterConnection, dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList
    
    Set dbMasterConnection = CreateObject(&quot;ADODB.Connection&quot;)

    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName 
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    
    If connectionString  &lt;&gt; &quot;&quot; And timeout  &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate dbMasterConnection, connectionString, timeout, netBiosHostName, instanceName, False
        lastError.Save
        If lastError.Number = 0 Then
            Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If

    Dim ds: Set ds = New DriverSelector

    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Set SmartConnectWithoutSQLADODBIntent = Nothing
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)   

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, machineName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

	
    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate dbMasterConnection, connectionString, 15, netBiosHostName, instanceName, False
    lastError.Save
    If lastError.Number = 0 Then
        Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If

    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
                lastError.Save
                If lastError.Number = 0 Then
                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
                End If
            Next
        Else
    	    &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
	                lastError.Save
	                If lastError.Number = 0 Then
	                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
		                lastError.Save
		                If lastError.Number = 0 Then
		                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Function SmartConnect(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName)    
     SmartConnect = SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, intent)
    On Error Resume Next
    SmartConnectIntent = False
    Dim dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList 
    

    
    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName  
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)

    If connectionString &lt;&gt; &quot;&quot; And timeout &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate cnADOConnection, connectionString, timeout, netBiosHostName, instanceName, True
        lastError.Save
        If lastError.Number = 0 Then
            SmartConnectIntent = True
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If


    Dim ds: Set ds = New DriverSelector

    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, netBiosHostName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate cnADOConnection, connectionString, 15, netBiosHostName, instanceName, True
    lastError.Save
    If lastError.Number = 0 Then
        SmartConnectIntent = True
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If
	
    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
                lastError.Save
                If lastError.Number = 0 Then
                    SmartConnectIntent = True
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
                End If
            Next
        Else
            &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
	                lastError.Save
	                If lastError.Number = 0 Then
	                    SmartConnectIntent = True
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
		                lastError.Save
		                If lastError.Number = 0 Then
		                    SmartConnectIntent = True
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Sub WriteToEventLogAndExit(ByVal message)
    oAPI.LogScriptEvent &quot;Management Group: &quot; &amp; ManagementGroupName &amp; &quot;. Script: &quot; &amp; WScript.ScriptName &amp; &quot;. Version: &quot; &amp; MANAGEMENT_PACK_VERSION, 4002, EVENT_TYPE_ERROR, message   
    WScript.Quit()
End Sub

Function ExtractHostNameFromEndpoint(ByVal sEndpoint)
    If sEndpoint = &quot;&quot; Then
        ExtractHostNameFromEndpoint = &quot;&quot;
        Exit Function
    End If
    Dim oRegEx, oMatches
    Set oRegEx = MomCreateObject(&quot;VBScript.RegExp&quot;)
    oRegEx.Pattern = &quot;://(.+):&quot;
    Set oMatches = oRegEx.Execute(sEndpoint)
    If oMatches.Count &gt; 0 Then
        If oMatches(0).SubMatches.Count &gt; 0 Then
            ExtractHostNameFromEndpoint = oMatches(0).SubMatches(0)
        Else
            ExtractHostNameFromEndpoint = sEndpoint
        End If
    Else
        ExtractHostNameFromEndpoint = sEndpoint
    End If
End Function

Function GetMirroringLevelName(ByVal nSafetyLevel, ByVal sWitnessName)
    GetMirroringLevelName = &quot;Unknown state&quot;
    If nSafetyLevel = 1 Then
        GetMirroringLevelName = &quot;High-performance mode&quot;
    Else
        If sWitnessName = &quot;&quot; Then
            GetMirroringLevelName = &quot;High-safety mode without automatic failover&quot;
        Else
            GetMirroringLevelName = &quot;High-safety mode with automatic failover&quot;
        End If
    End If
End Function

Function IsExcluded(ByVal sDatabase, ByVal sExcludeList)
	Dim aExcludes, bMatch, nIndex

	bMatch = False
	If Trim(sExcludeList) = &quot;*&quot; Then
	    bMatch = True
	Else
		aExcludes = Split(sExcludeList, &quot;,&quot;)
		For nIndex = 0 To UBound(aExcludes)
			If LCase(sDatabase) = LCase(Trim(aExcludes(nIndex))) Then
				bMatch = True
			End If
		Next
	End If
	IsExcluded = bMatch
End Function

                  
                  $Config/ScriptBody$				
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </DataSource>
            </MemberModules>
            <Composition>
              <Node ID="DS" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.SQLServer.Windows.Mirroring.ScriptedStateProvider.DS" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ConnectionString" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MachineName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TcpPorts" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Version" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="ScriptBody" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedScript.PropertyBagProvider">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <ScriptName>$Config/ScriptName$</ScriptName>
                <Arguments>"$Config/ConnectionString$" "$Config/MachineName$" "$Config/InstanceName$" "$Config/TcpPorts$" "$Config/Version$"</Arguments>
                <ScriptBody>&apos;#Include File:Common.vbs
Option Explicit
SetLocale(&quot;en-us&quot;)

Const ManagementGroupName = &quot;$Target/ManagementGroup/Name$&quot;
Const SQL_DEFAULT = &quot;MSSQLSERVER&quot;
Const DEBUG_MODE = False
Const MANAGEMENT_PACK_VERSION = &quot;7.0.20.0&quot;
Const EVENT_TYPE_ERROR = 1
Const MAX_DRIVER_VERSION_STR = &quot;99999999.99999999.99999999.99999999&quot;
Const DriverSelector_DEFAULT_DRIVER_NAME = &quot;SQL Server&quot;

Dim oArgs
Set oArgs = WScript.Arguments
Dim ConnectionString, MachineName, InstanceName, sTcpPort, SQLVersion
ConnectionString = oArgs(0)
MachineName = oArgs(1)
InstanceName = oArgs(2)
sTcpPort = oArgs(3)
SQLVersion = oArgs(4)

Dim SQLVersionArr, SQLMajorVersion, SQL_WMI_NAMESPACE
SQLVersionArr = split(SQLVersion,&quot;.&quot;)
SQLMajorVersion = SQLVersionArr(0)
SQL_WMI_NAMESPACE = &quot;ComputerManagement&quot; &amp; SQLMajorVersion

Dim GlobalErrorList: Set GlobalErrorList = New ArrayList

Dim StartTime,EndTime,sTime
&apos;Capture script start time
StartTime = Now

Dim oAPI
Set oAPI = MOMCreateObject(&quot;MOM.ScriptAPI&quot;)

&apos;Call oAPI.LogScriptEvent("$Config/ScriptName$", 4005, 0, "Starting script. ConnectionString: " &amp; ConnectionString &amp; ". MachineName: " &amp; MachineName &amp; ". InstanceName: " &amp; InstanceName &amp; ". sTcpPort: " &amp; sTcpPort &amp; ". Version: " &amp; SQLVersion &amp; ". SQL_WMI_NAMESPACE: " &amp; SQL_WMI_NAMESPACE)


Function MomCreateObject(ByVal sProgramId)
    Dim oError
    Set oError = New Error
    
	On Error Resume Next
	Set MomCreateObject = CreateObject(sProgramId)
	oError.Save
	On Error Goto 0
	
	If oError.Number &lt;&gt; 0 Then ThrowScriptError &quot;Unable to create automation object &apos;&quot; &amp; sProgramId &amp; &quot;&apos;&quot;, oError
End Function

Public Function GetSQLServiceName(sInstance)
    If sInstance = SQL_DEFAULT Then
        GetSQLServiceName = SQL_DEFAULT
    Else
        GetSQLServiceName = &quot;MSSQL$&quot; &amp; sInstance
    End If
End Function

Function GetServiceState( sTargetComputer, sServiceName)
    On Error Resume Next    

    Dim sNamespace, sQuery, oWMI, objClasses, sState
    sNamespace = &quot;winmgmts://&quot; &amp; sTargetComputer &amp; &quot;/root/cimv2&quot;
    sQuery = &quot;SELECT State FROM Win32_Service where  Name = &quot;&quot;&quot; &amp; EscapeWQLString(sServiceName) &amp; &quot;&quot;&quot;&quot;
    
    Set oWMI = GetObject(sNamespace)
    Set objClasses = oWMI.ExecQuery(sQuery)

    if objClasses.Count &gt;= 1 Then
        sState = GetFirstItemFromWMIQuery(objClasses).Properties_.Item(&quot;State&quot;)
    End If
    
    If Err.number &lt;&gt; 0 Or objClasses.Count = 0 Then
        sState = &quot;Unknown&quot;
    End If 

    Err.Clear
    GetServiceState = sState
End Function

Class Error
    Private m_lNumber
    Private m_sSource
    Private m_sDescription
    Private m_sHelpContext
    Private m_sHelpFile

    Public Sub Save()
        m_lNumber = Err.Number
        m_sSource = Err.Source
        m_sDescription = Err.Description
        m_sHelpContext = Err.HelpContext
        m_sHelpFile = Err.HelpFile
    End Sub

    Public Sub Raise()
        Err.Raise m_lNumber, m_sSource, m_sDescription, m_sHelpFile, m_sHelpContext
    End Sub

    Public Sub Clear()
        m_lNumber = 0
        m_sSource = &quot;&quot;
        m_sDescription = &quot;&quot;
        m_sHelpContext = &quot;&quot;
        m_sHelpFile = &quot;&quot;
    End Sub

    Public Default Property Get Number()
        Number = m_lNumber
    End Property
    Public Property Get Source()
        Source = m_sSource
    End Property
    Public Property Get Description()
        Description = m_sDescription
    End Property
    Public Property Get HelpContext()
        HelpContext = m_sHelpContext
    End Property
    Public Property Get HelpFile()
        HelpFile = m_sHelpFile
    End Property    
End Class

Class ArrayList
    Private m_itemArray

    Private Sub Class_Initialize()
        Me.Clear
    End Sub

    Private Sub AddItemToArray(ByRef itemArray, ByVal item)
        ReDim Preserve itemArray(UBound(itemArray) + 1) 
        itemArray(UBound(itemArray)) = item
    End Sub

    Public Sub Clear()
        m_itemArray = Array()
    End Sub

    Public Sub Add(item)
        AddItemToArray m_itemArray, item
    End Sub

    Public Sub RemoveAt(index)
        If index &lt; 0 Or index &gt; UBound(m_itemArray) Then
            Exit Sub
        End If
        Dim newArr: newArr = Array()
        Dim i
        For i = 0 To UBound(m_itemArray)
            If i &lt;&gt; index Then
                Call AddItemToArray(newArr, m_itemArray(i))
            End If
        Next
        m_itemArray = newArr
    End Sub

    Public Property Get Count()
        Count = UBound(m_itemArray) + 1
    End Property

    Public Property Get ItemsArray()
        ItemsArray = m_itemArray
    End Property

    Public Property Get IsEmpty()
        IsEmpty = UBound(m_itemArray) &lt; 0
    End Property
End Class

Class ScriptLogger
    Dim sourceLogEvent
    
    Private Sub Class_Initialize()
        sourceLogEvent = &quot;Management Group: &quot; + ManagementGroupName + &quot;. Script: &quot; + WScript.ScriptName + &quot;. Version: &quot; + MANAGEMENT_PACK_VERSION
    End Sub
    
    Private Sub Class_Terminate()
    End Sub
    
    Public Property Get ErrorEventType
        ErrorEventType = 1
    End Property
    
    Public Property Get WarningEventType
        WarningEventType = 2
    End Property
    
    Public Property Get InfoEventType
        InfoEventType = 4
    End Property

    Private Function LogEvent (message, eventType)
        On Error Resume Next
        Dim oAPI
        Set oAPI = CreateObject(&quot;MOM.ScriptAPI&quot;)
        Call oAPI.LogScriptEvent(sourceLogEvent, SCRIPT_EVENT_ID, eventType, message)
    End Function

    Public Function LogDebug(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
            LogEvent message, Me.InfoEventType
        End If
    End Function
    
    Public Function LogError(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.ErrorEventType
    End Function
    
    Public Function LogWarning(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.WarningEventType
    End Function
    
    Public Function LogFormattedError(customMessage)
        If Err.number &lt;&gt; 0 Then
            Me.LogError FormatErrorMessage(customMessage, &quot;&quot;)
        End If
    End Function
    
    Private Function ScriptInfo()
        Dim commandLineInfo  : commandLineInfo = WScript.ScriptFullName
        Dim argument
        For Each argument In WScript.Arguments
            commandLineInfo = commandLineInfo &amp; &quot; &quot;&quot;&quot; &amp; argument &amp; &quot;&quot;&quot;&quot;
        Next
        ScriptInfo = commandLineInfo
    End Function
End Class

Function FormatErrorMessage(customMessage, instanceName)
    FormatErrorMessage = customMessage
    If Err.number &lt;&gt; 0 Then
        Dim msg
        msg =_
        &quot; Error Number: &quot; &amp; CStr(Err.number) &amp; VbCrLf &amp; _
        &quot; Description: &quot; &amp; Err.Description

        If Not IsEmpty(instanceName) And instanceName &lt;&gt; &quot;&quot; Then
            msg = msg &amp; VbCrLf &amp; &quot; Instance: &quot; &amp; instanceName
        End If
        If customMessage &lt;&gt; &quot;&quot; Then
            msg = customMessage &amp; VbCrLf &amp; msg &amp; VbCrLf
        End If       
        FormatErrorMessage = msg
    End If
End Function

Function FormatDbErrorMessage(message, instanceName, dbName)
    FormatDbErrorMessage = message &amp; VbCrLf &amp; _
    &quot; Instance: &quot; &amp; instanceName &amp; VbCrLf &amp; _
    &quot; Database: &quot; &amp; dbName
End Function

Function ThrowScriptErrorNoAbort(ByVal sMessage, ByVal oErr)
    On Error Resume Next
    Dim errorText: errorText =  sMessage &amp; &quot;: &quot; &amp; oErr.Description
    GlobalErrorList.Add errorText
End Function

Function ThrowScriptError(Byval sMessage, ByVal oErr)
    On Error Resume Next
    ThrowScriptErrorNoAbort sMessage, oErr
    GlobalErrorListToEventLog()
    Quit()
End Function

Sub HandleError(customMessage)
    Dim localLogger
    If Err.number &lt;&gt; 0 Then
        Set localLogger = new ScriptLogger
        Call localLogger.LogFormattedError(customMessage)
        Call Wscript.Quit(0)
    End If
End Sub

Function HandleErrorContinue(customMessage)
    HandleErrorContinue = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinue = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, &quot;&quot;))
        Call Err.Clear()
    End If
End Function

Function HandleErrorContinueEx(customMessage, instanceName)
    HandleErrorContinueEx = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinueEx = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, instanceName))
        Call Err.Clear()
    End If
End Function

Function HandleSqlErrorContinue(adoConnection, customMessage, instanceName)
    HandleSqlErrorContinue = True   
    If Err.Number &lt;&gt; 0 Then
        HandleSqlErrorContinue = False
        Dim sqlErr
        Dim e: Set e = new Error
        e.Save
        On Error Resume Next
        If adoConnection.Errors.Count &gt; 0 Then
            Set sqlErr = adoConnection.Errors(0)
            adoConnection.Errors.Clear
            Call Err.Raise(sqlErr.Number, sqlErr.Source, sqlErr.Description)
        Else
            Call e.Raise()
        End If
        Call HandleErrorContinueEx(customMessage, instanceName)
    End If
End Function

Function GetGlobalErrorListEventString()
    GetGlobalErrorListEventString = &quot;&quot;
    If Not GlobalErrorList.IsEmpty Then
        GetGlobalErrorListEventString = &quot;The next errors occurred:&quot;&amp; vbNewLine &amp; Join(GlobalErrorList.ItemsArray, vbNewLine &amp; vbNewLine)
    End If
End Function

Function GlobalErrorListToEventLog()
    On Error Resume Next
    If Not GlobalErrorList.IsEmpty Then
        Dim localLogger: Set localLogger = New ScriptLogger
        localLogger.LogWarning GetGlobalErrorListEventString()
    End If
End Function

Function Quit()
    WScript.Quit()
End Function

Function EscapeWQLString (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function ConnectToWMI(ComputerName, strNamespace)
    Set ConnectToWMI = Nothing
	Set ConnectToWMI = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; ComputerName &amp; &quot;\&quot; &amp; strNamespace)
End Function

Function WMIGetProperty(oWmi, sPropName, nCIMType, ErrAction)
    Dim sValue, oWmiProp
    
    If Not IsValidObject(oWmi) Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;Accessing property on invalid WMI object.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        Exit Function
    End If
    
    On Error Resume Next
    Set oWmiProp = oWmi.Properties_.Item(sPropName)
    If Err.Number &lt;&gt; 0 Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
    End If
    On Error GoTo 0
    
    If IsValidObject(oWmiProp) Then
        sValue = oWmiProp.Value
        
        If IsNull(sValue) Then
            &apos;
            &apos; If value is null, return blank to avoid any issues
            &apos;
            WMIGetProperty = &quot;&quot;
            
        Else
            
            Select Case (oWmiProp.CIMType)
                Case wbemCimtypeString, wbemCimtypeSint16, wbemCimtypeSint32, wbemCimtypeReal32, wbemCimtypeReal64, wbemCimtypeSint8, wbemCimtypeUint8, wbemCimtypeUint16, wbemCimtypeUint32, wbemCimtypeSint64, wbemCimtypeUint64:
                    If Not oWmiProp.IsArray Then
                        WMIGetProperty = Trim(CStr(sValue))
                    Else
                        WMIGetProperty = Join(sValue, &quot;, &quot;)
                    End If

                Case wbemCimtypeBoolean:
                    If sValue = 1 Or UCase(sValue) = &quot;TRUE&quot; Then
                        WMIGetProperty = &quot;True&quot;
                    Else
                        WMIGetProperty = &quot;False&quot;
                    End If

                Case wbemCimtypeDatetime:
                    Dim sTmpStrDate
                
                    &apos;
                    &apos; First attempt to convert the whole wmi date string
                    &apos;
                    sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                  Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                  Left(sValue, 4) &amp; &quot; &quot; &amp; _
                                  Mid (sValue, 9, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 11, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 13, 2)
                    If IsDate(sTmpStrDate) Then
                        WMIGetProperty = CDate(sTmpStrDate)
                    Else
                    
                        &apos;
                        &apos; Second, attempt just to convert the YYYYMMDD
                        &apos;
                        sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                      Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                      Left(sValue, 4)
                        If IsDate(sTmpStrDate) Then
                            WMIGetProperty = CDate(sTmpStrDate)
                        Else
                            &apos;
                            &apos; Nothing works - return passed in string
                            &apos;
                            WMIGetProperty = sValue
                        End If
                    
                    End If
                
                Case Else:
                    WMIGetProperty = &quot;&quot;
            End Select
        End If
    Else
        
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        
    End If
    
    
    If (ErrAction And ErrAction_Trace) = ErrAction_Trace Then _
        WScript.Echo &quot;  + &quot; &amp; sPropName &amp; &quot; :: &apos;&quot; &amp; WMIGetProperty &amp; &quot;&apos;&quot;
    
End Function

Function WMIExecQuery(ByVal sNamespace, ByVal sQuery)
    &apos;
    &apos; WMIExecQuery :: Executes the WMI query and returns the result set.
    &apos;
    &apos;
    Dim oWMI, oQuery, nInstanceCount
    Dim e
    Set e = New Error
    On Error Resume Next
    Set oWMI = GetObject(sNamespace)
    e.Save
    On Error GoTo 0
    If IsEmpty(oWMI) Then
        ThrowScriptErrorNoAbort &quot;Unable to open WMI Namespace &apos;&quot; &amp; sNamespace &amp; &quot;&apos;.  Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists.&quot;, e
        ThrowEmptyDiscoveryData
    End If
    
    On Error Resume Next
        Set oQuery = oWMI.ExecQuery(sQuery)
        e.Save
    On Error GoTo 0
    If IsEmpty(oQuery) Or e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; returned an invalid result set.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    &apos;Determine if we queried a valid WMI class - Count will return 0 or empty
    On Error Resume Next
    nInstanceCount = oQuery.Count
    e.Save
    On Error GoTo 0
    If e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; did not return any valid instances.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    Set WMIExecQuery = oQuery
    
End Function

Function GetFirstItemFromWMIQuery(ByRef oQuery)
    ON ERROR RESUME NEXT
    Err.Clear
    Dim oResult: Set oResult = Nothing
    Set oResult = oQuery.ItemIndex(0)
    if Err.number &lt;&gt; 0 then
        Err.Clear
        Dim oObject
        For Each oObject in oQuery 
            Set oResult = oObject
            Exit For
        Next    
    end if
    Set GetFirstItemFromWMIQuery = oResult
End Function

Class Registry
    Public HKEY_CLASSES_ROOT
    Public HKEY_CURRENT_USER
    Public HKEY_LOCAL_MACHINE
    Public HKEY_USERS
    Public HKEY_CURRENT_CONFIG
    Public HKEY_DYN_DATA 

    Public ERROR_ACCESS_DENIED
    Public ERROR_KEY_NOT_FOUND
    Public ERROR_VALUE_NOT_FOUND
    Public SUCCESS
    
    Private m_oReg
    Private m_lHive
    
    Private Sub Class_Initialize()
        HKEY_CLASSES_ROOT = &amp;H80000000
        HKEY_CURRENT_USER = &amp;H80000001 
        HKEY_LOCAL_MACHINE = &amp;H80000002
        HKEY_USERS = &amp;H80000003 
        HKEY_CURRENT_CONFIG = &amp;H80000005
        HKEY_DYN_DATA = &amp;H80000006
        
        ERROR_ACCESS_DENIED = 5
        ERROR_KEY_NOT_FOUND = 2
        ERROR_VALUE_NOT_FOUND = 1
        SUCCESS = 0
        
        m_lHive = HKEY_LOCAL_MACHINE
    End Sub
    
    Public Sub Connect(ByVal sHostName)
        Set m_oReg = GetObject(&quot;winmgmts://&quot; &amp; sHostName &amp; &quot;/root/default:StdRegProv&quot;)
    End Sub
    
    Public Property Get Hive()
        Hive = m_lHive
    End Property
    
    Public Property Let Hive(ByVal lHive)
        m_lHive = lHive
    End Property
    
    Public Function ReadDWORDValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim lValue
        lResult = m_oReg.GetDWORDValue(m_lHive, sKeyPath, sValueName, lValue)
        ReadDWORDValue = lValue
    End Function
    
    Public Function ReadStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim sValue
        lResult = m_oReg.GetStringValue(m_lHive, sKeyPath, sValueName, sValue)
        ReadStringValue = sValue
    End Function
    
    Public Function ReadMultiStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aValues
        lResult = m_oReg.GetMultiStringValue(m_lHive, sKeyPath, sValueName, aValues)
        ReadMultiStringValue = aValues
    End Function
    
    Public Function EnumKeys(ByVal sKeyPath, ByRef lResult)
        Dim aSubKeys
        lResult = m_oReg.EnumKey(m_lHive, sKeyPath, aSubKeys)
        EnumKeys = aSubKeys
    End Function

    Public Function EnumValues(ByVal sKeyPath, ByRef lResult)
        Dim aNames, aTypes
        lResult = m_oReg.EnumValues(m_lHive, sKeyPath, aNames, aTypes)
        EnumValues = aNames
    End Function
    
    Public Function CreateKey(ByVal sKeyPath)
        CreateKey = m_oReg.CreateKey(m_lHive, sKeyPath)
    End Function
    
    Public Function WriteStringValue(ByVal sKeyPath, ByVal sValueName, ByVal sValue)
        WriteStringValue = m_oReg.SetStringValue(m_lHive, sKeyPath, sValueName, sValue)
    End Function
    
    Public Function DeleteValue(ByVal sKeyPath, ByVal sValueName)
        DeleteValue = m_oReg.DeleteValue(m_lHive, sKeyPath, sValueName)
    End Function
    
    Public Function ReadBinaryValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aData
        lResult = m_oReg.GetBinaryValue(m_lHive, sKeyPath, sValueName, aData)
        ReadBinaryValue = aData
    End Function

End Class

Function ArraysAreIntersected(ByRef arrA, ByRef arrB)
    Dim itemA, itemB
    ArraysAreIntersected = False
    For Each itemA in arrA
        For Each itemB in arrB
            If itemA = itemB Then
                ArraysAreIntersected = True
                Exit Function
            End If
        Next
    Next
End Function

Function ArrayContains(ByRef arr, ByRef searchItem)
    ArrayContains = False
    Dim item
    For Each item In arr
        If item = searchItem Then
            ArrayContains = True
            Exit Function
        End If
    Next
End Function

Function GetDriverVersionObj(oVersion)
    Dim tpName, vVersion
    tpName = TypeName(oVersion)
    Select Case tpName
    Case &quot;DriverVersion&quot;
        Set vVersion = oVersion
    Case &quot;String&quot;
        Set vVersion = (new DriverVersion)(oVersion)
    Case Else
        Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Parameter is not an instance of type DriverVersion.&quot;)
    End Select
    Set GetDriverVersionObj = vVersion
End Function

Class DriverVersion
    Private m_major
    Private m_minor
    Private m_build
    Private m_revision
    
    Public Default Function Init(versionStr)
        Parse(versionStr)
        Set Init = Me
    End Function

    Private Sub Parse(vStr)
        Dim parts, versionRegex, oRegex, matches
        Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{1,8})(.\d{1,8}){0,3}$&quot;
        Set matches = oRegex.Execute(vStr)
        If matches.Count = 0 Then
            Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Invalid version string.&quot;)
        End If
        parts = Split(vStr, &quot;.&quot;)
        m_major = CLng(parts(0))
        m_minor = 0
        m_build = 0
        m_revision = 0
        IF UBound(parts) &gt;= 1 Then
            m_minor = CLng(parts(1))
            If UBound(parts) &gt;= 2 Then
                m_build = CLng(parts(2))
                If UBound(parts) &gt;= 3 Then
                    m_revision = CLng(parts(3))
                End If
            End If
        End If
    End Sub

    Public Function CompareTo(v)
        Dim d
        d = m_major - v.Major
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_minor - v.Minor
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_build - v.Build
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_revision - v.Revision
        CompareTo = d
    End Function
    
    Public Function ToString()
        ToString = &quot;&quot; &amp; m_major &amp; &quot;.&quot; &amp; m_minor &amp; &quot;.&quot; &amp; m_build &amp; &quot;.&quot; &amp; m_revision
    End Function

    Public Property Get Major()
        Major = m_major
    End Property

    Public Property Get Minor()
       Minor = m_minor
    End Property

    Public Property Get Build()
       Build = m_build
    End Property

    Public Property Get Revision()
       Revision = m_revision
    End Property
End Class

Class VersionRange
    Private m_startVersion
    Private m_endVersion

    Public Default Function Init(sStartVersion, sEndVersion)
        Set m_startVersion = GetDriverVersionObj(sStartVersion)
        Set m_endVersion = GetDriverVersionObj(sEndVersion)
        Set Init = Me
    End Function

    Public Property Get StartVersion()
        Set StartVersion = m_startVersion
    End Property

    Public Property Get EndVersion()
        Set EndVersion = m_endVersion
    End Property
End Class

Class DriverItem
    Private m_name
    Private m_nameVersion
    Private m_driverVersion
    Private m_parseObject

    Public Default Function Init(sName, oNameVersion, oDriverVersion, ByRef oParseObject)
        m_Name = sName
        Set m_nameVersion = GetDriverVersionObj(oNameVersion)
        Set m_driverVersion = GetDriverVersionObj(oDriverVersion)
        Set m_parseObject = oParseObject
        Set Init = Me
    End Function 

    Public Property Get Name()
        Name = m_name
    End Property

    Public Property Get NameVersion()
        Set NameVersion = m_nameVersion
    End Property

    Public Property Get DriverVersion()
        Set DriverVersion = m_driverVersion
    End Property
    
    Public Property Get ParseObject()
        Set ParseObject = m_parseObject
    End Property
End Class

Class DriverSelectorRule
    Private m_nameRegexStr
    Private m_nameRegex
    Private m_versionRegexStr
    Private m_versionRegex
    Private m_nameMinVersion
    Private m_nameMaxVersion
    Private m_computerId
    Private m_driverVersionArr

    Public DriverCollection
    Public IsNativeClient

    Public Default Function Init(sNameRegex, sVersionRegex, sNameMinVersion, sNameMaxVersion, oVersionRangeArray)
        m_computerId = &quot;.&quot;
        m_nameRegexStr = sNameRegex
        Set m_nameRegex = New RegExp
        m_nameRegex.Pattern = m_nameRegexStr
        m_versionRegexStr = sVersionRegex
        If Not IsNull(m_versionRegexStr) Then
            If Len(m_versionRegexStr) &gt; 0 Then
                Set m_versionRegex = New RegExp
                m_versionRegex.Pattern = m_versionRegexStr
                m_versionRegex.Global = True
            End If
        End If
        Set m_nameMinVersion = GetDriverVersionObj(sNameMinVersion)
        Set m_nameMaxVersion = GetDriverVersionObj(sNameMaxVersion)
        m_driverVersionArr = oVersionRangeArray

        DriverCollection = Array()
        IsNativeClient = False
        Set Init = Me
    End Function

     Private Function CheckVersion(oVersion, vMinVersion, vMaxVersion)
        Dim vVersion: Set vVersion = GetDriverVersionObj(oVersion)
        CheckVersion = vVersion.CompareTo(vMinVersion) &gt;= 0 And (vVersion.ToString() = MAX_DRIVER_VERSION_STR Or vMinVersion.CompareTo(vMaxVersion) = 0 Or vVersion.CompareTo(vMaxVersion) &lt; 0)
    End Function

    Public Function MatchName(sDriverName)
        Dim matches
        Set matches = m_nameRegex.Execute(sDriverName)
        If matches.Count &gt; 0 Then
            MatchName = True
            Exit Function
        End If
        MatchName = False
    End Function

    Public Function GetNameVersion(sDriverName)
        Dim sVersion, matches
        If Not IsNull(m_versionRegexStr) Then
            Set matches = m_versionRegex.Execute(sDriverName)
            If matches.Count &gt; 0 Then
                sVersion = matches(0).Value
            End If   
        End If
        If Not IsNull(sVersion) Then
            Set GetNameVersion = GetDriverVersionObj(sVersion)
        Else
            Set GetNameVersion = GetDriverVersionObj(&quot;0&quot;)
        End If
    End Function

    Public Function CheckNameVersion(oVersion)
        CheckNameVersion = CheckVersion(oVersion, m_nameMinVersion, m_nameMaxVersion)
    End Function

    Public Function CheckDriverVersion(oVersion)
        CheckDriverVersion = False
        Dim driverVersionItem
        For Each driverVersionItem In m_driverVersionArr
             If CheckVersion(oVersion, driverVersionItem.StartVersion, driverVersionItem.EndVersion) Then
                CheckDriverVersion = True
                Exit For
            End If
        Next
    End Function

    Public Function GetDriverVersion(sDriverName)
        Dim computerId, driverPath, sDllVersion, objFSO, oRegistry
        Dim HKEY_LOCAL_MACHINE: HKEY_LOCAL_MACHINE = &amp;H80000002
        Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\&quot; &amp; sDriverName, &quot;Driver&quot;, driverPath   
        Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;) 
        sDllVersion =  objFSO.GetFileVersion(driverPath)
        Set GetDriverVersion = (new DriverVersion)(sDllVersion)
    End Function

    Public Sub AddDriver(ByRef oDriver)
        ReDim Preserve DriverCollection(UBound(DriverCollection) + 1) 
        Set DriverCollection(UBound(DriverCollection)) = oDriver
    End Sub

    Public Sub ResetState()
        DriverCollection = Array()
    End Sub

    Public Property Get DriverNameRegex()
        DriverNameRegex = m_nameRegexStr
    End Property

    Public Property Get NameMinVersion()
        Set NameMinVersion= m_nameMinVersion
    End Property

    Public Property Get NameMaxVersion()
        Set NameMaxVersion = m_nameMaxVersion
    End Property

    Public Property Get VersionRangeCollection()
        VersionRangeCollection = m_driverVersionArr
    End Property

    Public Property Get CollectionIsEmpty()
        CollectionIsEmpty = UBound(DriverCollection) &lt; 0
    End Property
End Class

Class DriverSelector
	Private m_computerId
    Private m_selectorRules(3)
    Private m_selectedDriverName
    Private m_processed
    Private HKEY_LOCAL_MACHINE
    Private m_defaultDriverName

    Private m_ncli_ForceProtocolEncryption
    Private m_ncli_TrustServerCertificate

    Private m_ncli_tcpProtocolEnabled
    Private m_ncli_smProtocolEnabled

    Public ErrorCollection

    Private Sub Class_Initialize()
        Set m_selectorRules(0) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;,&quot;\d{1,8}(\.\d{1,8})?$&quot;, &quot;11.0&quot;, &quot;11.0&quot;,_
            Array(_
               (new VersionRange)(&quot;2011.110.6020.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2011.110.5592.0&quot;, &quot;2011.110.6000.0&quot;),_
               (new VersionRange)(&quot;2011.110.5347.0&quot;, &quot;2011.110.5522.0&quot;)))
        m_selectorRules(0).IsNativeClient = True
        Set m_selectorRules(1) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;11.0&quot;, MAX_DRIVER_VERSION_STR,_
            Array(_
               (new VersionRange)(&quot;2014.120.4219.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2014.120.2546.0&quot;, &quot;2014.120.4000.0&quot;)))
        Set m_selectorRules(2) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;, &quot;\d{1,8}(\.\d{1,8})?$&quot;,&quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
        m_selectorRules(2).IsNativeClient = True
        Set m_selectorRules(3) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
		
        m_computerId = &quot;.&quot;
        m_defaultDriverName = &quot;SQL Server&quot;
        HKEY_LOCAL_MACHINE = &amp;H80000002
        m_ncli_ForceProtocolEncryption = False
        m_ncli_TrustServerCertificate = False
        m_ncli_tcpProtocolEnabled  = True
        m_processed = False
        Call ResetState()
    End Sub

    &apos; Select most appropriate driver from filtered installed system (ODBC) drivers.
    &apos; select all available drivers
    &apos; Filter by driver name and version
    &apos; Intersected: check client and server have shared protocols
    &apos; tcp and np (Named Pipes) can work by network, sm can work only locally
    &apos; driver priorities: sm, tcp; np not used
    &apos; 
    &apos; For native client need common client and server protocols
    &apos; 
    &apos; Select latest namespace with highest version
    &apos; Select client protocols
    &apos; Select server protocols (enabled)
    &apos; Intersect client and server protocols
    &apos; Select odbc drivers related to inresected protocols
    &apos; We have 3 possible drivers:
    &apos; - ODBC (all protocols enabled)
    &apos; - Native Client (tcp, sm, np protocols)
    &apos;      only native client can choose protocols through registry settings
    &apos; - Microsoft SQL Server (all protocols enabled)
	Public Sub ProcessDrivers(enabledServerProtocols)
        Dim ri, i, isSelected, currentSelect, oError
        Set oError = New Error
        Call ResetState()
        On Error Resume Next

        Dim client: Set client = GetClientParameters()

        Dim ncProtocolsAreIntersected: ncProtocolsAreIntersected = ArraysAreIntersected(enabledServerProtocols, client.Protocols)
		Call ProcessSystemOdbcDrivers(ncProtocolsAreIntersected)

        oError.Save
        If oError.Number &lt;&gt; 0 Then
            Call AddError(oError)
            m_selectedDriverName = m_defaultDriverName
            m_processed = true
            Exit Sub
        End If
        On Error GoTo 0
        
        Dim driver: Set driver = SelectFreshDriver(m_selectorRules)

        If Not driver Is Nothing Then
            If driver.ParseObject.IsNativeClient Then
                client.IsTcpProtocolEnabled = ArrayContains(client.Protocols, &quot;tcp&quot;)
                client.IsSharedMemoryProtocolEnabled = ArrayContains(client.Protocols, &quot;sm&quot;)
            End If
        End If

        If Not driver Is Nothing Then
            client.DriverName = driver.Name
        End If

        &apos; for compatibility fill deprecated
        m_selectedDriverName = client.DriverName
        m_ncli_ForceProtocolEncryption = client.IsForceProtocolEncryption
        m_ncli_TrustServerCertificate = client.IsTrustServerCertificate
        m_ncli_tcpProtocolEnabled = client.IsTcpProtocolEnabled
        m_ncli_smProtocolEnabled = client.IsSharedMemoryProtocolEnabled

        m_processed = True
	End Sub

    Private Function SelectFreshDriver(rules)
        Set SelectFreshDriver = Nothing
        Dim selected: Set selected = Nothing
        Dim rule: Set selected = Nothing
        Dim driver: Set selected = Nothing

        For Each rule In rules
            For Each driver In rule.DriverCollection
                &apos; select first if not selected
                If selected Is Nothing Then
                    Set selected = driver
                Else
                    &apos; select fresh, compare driver with selected by name and
                    &apos; version
                    if driver.NameVersion.CompareTo(selected.NameVersion) &gt;= 0 And _
                        driver.DriverVersion.CompareTo(selected.DriverVersion) &gt;= 0 Then
                        Set selected = driver
                    End If
                End If
            Next

            &apos; all rules have order by priority, if rule contains drivers, then
            &apos; selected with high priority
            if Not selected Is Nothing Then
                Exit For
            End If
        Next

        Set SelectFreshDriver = selected
    End Function

    Private Function GetClientParameters()
        Set GetClientParameters = Nothing
        Dim params: Set params = (New ConnectionParams)(&quot;.&quot;)
        params.Namespace = GetNsNameWithHighestVersion()
        Call GetNativeClientSettings(params.Namespace, params)
        params.Protocols = GetEnabledNativeClientProtocols(params.Namespace)
        Set GetClientParameters = params
    End Function
	
    Private Sub ProcessOdbcDriver(driverName, protocolsAreIntersected)
        Dim isInstalled, oRegistry, oNameVersion, oDriverVersion
        Set oRegistry = GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)
        
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverName, isInstalled 
        Dim selectorRule
        For Each selectorRule In m_selectorRules
            If (isInstalled &lt;&gt; &quot;Installed&quot;) Then
                Exit For
            End If
            If selectorRule.MatchName(driverName) Then
                If (Not selectorRule.IsNativeClient) Or (selectorRule.IsNativeClient And protocolsAreIntersected) Then
                    Set oNameVersion = selectorRule.GetNameVersion(driverName)
                    If (selectorRule.CheckNameVersion(oNameVersion)) Then
                        Set oDriverVersion = selectorRule.GetDriverVersion(driverName)
                        If (selectorRule.CheckDriverVersion(oDriverVersion)) Then
                            selectorRule.AddDriver((new DriverItem)(driverName, oNameVersion, oDriverVersion, selectorRule))
                            Exit For
                        End If
                    End If
                End If
            End If
        Next
    End Sub

    &apos; Get available drivers in the system and fill rules drivers
    &apos; TODO: rename method
	Private Sub ProcessSystemOdbcDrivers(protocolsAreIntersected)
        Dim oRegistry, driverNames, paramValueTypes, i, oError
        Set oError = New Error
		Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
		Call oRegistry.EnumValues(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverNames, paramValueTypes)
		On Error Resume Next

        Dim driverName
        For Each driverName In driverNames
            oError.Clear
            Call ProcessOdbcDriver(driverName, protocolsAreIntersected)
            oError.Save
            If oError.Number &lt;&gt; 0 Then
                Call AddError(oError)
            End If
		Next
	End Sub
	
    Private Function GetNsNameWithHighestVersion()
        Dim rootNs: rootNs = &quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\Microsoft\SqlServer&quot;
        Dim oWMI: Set oWMI = GetObject(rootNs)
        Dim namespaces: Set namespaces = oWMI.ExecQuery(&quot;SELECT Name FROM __NAMESPACE WHERE Name LIKE &apos;ComputerManagement%&apos;&quot;)
        Dim currentName: currentName = &quot;&quot;
        Dim objItem
	    For Each objItem In namespaces
            If objItem.Name &gt; currentName Then
                currentName = objItem.Name
            End If
        Next
        GetNsNameWithHighestVersion = rootNs &amp; &quot;\&quot; &amp; currentName
    End Function

    Private Sub GetNativeClientSettings(namespaceFullName, params)
        On Error Resume Next
        Err.Clear

        Dim sNamespace, oWMI, objClasses, sState, sTargetComputer
        Set oWMI = GetObject(namespaceFullName)
        Set objClasses = Nothing

        &apos; query can fail, because native client not supported
        Set objClasses = oWMI.ExecQuery(&quot;SELECT FlagName, FlagValue FROM ClientSettingsGeneralFlag&quot;)

        &apos; do nothing, its ok, just skip this settings
        If (Err.Number &lt;&gt; 0) Or (objClasses Is Nothing) Then
            Exit Sub
        End If

        Dim objItem
        For Each objItem in objClasses
            Select Case objItem.FlagName
            Case &quot;Force protocol encryption&quot;
                &apos;m_ncli_ForceProtocolEncryption = objItem.FlagValue
                params.IsForceProtocolEncryption = objItem.FlagValue
            Case &quot;Trust Server Certificate&quot;
                &apos;m_ncli_TrustServerCertificate = objItem.FlagValue
                params.IsTrustServerCertificate = objItem.FlagValue
            End Select
        Next
    End Sub   

    Private Function GetEnabledNativeClientProtocols(namespaceFullName)
        On Error Resume Next
        Err.Clear

        Dim oWMI: Set oWMI = GetObject(namespaceFullName)  
        Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, ProtocolOrder FROM ClientNetworkProtocol&quot;)

        If (oQuery.Count &gt; 0) And (Err.Number Is 0) Then
            Dim protocolsArr: Set protocolsArr = New ArrayList
            Dim protocolItem
            For Each protocolItem In oQuery
                If protocolItem.ProtocolOrder &gt; 0 Then
                    protocolsArr.Add LCase(protocolItem.ProtocolName)
                End If
            Next
            GetEnabledNativeClientProtocols = protocolsArr.ItemsArray
        Else
            GetEnabledNativeClientProtocols = Array()
        End If
    End Function

    Private Sub AddError(oError)
        Dim newSize
        newSize = UBound(ErrorCollection) + 1
        ReDim Preserve ErrorCollection(newSize)
        ErrorCollection(newSize) = &quot;[&quot; &amp; (oError.Number and 65535) &amp; &quot;][&quot; &amp; oError.Source &amp; &quot;] &quot; &amp; oError.Description 
    End Sub

    Private Sub ResetState()
        Dim pr
        ErrorCollection = Array()
        For Each pr In m_selectorRules
            pr.ResetState()
        Next
    End Sub

    Private Sub ThrowIfNotProcessed()
        If Not m_processed Then
            Call Err.Raise(SCRIPT_EVENT_ID, &quot;&quot;, &quot;Drivers are not processed. Call &apos;ProcessDrivers&apos; first.&quot;)
        End If
    End Sub

    Public Property Get HasErrors()
        HasErrors = UBound(ErrorCollection) &gt;= 0
    End Property

    Public Property Get DriverName()
        ThrowIfNotProcessed
        DriverName = m_selectedDriverName
    End Property 

    Public Property Get UseFqdn()
        ThrowIfNotProcessed
        UseFqdn = m_ncli_ForceProtocolEncryption And Not m_ncli_TrustServerCertificate
    End Property

    Public Property Get ClientTcpProtocolEnabled()
        ThrowIfNotProcessed
        ClientTcpProtocolEnabled = m_ncli_tcpProtocolEnabled
    End Property

    Public Property Get ClientSharedMemoryProtocolEnabled()
        ThrowIfNotProcessed
        ClientSharedMemoryProtocolEnabled = m_ncli_smProtocolEnabled
    End Property
End Class

Class ConnectionParams
    Public ComputerName
    Public DriverName
    Public Namespace
    Public IsForceProtocolEncryption
    Public IsTrustServerCertificate
    Public IsTcpProtocolEnabled
    Public IsSharedMemoryProtocolEnabled
    Public Protocols

    Public Default Function Init(sComputerName)
        ComputerName = sComputerName
        DriverName = DriverSelector_DEFAULT_DRIVER_NAME
        Namespace = &quot;&quot;
        IsForceProtocolEncryption = False
        IsTrustServerCertificate = False
        IsTcpProtocolEnabled = True
        IsSharedMemoryProtocolEnabled = True
        Set Init = Me
    End Function
End Class

Class UniqueCollection
    Private m_dict

    Public Default Function Init()
        Set m_dict = CreateObject(&quot;Scripting.Dictionary&quot;)
        Set Init = Me
    End Function

    Public Sub PutItem(item)
       If Not m_dict.Exists(item) Then
            m_dict.add item, &quot;&quot;
       End If
    End Sub
	
	Public Function Exists(item)
		Exists = m_dict.Exists(item)
	End Function
	
    Public Function GetItems()
        GetItems = m_dict.Keys()
    End Function

    Public Sub Clear()
        m_dict.RemoveAll()
    End Sub
End Class

Class SqlServerTcpIpSettings
    Private m_listenAllIPs
    Private m_ipSettings

    Public Default Function Init(listenAllIps, ipSettings)
        m_listenAllIPs = listenAllIps
        Set m_ipSettings = ipSettings
        Set Init = Me
    End Function

    Public Property Get ListenAllIPs()
        ListenAllIPs = m_listenAllIPs
    End Property

    Public Property Get IpSettings()
        Set IpSettings = m_ipSettings
    End Property
End Class

Function EscapeConnStringValue (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeConnStringValue  = &quot;{&quot; + Replace(strValue, &quot;}&quot;, &quot;}}&quot;) + &quot;}&quot;
End Function

Function EscapeWQLString (ByVal strValue)
	ON ERROR RESUME NEXT
	Err.Clear

	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function furlEncode(vString,vEncDec)
    Dim i
    Dim aReserved(24,1)
    &apos;column 1
    aReserved(0,0) = &quot;%&quot; &apos;25
    aReserved(1,0) = &quot;;&quot; &apos;3B
    aReserved(2,0) = &quot;/&quot; &apos;2F
    aReserved(3,0) = &quot;?&quot; &apos;3F
    aReserved(4,0) = &quot;:&quot; &apos;3A
    aReserved(5,0) = &quot;@&quot; &apos;40
    aReserved(6,0) = &quot;&amp;&quot; &apos;26
    aReserved(7,0) = &quot;=&quot; &apos;3D
    aReserved(8,0) = &quot;+&quot; &apos;2B
    aReserved(9,0) = &quot;$&quot; &apos;24
    aReserved(10,0) = &quot;,&quot; &apos;2C
    aReserved(11,0) = &quot; &quot; &apos;20
    aReserved(12,0) = &quot;&quot;&quot;&quot; &apos;22
    aReserved(13,0) = &quot;&lt;&quot; &apos;3C
    aReserved(14,0) = &quot;&gt;&quot; &apos;3E
    aReserved(15,0) = &quot;#&quot; &apos;23
    aReserved(16,0) = &quot;{&quot; &apos;7B
    aReserved(17,0) = &quot;}&quot; &apos;7D
    aReserved(18,0) = &quot;|&quot; &apos;7C
    aReserved(19,0) = &quot;\&quot; &apos;5C
    aReserved(20,0) = &quot;^&quot; &apos;5E
    aReserved(21,0) = &quot;~&quot; &apos;7E
    aReserved(22,0) = &quot;[&quot; &apos;5B
    aReserved(23,0) = &quot;]&quot; &apos;5D
    aReserved(24,0) = &quot;`&quot; &apos;60
    &apos;column 2
    aReserved(0,1) = &quot;%25&quot;
    aReserved(1,1) = &quot;%3B&quot;
    aReserved(2,1) = &quot;%2F&quot;
    aReserved(3,1) = &quot;%3F&quot;
    aReserved(4,1) = &quot;%3A&quot;
    aReserved(5,1) = &quot;%40&quot;
    aReserved(6,1) = &quot;%26&quot;
    aReserved(7,1) = &quot;%3D&quot;
    aReserved(8,1) = &quot;%2B&quot;
    aReserved(9,1) = &quot;%24&quot;
    aReserved(10,1) = &quot;%2C&quot;
    aReserved(11,1) = &quot;%20&quot;
    aReserved(12,1) = &quot;%22&quot;
    aReserved(13,1) = &quot;%3C&quot;
    aReserved(14,1) = &quot;%3E&quot;
    aReserved(15,1) = &quot;%23&quot;
    aReserved(16,1) = &quot;%7B&quot;
    aReserved(17,1) = &quot;%7D&quot;
    aReserved(18,1) = &quot;%7C&quot;
    aReserved(19,1) = &quot;%5C&quot;
    aReserved(20,1) = &quot;%5E&quot;
    aReserved(21,1) = &quot;%7E&quot;
    aReserved(22,1) = &quot;%5B&quot;
    aReserved(23,1) = &quot;%5D&quot;
    aReserved(24,1) = &quot;%60&quot;

    For i = 0 to Ubound(aReserved)
        If vEncDec = &quot;enc&quot; Then
        vString = Replace(vString,aReserved(i,0),aReserved(i,1))
        End If
        If vEncDec = &quot;dec&quot; Then
        vString = Replace(vString,aReserved(i,1),aReserved(i,0))
        End If
    Next

    furlEncode = vString
End Function

Class UtcDateOperations
    Private m_wbemDate

    Private Sub Class_Initialize()
        Set m_wbemDate = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
    End Sub

    Public Function DateToIso8601UtcString(objDate)
        DateToIso8601UtcString = _
            DatePart(&quot;yyyy&quot;, objDate) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;m&quot;, objDate), 2) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;d&quot;, objDate), 2) &amp;_
            &quot;T&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;h&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;n&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;s&quot;, objDate), 2) &amp;_
            &quot;Z&quot;
    End Function

    Public Function Iso8601UtcStringToDate(sDate)
        Dim oRegex: Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{4})-(\d\d)-(\d\d)(?:T|\s)(\d\d):(\d\d):(\d\d)Z$&quot; 
        
        Dim matches: Set matches = oRegex.Execute(sDate)
        If matches.Count = 0 Then
            Err.Raise 4000, &quot;&quot;, &quot;Input date string is in invalid format&quot;
        End If
        
        Dim year: year = CInt(matches(0).SubMatches(0))
        Dim month: month = CInt(matches(0).SubMatches(1))
        Dim day: day = CInt(matches(0).SubMatches(2))

        Dim hour: hour = CInt(matches(0).SubMatches(3))
        Dim minute: minute = CInt(matches(0).SubMatches(4))
        Dim second: second = CInt(matches(0).SubMatches(5))

        Dim resDate: resDate = DateSerial(year, month, day)
        resDate = DateAdd(&quot;h&quot;, hour, resDate)
        resDate = DateAdd(&quot;n&quot;, minute, resDate)
        resDate = DateAdd(&quot;s&quot;, second, resDate)

        Iso8601UtcStringToDate = resDate
    End Function

    Public Function GetUtcNow()
        m_wbemDate.SetVarDate(Now())
        GetUtcNow = CDate(m_wbemDate.GetVarDate(false))
    End function

    Public Function CheckSecondsElapsed(sDate, nSeconds)
        Dim utcNow: utcNow = Me.GetUtcNow
        Dim utcDate: utcDate = Iso8601UtcStringToDate(sDate)
        CheckSecondsElapsed = DateDiff(&quot;s&quot;,utcDate,utcNow) &gt; nSeconds
    End function
End Class

Function GetCacheKey(stateMpPrefix, sKeyName)
    Dim oApi: Set oApi = CreateObject(&quot;MOM.ScriptAPI&quot;)
    Dim regKey: regKey = oAPI.GetScriptStateKeyPath(ManagementGroupID)
    regKey = regKey &amp; &quot;\&quot; &amp; stateMpPrefix &amp; &quot;\&quot; &amp; sKeyName
    GetCacheKey = regKey
End Function

Function GetStringValueFromCache(sKeyName, sValueName, cacheExpirationTime)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)
        
    Dim lErrCode
    Dim sDate: sDate = oReg.ReadStringValue(regKey, sDateValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    Dim sValue: sValue = oReg.ReadStringValue(regKey, sValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    If udo.CheckSecondsElapsed(sDate, cacheExpirationTime) Then
        Exit Function
    End If

    GetStringValueFromCache = sValue
End Function

Function PutStringValueToCache(sKeyName, sValueName, sValue)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    Dim dUtcNow: dUtcNow = udo.GetUtcNow()

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)

    Call oReg.CreateKey(regKey)

    Dim lErrCode
    
    Call oReg.WriteStringValue(regKey, sValueName, sValue)
    Call oReg.WriteStringValue(regKey, sDateValueName, udo.DateToIso8601UtcString(dUtcNow))
End Function

Function GetWMISingleValue(wmiProvider, query, propertyName)
    Dim oQuery: Set oQuery = wmiProvider.ExecQuery(query)
    If oQuery.Count = 0 Then
        Err.Raise 4000, &quot;&quot;, &quot;Query &apos;&quot; &amp; query &amp; &quot;&apos; didn&apos;t return any objects&quot;
    End If
    Dim colSettings: Set colSettings = GetFirstItemFromWMIQuery(oQuery)
    GetWMISingleValue = colSettings.Properties_.Item(propertyName).Value
End Function

Class HostNameData
    Public HostName
    Public IsClustered

    Public Default Function Init(sHostName, bIsClustered)
        Me.HostName = sHostName
        Me.IsClustered = bIsClustered
        Set Init = Me
    End function
End Class

Function GetSqlServerHostName(strDNSComputerName, instanceName, namespace)
    Set GetSqlServerHostName = Nothing
    Dim serviceName: serviceName = GetSQLServiceName(instanceName)
    Dim escapedServiceName: escapedServiceName = EscapeWQLString(serviceName)
    
    Dim wmiProvider: Set wmiProvider = ConnectToWMI(strDNSComputerName, &quot;ROOT\Microsoft\SqlServer\&quot; + namespace)

    Dim isClustered: isClustered = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyNumValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;CLUSTERED&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyNumValue&quot;)

    Dim hostName
    If isClustered = 0 Then
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT HostName FROM SqlService WHERE SQLServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;HostName&quot;)
    Else
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyStrValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;VSNAME&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyStrValue&quot;)
    End If

    Set GetSqlServerHostName = (New HostNameData)(hostName, CBool(isClustered))
End Function

Function EscapeCacheValueName(name)
    EscapeCacheValueName = Replace(name, &quot;_&quot;, &quot;__&quot;)
End Function

Function GetSqlServerHostNameEx(strDNSComputerName, instanceName, namespace)
    Set GetSqlServerHostNameEx = Nothing
    Dim cacheExpirationTime: cacheExpirationTime = 7200
    Dim hostValueName: hostValueName = EscapeCacheValueName(strDNSComputerName)
    Dim isClusteredValueName: isClusteredValueName = hostValueName &amp; &quot;_IsClustered&quot;
    Dim isClusteredStr

    On Error Resume Next
    Call Err.Clear()
    Dim hostName: hostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    If Err.Number = 0 And Not IsEmpty(hostName) Then
        isClusteredStr = GetStringValueFromCache(&quot;SqlHostNames&quot;, isClusteredValueName, cacheExpirationTime)
        If Err.Number = 0 And Not IsEmpty(isClusteredStr) Then
            If isClusteredStr = &quot;0&quot; Or isClusteredStr = &quot;1&quot; Then
                Set GetSqlServerHostNameEx = (New HostNameData)(hostName, CBool(isClusteredStr))
                Exit Function
            End If
        End If
    End If
    Call Err.Clear()

    On Error GoTo 0
    Dim hostNameData: Set hostNameData = GetSqlServerHostName(strDNSComputerName, instanceName, namespace)

    If hostNameData.IsClustered Then 
        isClusteredStr = &quot;1&quot;
    Else 
        isClusteredStr = &quot;0&quot;
    End If

    On Error Resume Next
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, hostValueName, hostNameData.HostName)
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, isClusteredValueName, isClusteredStr)
    
    Call Err.Clear()

    Set GetSqlServerHostNameEx = hostNameData
End function

Function GetLocalHostName()
    Dim wshShell: Set wshShell = CreateObject( &quot;WScript.Shell&quot; )
    GetLocalHostName = wshShell.ExpandEnvironmentStrings(&quot;%COMPUTERNAME%&quot;)
End Function

Function DelimitSqlIdentifier(identifier)
    DelimitSqlIdentifier = &quot;[&quot; + Replace(identifier, &quot;]&quot;, &quot;]]&quot;) + &quot;]&quot;
End Function

Function SqlTcpPortIsEmpty(tcpPort)
    SqlTcpPortIsEmpty = (IsEmpty(tcpPort) Or tcpPort = &quot;&quot; Or tcpPort = &quot;0&quot;)
End Function

Function GetDataSource(server, tcpPort)
    Dim dataSource : dataSource = server
    If Not SqlTcpPortIsEmpty(tcpPort) Then
        Dim nameParts : nameParts = Split(dataSource, &quot;\&quot;)
        dataSource = nameParts(0) &amp; &quot;,&quot; &amp; tcpPort
    End If
    GetDataSource = dataSource
End Function

Function BuildDataSourceFromParts(computerName, instanceName, tcpPort)
    Dim dataSource : dataSource = computerName
    If instanceName &lt;&gt; &quot;MSSQLSERVER&quot; Then
        dataSource = computerName &amp; &quot;\&quot; &amp; instanceName
    End If
    BuildDataSourceFromParts = GetDataSource(dataSource, tcpPort)
End Function

Function GetConnectionString(driverName, dataSource, databaseName, intent)
    GetConnectionString = &quot;Driver=&quot; &amp; EscapeConnStringValue(driverName) &amp; &quot;;Server=&quot; &amp; EscapeConnStringValue(dataSource) &amp; &quot;;Database=&quot; &amp; EscapeConnStringValue(databaseName) &amp; &quot;;Trusted_Connection=yes;ApplicationIntent=&quot; &amp; intent
End Function

Function GetEnabledSqlServerProtocols(namespaceName, computerName, instanceName)
    Dim oWMI: Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot; &amp; namespaceName)  
    Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, Enabled FROM ServerNetworkProtocol WHERE InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos;&quot;)
    If oQuery.Count &gt; 0 Then
        Dim protocolsArr: Set protocolsArr = New ArrayList
        Dim protocolItem
        For Each protocolItem In oQuery
            If protocolItem.Enabled Then
                protocolsArr.Add LCase(protocolItem.ProtocolName)
            End If
        Next
        GetEnabledSqlServerProtocols = protocolsArr.ItemsArray
    Else
        GetEnabledSqlServerProtocols = Array()
    End If
End Function

Function GetSqlServerTcpIpSettings(instanceName, computerName)
    ON ERROR RESUME NEXT
    Dim oWMI, oQuery, tcpItem
    Dim i, j
    Dim uc: Set uc = (new UniqueCollection)()
    Dim isListenAll: isListenAll = False
    Dim ipSettings: Set ipSettings = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot;&amp; SQL_WMI_NAMESPACE)  

    Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND PropertyName = &apos;ListenOnAllIPs&apos;&quot;)

    If oQuery.Count &gt;0 Then
        Dim isListenAllObj: Set isListenAllObj = GetFirstItemFromWMIQuery(oQuery)
        If isListenAllObj.PropertyNumVal = 1 Then
            isListenAll  = True
        End If
    End If

    Dim tcpPorts, tcpPort, processedPort
        
    If isListenAll Then
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;IPAll&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
        If oQuery.Count &gt; 0 Then
            For Each tcpItem In oQuery
                tcpPorts = Split(tcpItem.PropertyStrVal,&quot;,&quot;)
                For Each tcpPort In tcpPorts
            	    processedPort = Trim(tcpPort)
            	    If Not SqlTcpPortIsEmpty(processedPort) Then
                	    uc.PutItem(processedPort)
                    End If
                Next
            Next
            ipSettings.add &quot;IPAll&quot;, uc.GetItems()
        End If
    Else
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName &lt;&gt; &apos;&apos; AND PropertyName = &apos;Enabled&apos; AND PropertyNumVal = 1&quot;) 
        Dim ipItem
        If oQuery.Count &gt; 0 Then
            For Each ipItem In oQuery
                Dim ipAddressName : ipAddressName = ipItem.IPAddressName
                Dim oQuery2 : Set oQuery2 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot; &amp; EscapeWQLString(instanceName) &amp; &quot;&apos; AND IPAddressName = &apos;&quot; &amp; EscapeWQLString(ipAddressName) &amp; &quot;&apos; AND PropertyName = &apos;IpAddress&apos; AND PropertyStrVal != &apos;&apos;&quot;)
                If oQuery2.Count &gt; 0 Then
                    Dim ipAddress : ipAddress = GetFirstItemFromWMIQuery(oQuery2).PropertyStrVal
                    Dim oQuery3: Set oQuery3 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;&quot;&amp; EscapeWQLString(ipAddressName) &amp;&quot;&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
                    If oQuery3.Count &gt; 0 Then 
                        uc.Clear()
                        Dim portItem
                        For Each portItem In oQuery3
                            tcpPorts = Split(portItem.PropertyStrVal,&quot;,&quot;)
                            For Each tcpPort In tcpPorts
                            	processedPort = Trim(tcpPort)
                                If Not SqlTcpPortIsEmpty(processedPort) Then
				                	uc.PutItem(processedPort)
				                End If
                            Next
                            ipSettings.add ipAddress, uc.GetItems()
                        Next
                    End If
                End If
            Next
        End If
    End If
    Set GetSqlServerTcpIpSettings = (new SqlServerTcpIpSettings)(isListenAll, ipSettings)
End Function

Function GetTcpPortsString(ByVal inputDataSource)
    On Error Resume Next
	Dim computerName, instanceName, pathArray
	
	pathArray = Split(inputDataSource, &quot;\&quot;)
    computerName = pathArray(0)
    instanceName = &quot;MSSQLSERVER&quot;
	If (UBound(pathArray) &gt; 0) Then
	    instanceName = pathArray(1)
	End If

    Dim tcpIpSettings: Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, computerName)
    Dim upc : Set upc = (new UniqueCollection)()
    Dim ip, port
    For Each ip In tcpIpSettings.IpSettings.Keys 
        For Each port In tcpIpSettings.IpSettings.Item(ip)
            upc.PutItem port
        Next
    Next
    GetTcpPortsString = Join(upc.GetItems(),&quot;, &quot;)
End Function

Public Sub SqlTestDestination(dbConnection, hostName, instanceName, isADODB)
    Dim queryServerName, queryInstanceName
    Dim destinationTestQuery: destinationTestQuery = &quot;select CAST(SERVERPROPERTY(&apos;MachineName&apos;) AS nvarchar(128)) as ServerName, @@servicename as InstanceName&quot;
    On Error Goto 0
    If 0 = Err.number Then
        Dim queryResult
        If isADODB Then
            Set queryResult = dbConnection.ExecuteQueryTE(destinationTestQuery)
        Else
            Set queryResult = dbConnection.Execute(destinationTestQuery)
        End If
        If Not queryResult.EOF Then
            queryServerName = UCase(queryResult(&quot;ServerName&quot;).Value)
            queryInstanceName = UCase(queryResult(&quot;InstanceName&quot;).Value)
            If (UCase(hostName) = queryServerName) And (UCase(instanceName) = queryInstanceName) Then
                Exit Sub
            End If
        End If
        dbConnection.Close() 
        Err.Raise 16389, &quot;&quot;, &quot;Connection target check failed: connected to &quot; &amp; hostName &amp; &quot;\&quot; &amp; instanceName &amp; &quot;, but got &quot; &amp; queryServerName &amp; &quot;\&quot; &amp; queryInstanceName &amp; &quot;.&quot;
    End If
End Sub

Sub TryToConnectAndValidate(connectionObj, connectionString, timeout, hostName, instanceName, isADODB)
    On Error GoTo 0
    
    If isADODB Then
        connectionObj.Open connectionString, &quot;&quot;, timeout
    Else
        if (connectionObj.Mode &lt;&gt; 0) then
          connectionObj.Close()
        end if
        connectionObj.ConnectionTimeout = timeout
        connectionObj.Open connectionString
    End If
    SqlTestDestination connectionObj, hostName, instanceName, isADODB
End Sub

Function FormatConnectionErrorMessage(dataSource, lastError)
    FormatConnectionErrorMessage = &quot;Connection to data source &apos;&quot; &amp; dataSource &amp; &quot;&apos; failed: &quot; &amp; lastError.Description
End Function

Function SmartConnectWithoutSQLADODB(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName)    
    Set SmartConnectWithoutSQLADODB = SmartConnectWithoutSQLADODBIntent(inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectWithoutSQLADODBIntent(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName, ByVal intent)
    On Error Resume Next
    Set SmartConnectWithoutSQLADODBIntent = Nothing
    Dim dbMasterConnection, dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList
    
    Set dbMasterConnection = CreateObject(&quot;ADODB.Connection&quot;)

    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName 
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    
    If connectionString  &lt;&gt; &quot;&quot; And timeout  &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate dbMasterConnection, connectionString, timeout, netBiosHostName, instanceName, False
        lastError.Save
        If lastError.Number = 0 Then
            Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If

    Dim ds: Set ds = New DriverSelector

    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Set SmartConnectWithoutSQLADODBIntent = Nothing
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)   

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, machineName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

	
    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate dbMasterConnection, connectionString, 15, netBiosHostName, instanceName, False
    lastError.Save
    If lastError.Number = 0 Then
        Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If

    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
                lastError.Save
                If lastError.Number = 0 Then
                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
                End If
            Next
        Else
    	    &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
	                lastError.Save
	                If lastError.Number = 0 Then
	                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
		                lastError.Save
		                If lastError.Number = 0 Then
		                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Function SmartConnect(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName)    
     SmartConnect = SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, intent)
    On Error Resume Next
    SmartConnectIntent = False
    Dim dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList 
    

    
    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName  
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)

    If connectionString &lt;&gt; &quot;&quot; And timeout &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate cnADOConnection, connectionString, timeout, netBiosHostName, instanceName, True
        lastError.Save
        If lastError.Number = 0 Then
            SmartConnectIntent = True
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If


    Dim ds: Set ds = New DriverSelector

    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, netBiosHostName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate cnADOConnection, connectionString, 15, netBiosHostName, instanceName, True
    lastError.Save
    If lastError.Number = 0 Then
        SmartConnectIntent = True
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If
	
    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
                lastError.Save
                If lastError.Number = 0 Then
                    SmartConnectIntent = True
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
                End If
            Next
        Else
            &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
	                lastError.Save
	                If lastError.Number = 0 Then
	                    SmartConnectIntent = True
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
		                lastError.Save
		                If lastError.Number = 0 Then
		                    SmartConnectIntent = True
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Sub WriteToEventLogAndExit(ByVal message)
    oAPI.LogScriptEvent &quot;Management Group: &quot; &amp; ManagementGroupName &amp; &quot;. Script: &quot; &amp; WScript.ScriptName &amp; &quot;. Version: &quot; &amp; MANAGEMENT_PACK_VERSION, 4002, EVENT_TYPE_ERROR, message   
    WScript.Quit()
End Sub

Function ExtractHostNameFromEndpoint(ByVal sEndpoint)
    If sEndpoint = &quot;&quot; Then
        ExtractHostNameFromEndpoint = &quot;&quot;
        Exit Function
    End If
    Dim oRegEx, oMatches
    Set oRegEx = MomCreateObject(&quot;VBScript.RegExp&quot;)
    oRegEx.Pattern = &quot;://(.+):&quot;
    Set oMatches = oRegEx.Execute(sEndpoint)
    If oMatches.Count &gt; 0 Then
        If oMatches(0).SubMatches.Count &gt; 0 Then
            ExtractHostNameFromEndpoint = oMatches(0).SubMatches(0)
        Else
            ExtractHostNameFromEndpoint = sEndpoint
        End If
    Else
        ExtractHostNameFromEndpoint = sEndpoint
    End If
End Function

Function GetMirroringLevelName(ByVal nSafetyLevel, ByVal sWitnessName)
    GetMirroringLevelName = &quot;Unknown state&quot;
    If nSafetyLevel = 1 Then
        GetMirroringLevelName = &quot;High-performance mode&quot;
    Else
        If sWitnessName = &quot;&quot; Then
            GetMirroringLevelName = &quot;High-safety mode without automatic failover&quot;
        Else
            GetMirroringLevelName = &quot;High-safety mode with automatic failover&quot;
        End If
    End If
End Function

Function IsExcluded(ByVal sDatabase, ByVal sExcludeList)
	Dim aExcludes, bMatch, nIndex

	bMatch = False
	If Trim(sExcludeList) = &quot;*&quot; Then
	    bMatch = True
	Else
		aExcludes = Split(sExcludeList, &quot;,&quot;)
		For nIndex = 0 To UBound(aExcludes)
			If LCase(sDatabase) = LCase(Trim(aExcludes(nIndex))) Then
				bMatch = True
			End If
		Next
	End If
	IsExcluded = bMatch
End Function

                  
                  $Config/ScriptBody$
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </DataSource>
            </MemberModules>
            <Composition>
              <Node ID="DS" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.SQLServer.Windows.Mirroring.Database.DiscoveryProvider.DS" Accessibility="Internal" RunAs="MSCL!Microsoft.SQLServer.Core.RunAs.Discovery" Batching="false">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MachineName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ConnectionString" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Version" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="ExcludeList" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TcpPorts" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="ExcludeList" Selector="$Config/ExcludeList$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedScript.DiscoveryProvider">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <ScriptName>Microsoft.SQLServer.Windows.Mirroring.Database.DiscoveryProvider.DS.vbs</ScriptName>
                <Arguments>$MPElement$ $Target/Id$ $Config/MachineName$ $Config/ConnectionString$ $Config/InstanceName$ $Config/Version$ "Exclude:$Config/ExcludeList$" "$Config/TcpPorts$"</Arguments>
                <ScriptBody>&apos;Script Begin
Option Explicit
SetLocale(&quot;en-us&quot;)

&apos;Set Constants
Const ManagementGroupName = &quot;$Target/ManagementGroup/Name$&quot;
Const SQL_DEFAULT = &quot;MSSQLSERVER&quot;
Const DEBUG_MODE = False
Const EVENT_TYPE_ERROR = 1
Const MANAGEMENT_PACK_VERSION = &quot;7.0.20.0&quot;
Const SQL_DISCOVERY_CONNECT_FAILURE = -1
Const SQL_DISCOVERY_QUERY_FAILURE = -2
Const SQL_DISCOVERY_SUCCESS = 0
Const DISCOVERY_ERROR_EVENT_ID = 7105
Const SCRIPT_EVENT_ID = 4211
Const MAX_DRIVER_VERSION_STR = &quot;99999999.99999999.99999999.99999999&quot;
Const DriverSelector_DEFAULT_DRIVER_NAME = &quot;SQL Server&quot;

Dim GlobalErrorList: Set GlobalErrorList = New ArrayList

Dim StartTime,EndTime,sTime
&apos;Capture script start time
StartTime = Now

Dim oAPI
Set oAPI = MOMCreateObject(&quot;MOM.ScriptAPI&quot;)

&apos;Log script event that we are starting discovery
Call oAPI.LogScriptEvent(&quot;Microsoft.SQLServer.Windows.Mirroring.Database.DiscoveryProvider.DS.vbs&quot;, 4002, 0, &quot;Starting script&quot;)

Dim GetMirroredDatabasesQuery
GetMirroredDatabasesQuery = &quot;SELECT &quot; &amp;_
                                &quot; d.name AS database_name, &quot; &amp;_
                                &quot; dm.mirroring_guid, &quot; &amp;_
                                &quot; dm.mirroring_partner_instance, &quot; &amp;_
                                &quot; dm.mirroring_role_desc, &quot; &amp;_
                                &quot; dm.mirroring_state, &quot; &amp;_
                                &quot; dm.mirroring_witness_state, &quot; &amp;_
                                &quot; dm.mirroring_safety_level, &quot; &amp;_
                                &quot; dm.mirroring_witness_name &quot; &amp;_
                            &quot; FROM &quot; &amp;_
                                &quot; sys.database_mirroring dm &quot; &amp;_
                                &quot; join sys.databases d ON (dm.database_id = d.database_id) &quot; &amp;_
                            &quot; WHERE mirroring_guid IS NOT NULL&quot;

&apos; #Include File:DiscoverSQLWindowsMirroredDB.vbs
&apos; Copyright (c) Microsoft Corporation. All rights reserved.
&apos; Parameters that should be passed to this script
&apos; 0 MPElement ID ($MPElement$)
&apos; 1 Target Id for ME this rule is running against ($Target/Id$)
&apos; 2 Computer Name
&apos; 3 SQL Connection String for the targeted DB Engine
&apos; 4 SQL Instance for the targeted DB Engine 
&apos; 5 SQL Version for the targeted DB Engine
&apos; 6 Excluded database list (prefixed with Exclude:)
&apos; 7 TCP Ports optional

Dim oArgs
Set oArgs = WScript.Arguments
If oArgs.Count &lt; 7 Or oArgs.Count &gt; 8 Then
   Wscript.Quit -1
End If

Dim SourceID, ManagedEntityId, InstanceName, ConnectionString, SQLVersion, TargetComputer, ExcludeList, sTcpPort

SourceId = oArgs(0)
ManagedEntityId = oArgs(1)
TargetComputer = oArgs(2)
ConnectionString = oArgs(3)
InstanceName = oArgs(4)
SQLVersion = oArgs(5)
ExcludeList = Mid(oArgs(6), 9)
sTcpPort = &quot;&quot;
If oArgs.Count = 8 Then
    sTcpPort = oArgs(7)
End If

Dim SQLVersionArr, SQLMajorVersion, SQL_WMI_NAMESPACE
SQLVersionArr = split(SQLVersion,&quot;.&quot;)
SQLMajorVersion = SQLVersionArr(0)
SQL_WMI_NAMESPACE = &quot;ComputerManagement&quot; &amp; SQLMajorVersion

Dim oDiscoveryData
Set oDiscoveryData = oAPI.CreateDiscoveryData(0, SourceId, ManagedEntityId)

Dim errorCode: errorCode = 0

Dim state, serviceName
serviceName = GetSQLServiceName(InstanceName)
state = GetServiceState(TargetComputer, serviceName)
If (state &lt;&gt; &quot;Running&quot;) And (state &lt;&gt; &quot;Unknown&quot;) Then
    oDiscoveryData.IsSnapshot = False
Else
    If DoDatabaseDiscovery() &lt; 0 Then 
        errorCode = -1
        oAPI.LogScriptEvent &quot;Management Group: &quot; &amp; ManagementGroupName &amp; &quot;. Script: &quot; &amp; WScript.ScriptName &amp; &quot;. Version: &quot; &amp; MANAGEMENT_PACK_VERSION &amp; &quot;. Instance: &quot; &amp; InstanceName, DISCOVERY_ERROR_EVENT_ID, EVENT_TYPE_ERROR, &quot;Mirrored DB discovery script &apos;&quot; &amp; WScript.ScriptName &amp; &quot;&apos; for instance &apos;&quot; &amp; InstanceName &amp; &quot;&apos; failed.&quot; &amp; vbNewLine &amp; GetGlobalErrorListEventString()
        Call GlobalErrorList.Clear()
    End If
End If

&apos;Capture script runtime for logging
EndTime = Now
sTime = DateDiff(&quot;s&quot;, StartTime, EndTime)
&apos;Log script event that we are ending discovery
Call oAPI.LogScriptEvent(&quot;Microsoft.SQLServer.Windows.Mirroring.Database.DiscoveryProvider.DS.vbs&quot;, 4002, 0, &quot;Ending script.  Script runtime in seconds: &quot; &amp; sTime)

Call oAPI.Return(oDiscoveryData)

Call GlobalErrorListToEventLog()
WScript.Quit(errorCode)


Function MomCreateObject(ByVal sProgramId)
    Dim oError
    Set oError = New Error
    
	On Error Resume Next
	Set MomCreateObject = CreateObject(sProgramId)
	oError.Save
	On Error Goto 0
	
	If oError.Number &lt;&gt; 0 Then ThrowScriptError &quot;Unable to create automation object &apos;&quot; &amp; sProgramId &amp; &quot;&apos;&quot;, oError
End Function

Public Function GetSQLServiceName(sInstance)
    If sInstance = SQL_DEFAULT Then
        GetSQLServiceName = SQL_DEFAULT
    Else
        GetSQLServiceName = &quot;MSSQL$&quot; &amp; sInstance
    End If
End Function

Function GetServiceState( sTargetComputer, sServiceName)
    On Error Resume Next    

    Dim sNamespace, sQuery, oWMI, objClasses, sState
    sNamespace = &quot;winmgmts://&quot; &amp; sTargetComputer &amp; &quot;/root/cimv2&quot;
    sQuery = &quot;SELECT State FROM Win32_Service where  Name = &quot;&quot;&quot; &amp; EscapeWQLString(sServiceName) &amp; &quot;&quot;&quot;&quot;
    
    Set oWMI = GetObject(sNamespace)
    Set objClasses = oWMI.ExecQuery(sQuery)

    if objClasses.Count &gt;= 1 Then
        sState = GetFirstItemFromWMIQuery(objClasses).Properties_.Item(&quot;State&quot;)
    End If
    
    If Err.number &lt;&gt; 0 Or objClasses.Count = 0 Then
        sState = &quot;Unknown&quot;
    End If 

    Err.Clear
    GetServiceState = sState
End Function

Class Error
    Private m_lNumber
    Private m_sSource
    Private m_sDescription
    Private m_sHelpContext
    Private m_sHelpFile

    Public Sub Save()
        m_lNumber = Err.Number
        m_sSource = Err.Source
        m_sDescription = Err.Description
        m_sHelpContext = Err.HelpContext
        m_sHelpFile = Err.HelpFile
    End Sub

    Public Sub Raise()
        Err.Raise m_lNumber, m_sSource, m_sDescription, m_sHelpFile, m_sHelpContext
    End Sub

    Public Sub Clear()
        m_lNumber = 0
        m_sSource = &quot;&quot;
        m_sDescription = &quot;&quot;
        m_sHelpContext = &quot;&quot;
        m_sHelpFile = &quot;&quot;
    End Sub

    Public Default Property Get Number()
        Number = m_lNumber
    End Property
    Public Property Get Source()
        Source = m_sSource
    End Property
    Public Property Get Description()
        Description = m_sDescription
    End Property
    Public Property Get HelpContext()
        HelpContext = m_sHelpContext
    End Property
    Public Property Get HelpFile()
        HelpFile = m_sHelpFile
    End Property    
End Class

Class ArrayList
    Private m_itemArray

    Private Sub Class_Initialize()
        Me.Clear
    End Sub

    Private Sub AddItemToArray(ByRef itemArray, ByVal item)
        ReDim Preserve itemArray(UBound(itemArray) + 1) 
        itemArray(UBound(itemArray)) = item
    End Sub

    Public Sub Clear()
        m_itemArray = Array()
    End Sub

    Public Sub Add(item)
        AddItemToArray m_itemArray, item
    End Sub

    Public Sub RemoveAt(index)
        If index &lt; 0 Or index &gt; UBound(m_itemArray) Then
            Exit Sub
        End If
        Dim newArr: newArr = Array()
        Dim i
        For i = 0 To UBound(m_itemArray)
            If i &lt;&gt; index Then
                Call AddItemToArray(newArr, m_itemArray(i))
            End If
        Next
        m_itemArray = newArr
    End Sub

    Public Property Get Count()
        Count = UBound(m_itemArray) + 1
    End Property

    Public Property Get ItemsArray()
        ItemsArray = m_itemArray
    End Property

    Public Property Get IsEmpty()
        IsEmpty = UBound(m_itemArray) &lt; 0
    End Property
End Class

Class ScriptLogger
    Dim sourceLogEvent
    
    Private Sub Class_Initialize()
        sourceLogEvent = &quot;Management Group: &quot; + ManagementGroupName + &quot;. Script: &quot; + WScript.ScriptName + &quot;. Version: &quot; + MANAGEMENT_PACK_VERSION
    End Sub
    
    Private Sub Class_Terminate()
    End Sub
    
    Public Property Get ErrorEventType
        ErrorEventType = 1
    End Property
    
    Public Property Get WarningEventType
        WarningEventType = 2
    End Property
    
    Public Property Get InfoEventType
        InfoEventType = 4
    End Property

    Private Function LogEvent (message, eventType)
        On Error Resume Next
        Dim oAPI
        Set oAPI = CreateObject(&quot;MOM.ScriptAPI&quot;)
        Call oAPI.LogScriptEvent(sourceLogEvent, SCRIPT_EVENT_ID, eventType, message)
    End Function

    Public Function LogDebug(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
            LogEvent message, Me.InfoEventType
        End If
    End Function
    
    Public Function LogError(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.ErrorEventType
    End Function
    
    Public Function LogWarning(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.WarningEventType
    End Function
    
    Public Function LogFormattedError(customMessage)
        If Err.number &lt;&gt; 0 Then
            Me.LogError FormatErrorMessage(customMessage, &quot;&quot;)
        End If
    End Function
    
    Private Function ScriptInfo()
        Dim commandLineInfo  : commandLineInfo = WScript.ScriptFullName
        Dim argument
        For Each argument In WScript.Arguments
            commandLineInfo = commandLineInfo &amp; &quot; &quot;&quot;&quot; &amp; argument &amp; &quot;&quot;&quot;&quot;
        Next
        ScriptInfo = commandLineInfo
    End Function
End Class

Function FormatErrorMessage(customMessage, instanceName)
    FormatErrorMessage = customMessage
    If Err.number &lt;&gt; 0 Then
        Dim msg
        msg =_
        &quot; Error Number: &quot; &amp; CStr(Err.number) &amp; VbCrLf &amp; _
        &quot; Description: &quot; &amp; Err.Description

        If Not IsEmpty(instanceName) And instanceName &lt;&gt; &quot;&quot; Then
            msg = msg &amp; VbCrLf &amp; &quot; Instance: &quot; &amp; instanceName
        End If
        If customMessage &lt;&gt; &quot;&quot; Then
            msg = customMessage &amp; VbCrLf &amp; msg &amp; VbCrLf
        End If       
        FormatErrorMessage = msg
    End If
End Function

Function FormatDbErrorMessage(message, instanceName, dbName)
    FormatDbErrorMessage = message &amp; VbCrLf &amp; _
    &quot; Instance: &quot; &amp; instanceName &amp; VbCrLf &amp; _
    &quot; Database: &quot; &amp; dbName
End Function

Function ThrowScriptErrorNoAbort(ByVal sMessage, ByVal oErr)
    On Error Resume Next
    Dim errorText: errorText =  sMessage &amp; &quot;: &quot; &amp; oErr.Description
    GlobalErrorList.Add errorText
End Function

Function ThrowScriptError(Byval sMessage, ByVal oErr)
    On Error Resume Next
    ThrowScriptErrorNoAbort sMessage, oErr
    GlobalErrorListToEventLog()
    Quit()
End Function

Sub HandleError(customMessage)
    Dim localLogger
    If Err.number &lt;&gt; 0 Then
        Set localLogger = new ScriptLogger
        Call localLogger.LogFormattedError(customMessage)
        Call Wscript.Quit(0)
    End If
End Sub

Function HandleErrorContinue(customMessage)
    HandleErrorContinue = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinue = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, &quot;&quot;))
        Call Err.Clear()
    End If
End Function

Function HandleErrorContinueEx(customMessage, instanceName)
    HandleErrorContinueEx = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinueEx = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, instanceName))
        Call Err.Clear()
    End If
End Function

Function HandleSqlErrorContinue(adoConnection, customMessage, instanceName)
    HandleSqlErrorContinue = True   
    If Err.Number &lt;&gt; 0 Then
        HandleSqlErrorContinue = False
        Dim sqlErr
        Dim e: Set e = new Error
        e.Save
        On Error Resume Next
        If adoConnection.Errors.Count &gt; 0 Then
            Set sqlErr = adoConnection.Errors(0)
            adoConnection.Errors.Clear
            Call Err.Raise(sqlErr.Number, sqlErr.Source, sqlErr.Description)
        Else
            Call e.Raise()
        End If
        Call HandleErrorContinueEx(customMessage, instanceName)
    End If
End Function

Function GetGlobalErrorListEventString()
    GetGlobalErrorListEventString = &quot;&quot;
    If Not GlobalErrorList.IsEmpty Then
        GetGlobalErrorListEventString = &quot;The next errors occurred:&quot;&amp; vbNewLine &amp; Join(GlobalErrorList.ItemsArray, vbNewLine &amp; vbNewLine)
    End If
End Function

Function GlobalErrorListToEventLog()
    On Error Resume Next
    If Not GlobalErrorList.IsEmpty Then
        Dim localLogger: Set localLogger = New ScriptLogger
        localLogger.LogWarning GetGlobalErrorListEventString()
    End If
End Function

Function Quit()
    WScript.Quit()
End Function

Sub WriteToEventLogAndExit(ByVal message)
    oAPI.LogScriptEvent &quot;Management Group: &quot; &amp; ManagementGroupName &amp; &quot;. Script: &quot; &amp; WScript.ScriptName &amp; &quot;. Version: &quot; &amp; MANAGEMENT_PACK_VERSION, 4002, EVENT_TYPE_ERROR, message   
    WScript.Quit()
End Sub

Function EscapeWQLString (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function ConnectToWMI(ComputerName, strNamespace)
    Set ConnectToWMI = Nothing
	Set ConnectToWMI = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; ComputerName &amp; &quot;\&quot; &amp; strNamespace)
End Function

Function WMIGetProperty(oWmi, sPropName, nCIMType, ErrAction)
    Dim sValue, oWmiProp
    
    If Not IsValidObject(oWmi) Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;Accessing property on invalid WMI object.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        Exit Function
    End If
    
    On Error Resume Next
    Set oWmiProp = oWmi.Properties_.Item(sPropName)
    If Err.Number &lt;&gt; 0 Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
    End If
    On Error GoTo 0
    
    If IsValidObject(oWmiProp) Then
        sValue = oWmiProp.Value
        
        If IsNull(sValue) Then
            &apos;
            &apos; If value is null, return blank to avoid any issues
            &apos;
            WMIGetProperty = &quot;&quot;
            
        Else
            
            Select Case (oWmiProp.CIMType)
                Case wbemCimtypeString, wbemCimtypeSint16, wbemCimtypeSint32, wbemCimtypeReal32, wbemCimtypeReal64, wbemCimtypeSint8, wbemCimtypeUint8, wbemCimtypeUint16, wbemCimtypeUint32, wbemCimtypeSint64, wbemCimtypeUint64:
                    If Not oWmiProp.IsArray Then
                        WMIGetProperty = Trim(CStr(sValue))
                    Else
                        WMIGetProperty = Join(sValue, &quot;, &quot;)
                    End If

                Case wbemCimtypeBoolean:
                    If sValue = 1 Or UCase(sValue) = &quot;TRUE&quot; Then
                        WMIGetProperty = &quot;True&quot;
                    Else
                        WMIGetProperty = &quot;False&quot;
                    End If

                Case wbemCimtypeDatetime:
                    Dim sTmpStrDate
                
                    &apos;
                    &apos; First attempt to convert the whole wmi date string
                    &apos;
                    sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                  Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                  Left(sValue, 4) &amp; &quot; &quot; &amp; _
                                  Mid (sValue, 9, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 11, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 13, 2)
                    If IsDate(sTmpStrDate) Then
                        WMIGetProperty = CDate(sTmpStrDate)
                    Else
                    
                        &apos;
                        &apos; Second, attempt just to convert the YYYYMMDD
                        &apos;
                        sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                      Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                      Left(sValue, 4)
                        If IsDate(sTmpStrDate) Then
                            WMIGetProperty = CDate(sTmpStrDate)
                        Else
                            &apos;
                            &apos; Nothing works - return passed in string
                            &apos;
                            WMIGetProperty = sValue
                        End If
                    
                    End If
                
                Case Else:
                    WMIGetProperty = &quot;&quot;
            End Select
        End If
    Else
        
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        
    End If
    
    
    If (ErrAction And ErrAction_Trace) = ErrAction_Trace Then _
        WScript.Echo &quot;  + &quot; &amp; sPropName &amp; &quot; :: &apos;&quot; &amp; WMIGetProperty &amp; &quot;&apos;&quot;
    
End Function

Function WMIExecQuery(ByVal sNamespace, ByVal sQuery)
    &apos;
    &apos; WMIExecQuery :: Executes the WMI query and returns the result set.
    &apos;
    &apos;
    Dim oWMI, oQuery, nInstanceCount
    Dim e
    Set e = New Error
    On Error Resume Next
    Set oWMI = GetObject(sNamespace)
    e.Save
    On Error GoTo 0
    If IsEmpty(oWMI) Then
        ThrowScriptErrorNoAbort &quot;Unable to open WMI Namespace &apos;&quot; &amp; sNamespace &amp; &quot;&apos;.  Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists.&quot;, e
        ThrowEmptyDiscoveryData
    End If
    
    On Error Resume Next
        Set oQuery = oWMI.ExecQuery(sQuery)
        e.Save
    On Error GoTo 0
    If IsEmpty(oQuery) Or e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; returned an invalid result set.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    &apos;Determine if we queried a valid WMI class - Count will return 0 or empty
    On Error Resume Next
    nInstanceCount = oQuery.Count
    e.Save
    On Error GoTo 0
    If e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; did not return any valid instances.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    Set WMIExecQuery = oQuery
    
End Function

Function GetFirstItemFromWMIQuery(ByRef oQuery)
    ON ERROR RESUME NEXT
    Err.Clear
    Dim oResult: Set oResult = Nothing
    Set oResult = oQuery.ItemIndex(0)
    if Err.number &lt;&gt; 0 then
        Err.Clear
        Dim oObject
        For Each oObject in oQuery 
            Set oResult = oObject
            Exit For
        Next    
    end if
    Set GetFirstItemFromWMIQuery = oResult
End Function

Class Registry
    Public HKEY_CLASSES_ROOT
    Public HKEY_CURRENT_USER
    Public HKEY_LOCAL_MACHINE
    Public HKEY_USERS
    Public HKEY_CURRENT_CONFIG
    Public HKEY_DYN_DATA 

    Public ERROR_ACCESS_DENIED
    Public ERROR_KEY_NOT_FOUND
    Public ERROR_VALUE_NOT_FOUND
    Public SUCCESS
    
    Private m_oReg
    Private m_lHive
    
    Private Sub Class_Initialize()
        HKEY_CLASSES_ROOT = &amp;H80000000
        HKEY_CURRENT_USER = &amp;H80000001 
        HKEY_LOCAL_MACHINE = &amp;H80000002
        HKEY_USERS = &amp;H80000003 
        HKEY_CURRENT_CONFIG = &amp;H80000005
        HKEY_DYN_DATA = &amp;H80000006
        
        ERROR_ACCESS_DENIED = 5
        ERROR_KEY_NOT_FOUND = 2
        ERROR_VALUE_NOT_FOUND = 1
        SUCCESS = 0
        
        m_lHive = HKEY_LOCAL_MACHINE
    End Sub
    
    Public Sub Connect(ByVal sHostName)
        Set m_oReg = GetObject(&quot;winmgmts://&quot; &amp; sHostName &amp; &quot;/root/default:StdRegProv&quot;)
    End Sub
    
    Public Property Get Hive()
        Hive = m_lHive
    End Property
    
    Public Property Let Hive(ByVal lHive)
        m_lHive = lHive
    End Property
    
    Public Function ReadDWORDValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim lValue
        lResult = m_oReg.GetDWORDValue(m_lHive, sKeyPath, sValueName, lValue)
        ReadDWORDValue = lValue
    End Function
    
    Public Function ReadStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim sValue
        lResult = m_oReg.GetStringValue(m_lHive, sKeyPath, sValueName, sValue)
        ReadStringValue = sValue
    End Function
    
    Public Function ReadMultiStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aValues
        lResult = m_oReg.GetMultiStringValue(m_lHive, sKeyPath, sValueName, aValues)
        ReadMultiStringValue = aValues
    End Function
    
    Public Function EnumKeys(ByVal sKeyPath, ByRef lResult)
        Dim aSubKeys
        lResult = m_oReg.EnumKey(m_lHive, sKeyPath, aSubKeys)
        EnumKeys = aSubKeys
    End Function

    Public Function EnumValues(ByVal sKeyPath, ByRef lResult)
        Dim aNames, aTypes
        lResult = m_oReg.EnumValues(m_lHive, sKeyPath, aNames, aTypes)
        EnumValues = aNames
    End Function
    
    Public Function CreateKey(ByVal sKeyPath)
        CreateKey = m_oReg.CreateKey(m_lHive, sKeyPath)
    End Function
    
    Public Function WriteStringValue(ByVal sKeyPath, ByVal sValueName, ByVal sValue)
        WriteStringValue = m_oReg.SetStringValue(m_lHive, sKeyPath, sValueName, sValue)
    End Function
    
    Public Function DeleteValue(ByVal sKeyPath, ByVal sValueName)
        DeleteValue = m_oReg.DeleteValue(m_lHive, sKeyPath, sValueName)
    End Function
    
    Public Function ReadBinaryValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aData
        lResult = m_oReg.GetBinaryValue(m_lHive, sKeyPath, sValueName, aData)
        ReadBinaryValue = aData
    End Function

End Class

Function ArraysAreIntersected(ByRef arrA, ByRef arrB)
    Dim itemA, itemB
    ArraysAreIntersected = False
    For Each itemA in arrA
        For Each itemB in arrB
            If itemA = itemB Then
                ArraysAreIntersected = True
                Exit Function
            End If
        Next
    Next
End Function

Function ArrayContains(ByRef arr, ByRef searchItem)
    ArrayContains = False
    Dim item
    For Each item In arr
        If item = searchItem Then
            ArrayContains = True
            Exit Function
        End If
    Next
End Function

Function GetDriverVersionObj(oVersion)
    Dim tpName, vVersion
    tpName = TypeName(oVersion)
    Select Case tpName
    Case &quot;DriverVersion&quot;
        Set vVersion = oVersion
    Case &quot;String&quot;
        Set vVersion = (new DriverVersion)(oVersion)
    Case Else
        Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Parameter is not an instance of type DriverVersion.&quot;)
    End Select
    Set GetDriverVersionObj = vVersion
End Function

Class DriverVersion
    Private m_major
    Private m_minor
    Private m_build
    Private m_revision
    
    Public Default Function Init(versionStr)
        Parse(versionStr)
        Set Init = Me
    End Function

    Private Sub Parse(vStr)
        Dim parts, versionRegex, oRegex, matches
        Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{1,8})(.\d{1,8}){0,3}$&quot;
        Set matches = oRegex.Execute(vStr)
        If matches.Count = 0 Then
            Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Invalid version string.&quot;)
        End If
        parts = Split(vStr, &quot;.&quot;)
        m_major = CLng(parts(0))
        m_minor = 0
        m_build = 0
        m_revision = 0
        IF UBound(parts) &gt;= 1 Then
            m_minor = CLng(parts(1))
            If UBound(parts) &gt;= 2 Then
                m_build = CLng(parts(2))
                If UBound(parts) &gt;= 3 Then
                    m_revision = CLng(parts(3))
                End If
            End If
        End If
    End Sub

    Public Function CompareTo(v)
        Dim d
        d = m_major - v.Major
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_minor - v.Minor
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_build - v.Build
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_revision - v.Revision
        CompareTo = d
    End Function
    
    Public Function ToString()
        ToString = &quot;&quot; &amp; m_major &amp; &quot;.&quot; &amp; m_minor &amp; &quot;.&quot; &amp; m_build &amp; &quot;.&quot; &amp; m_revision
    End Function

    Public Property Get Major()
        Major = m_major
    End Property

    Public Property Get Minor()
       Minor = m_minor
    End Property

    Public Property Get Build()
       Build = m_build
    End Property

    Public Property Get Revision()
       Revision = m_revision
    End Property
End Class

Class VersionRange
    Private m_startVersion
    Private m_endVersion

    Public Default Function Init(sStartVersion, sEndVersion)
        Set m_startVersion = GetDriverVersionObj(sStartVersion)
        Set m_endVersion = GetDriverVersionObj(sEndVersion)
        Set Init = Me
    End Function

    Public Property Get StartVersion()
        Set StartVersion = m_startVersion
    End Property

    Public Property Get EndVersion()
        Set EndVersion = m_endVersion
    End Property
End Class

Class DriverItem
    Private m_name
    Private m_nameVersion
    Private m_driverVersion
    Private m_parseObject

    Public Default Function Init(sName, oNameVersion, oDriverVersion, ByRef oParseObject)
        m_Name = sName
        Set m_nameVersion = GetDriverVersionObj(oNameVersion)
        Set m_driverVersion = GetDriverVersionObj(oDriverVersion)
        Set m_parseObject = oParseObject
        Set Init = Me
    End Function 

    Public Property Get Name()
        Name = m_name
    End Property

    Public Property Get NameVersion()
        Set NameVersion = m_nameVersion
    End Property

    Public Property Get DriverVersion()
        Set DriverVersion = m_driverVersion
    End Property
    
    Public Property Get ParseObject()
        Set ParseObject = m_parseObject
    End Property
End Class

Class DriverSelectorRule
    Private m_nameRegexStr
    Private m_nameRegex
    Private m_versionRegexStr
    Private m_versionRegex
    Private m_nameMinVersion
    Private m_nameMaxVersion
    Private m_computerId
    Private m_driverVersionArr

    Public DriverCollection
    Public IsNativeClient

    Public Default Function Init(sNameRegex, sVersionRegex, sNameMinVersion, sNameMaxVersion, oVersionRangeArray)
        m_computerId = &quot;.&quot;
        m_nameRegexStr = sNameRegex
        Set m_nameRegex = New RegExp
        m_nameRegex.Pattern = m_nameRegexStr
        m_versionRegexStr = sVersionRegex
        If Not IsNull(m_versionRegexStr) Then
            If Len(m_versionRegexStr) &gt; 0 Then
                Set m_versionRegex = New RegExp
                m_versionRegex.Pattern = m_versionRegexStr
                m_versionRegex.Global = True
            End If
        End If
        Set m_nameMinVersion = GetDriverVersionObj(sNameMinVersion)
        Set m_nameMaxVersion = GetDriverVersionObj(sNameMaxVersion)
        m_driverVersionArr = oVersionRangeArray

        DriverCollection = Array()
        IsNativeClient = False
        Set Init = Me
    End Function

     Private Function CheckVersion(oVersion, vMinVersion, vMaxVersion)
        Dim vVersion: Set vVersion = GetDriverVersionObj(oVersion)
        CheckVersion = vVersion.CompareTo(vMinVersion) &gt;= 0 And (vVersion.ToString() = MAX_DRIVER_VERSION_STR Or vMinVersion.CompareTo(vMaxVersion) = 0 Or vVersion.CompareTo(vMaxVersion) &lt; 0)
    End Function

    Public Function MatchName(sDriverName)
        Dim matches
        Set matches = m_nameRegex.Execute(sDriverName)
        If matches.Count &gt; 0 Then
            MatchName = True
            Exit Function
        End If
        MatchName = False
    End Function

    Public Function GetNameVersion(sDriverName)
        Dim sVersion, matches
        If Not IsNull(m_versionRegexStr) Then
            Set matches = m_versionRegex.Execute(sDriverName)
            If matches.Count &gt; 0 Then
                sVersion = matches(0).Value
            End If   
        End If
        If Not IsNull(sVersion) Then
            Set GetNameVersion = GetDriverVersionObj(sVersion)
        Else
            Set GetNameVersion = GetDriverVersionObj(&quot;0&quot;)
        End If
    End Function

    Public Function CheckNameVersion(oVersion)
        CheckNameVersion = CheckVersion(oVersion, m_nameMinVersion, m_nameMaxVersion)
    End Function

    Public Function CheckDriverVersion(oVersion)
        CheckDriverVersion = False
        Dim driverVersionItem
        For Each driverVersionItem In m_driverVersionArr
             If CheckVersion(oVersion, driverVersionItem.StartVersion, driverVersionItem.EndVersion) Then
                CheckDriverVersion = True
                Exit For
            End If
        Next
    End Function

    Public Function GetDriverVersion(sDriverName)
        Dim computerId, driverPath, sDllVersion, objFSO, oRegistry
        Dim HKEY_LOCAL_MACHINE: HKEY_LOCAL_MACHINE = &amp;H80000002
        Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\&quot; &amp; sDriverName, &quot;Driver&quot;, driverPath   
        Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;) 
        sDllVersion =  objFSO.GetFileVersion(driverPath)
        Set GetDriverVersion = (new DriverVersion)(sDllVersion)
    End Function

    Public Sub AddDriver(ByRef oDriver)
        ReDim Preserve DriverCollection(UBound(DriverCollection) + 1) 
        Set DriverCollection(UBound(DriverCollection)) = oDriver
    End Sub

    Public Sub ResetState()
        DriverCollection = Array()
    End Sub

    Public Property Get DriverNameRegex()
        DriverNameRegex = m_nameRegexStr
    End Property

    Public Property Get NameMinVersion()
        Set NameMinVersion= m_nameMinVersion
    End Property

    Public Property Get NameMaxVersion()
        Set NameMaxVersion = m_nameMaxVersion
    End Property

    Public Property Get VersionRangeCollection()
        VersionRangeCollection = m_driverVersionArr
    End Property

    Public Property Get CollectionIsEmpty()
        CollectionIsEmpty = UBound(DriverCollection) &lt; 0
    End Property
End Class

Class DriverSelector
	Private m_computerId
    Private m_selectorRules(3)
    Private m_selectedDriverName
    Private m_processed
    Private HKEY_LOCAL_MACHINE
    Private m_defaultDriverName

    Private m_ncli_ForceProtocolEncryption
    Private m_ncli_TrustServerCertificate

    Private m_ncli_tcpProtocolEnabled
    Private m_ncli_smProtocolEnabled

    Public ErrorCollection

    Private Sub Class_Initialize()
        Set m_selectorRules(0) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;,&quot;\d{1,8}(\.\d{1,8})?$&quot;, &quot;11.0&quot;, &quot;11.0&quot;,_
            Array(_
               (new VersionRange)(&quot;2011.110.6020.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2011.110.5592.0&quot;, &quot;2011.110.6000.0&quot;),_
               (new VersionRange)(&quot;2011.110.5347.0&quot;, &quot;2011.110.5522.0&quot;)))
        m_selectorRules(0).IsNativeClient = True
        Set m_selectorRules(1) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;11.0&quot;, MAX_DRIVER_VERSION_STR,_
            Array(_
               (new VersionRange)(&quot;2014.120.4219.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2014.120.2546.0&quot;, &quot;2014.120.4000.0&quot;)))
        Set m_selectorRules(2) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;, &quot;\d{1,8}(\.\d{1,8})?$&quot;,&quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
        m_selectorRules(2).IsNativeClient = True
        Set m_selectorRules(3) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
		
        m_computerId = &quot;.&quot;
        m_defaultDriverName = &quot;SQL Server&quot;
        HKEY_LOCAL_MACHINE = &amp;H80000002
        m_ncli_ForceProtocolEncryption = False
        m_ncli_TrustServerCertificate = False
        m_ncli_tcpProtocolEnabled  = True
        m_processed = False
        Call ResetState()
    End Sub

    &apos; Select most appropriate driver from filtered installed system (ODBC) drivers.
    &apos; select all available drivers
    &apos; Filter by driver name and version
    &apos; Intersected: check client and server have shared protocols
    &apos; tcp and np (Named Pipes) can work by network, sm can work only locally
    &apos; driver priorities: sm, tcp; np not used
    &apos; 
    &apos; For native client need common client and server protocols
    &apos; 
    &apos; Select latest namespace with highest version
    &apos; Select client protocols
    &apos; Select server protocols (enabled)
    &apos; Intersect client and server protocols
    &apos; Select odbc drivers related to inresected protocols
    &apos; We have 3 possible drivers:
    &apos; - ODBC (all protocols enabled)
    &apos; - Native Client (tcp, sm, np protocols)
    &apos;      only native client can choose protocols through registry settings
    &apos; - Microsoft SQL Server (all protocols enabled)
	Public Sub ProcessDrivers(enabledServerProtocols)
        Dim ri, i, isSelected, currentSelect, oError
        Set oError = New Error
        Call ResetState()
        On Error Resume Next

        Dim client: Set client = GetClientParameters()

        Dim ncProtocolsAreIntersected: ncProtocolsAreIntersected = ArraysAreIntersected(enabledServerProtocols, client.Protocols)
		Call ProcessSystemOdbcDrivers(ncProtocolsAreIntersected)

        oError.Save
        If oError.Number &lt;&gt; 0 Then
            Call AddError(oError)
            m_selectedDriverName = m_defaultDriverName
            m_processed = true
            Exit Sub
        End If
        On Error GoTo 0
        
        Dim driver: Set driver = SelectFreshDriver(m_selectorRules)

        If Not driver Is Nothing Then
            If driver.ParseObject.IsNativeClient Then
                client.IsTcpProtocolEnabled = ArrayContains(client.Protocols, &quot;tcp&quot;)
                client.IsSharedMemoryProtocolEnabled = ArrayContains(client.Protocols, &quot;sm&quot;)
            End If
        End If

        If Not driver Is Nothing Then
            client.DriverName = driver.Name
        End If

        &apos; for compatibility fill deprecated
        m_selectedDriverName = client.DriverName
        m_ncli_ForceProtocolEncryption = client.IsForceProtocolEncryption
        m_ncli_TrustServerCertificate = client.IsTrustServerCertificate
        m_ncli_tcpProtocolEnabled = client.IsTcpProtocolEnabled
        m_ncli_smProtocolEnabled = client.IsSharedMemoryProtocolEnabled

        m_processed = True
	End Sub

    Private Function SelectFreshDriver(rules)
        Set SelectFreshDriver = Nothing
        Dim selected: Set selected = Nothing
        Dim rule: Set selected = Nothing
        Dim driver: Set selected = Nothing

        For Each rule In rules
            For Each driver In rule.DriverCollection
                &apos; select first if not selected
                If selected Is Nothing Then
                    Set selected = driver
                Else
                    &apos; select fresh, compare driver with selected by name and
                    &apos; version
                    if driver.NameVersion.CompareTo(selected.NameVersion) &gt;= 0 And _
                        driver.DriverVersion.CompareTo(selected.DriverVersion) &gt;= 0 Then
                        Set selected = driver
                    End If
                End If
            Next

            &apos; all rules have order by priority, if rule contains drivers, then
            &apos; selected with high priority
            if Not selected Is Nothing Then
                Exit For
            End If
        Next

        Set SelectFreshDriver = selected
    End Function

    Private Function GetClientParameters()
        Set GetClientParameters = Nothing
        Dim params: Set params = (New ConnectionParams)(&quot;.&quot;)
        params.Namespace = GetNsNameWithHighestVersion()
        Call GetNativeClientSettings(params.Namespace, params)
        params.Protocols = GetEnabledNativeClientProtocols(params.Namespace)
        Set GetClientParameters = params
    End Function
	
    Private Sub ProcessOdbcDriver(driverName, protocolsAreIntersected)
        Dim isInstalled, oRegistry, oNameVersion, oDriverVersion
        Set oRegistry = GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)
        
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverName, isInstalled 
        Dim selectorRule
        For Each selectorRule In m_selectorRules
            If (isInstalled &lt;&gt; &quot;Installed&quot;) Then
                Exit For
            End If
            If selectorRule.MatchName(driverName) Then
                If (Not selectorRule.IsNativeClient) Or (selectorRule.IsNativeClient And protocolsAreIntersected) Then
                    Set oNameVersion = selectorRule.GetNameVersion(driverName)
                    If (selectorRule.CheckNameVersion(oNameVersion)) Then
                        Set oDriverVersion = selectorRule.GetDriverVersion(driverName)
                        If (selectorRule.CheckDriverVersion(oDriverVersion)) Then
                            selectorRule.AddDriver((new DriverItem)(driverName, oNameVersion, oDriverVersion, selectorRule))
                            Exit For
                        End If
                    End If
                End If
            End If
        Next
    End Sub

    &apos; Get available drivers in the system and fill rules drivers
    &apos; TODO: rename method
	Private Sub ProcessSystemOdbcDrivers(protocolsAreIntersected)
        Dim oRegistry, driverNames, paramValueTypes, i, oError
        Set oError = New Error
		Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
		Call oRegistry.EnumValues(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverNames, paramValueTypes)
		On Error Resume Next

        Dim driverName
        For Each driverName In driverNames
            oError.Clear
            Call ProcessOdbcDriver(driverName, protocolsAreIntersected)
            oError.Save
            If oError.Number &lt;&gt; 0 Then
                Call AddError(oError)
            End If
		Next
	End Sub
	
    Private Function GetNsNameWithHighestVersion()
        Dim rootNs: rootNs = &quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\Microsoft\SqlServer&quot;
        Dim oWMI: Set oWMI = GetObject(rootNs)
        Dim namespaces: Set namespaces = oWMI.ExecQuery(&quot;SELECT Name FROM __NAMESPACE WHERE Name LIKE &apos;ComputerManagement%&apos;&quot;)
        Dim currentName: currentName = &quot;&quot;
        Dim objItem
	    For Each objItem In namespaces
            If objItem.Name &gt; currentName Then
                currentName = objItem.Name
            End If
        Next
        GetNsNameWithHighestVersion = rootNs &amp; &quot;\&quot; &amp; currentName
    End Function

    Private Sub GetNativeClientSettings(namespaceFullName, params)
        On Error Resume Next
        Err.Clear

        Dim sNamespace, oWMI, objClasses, sState, sTargetComputer
        Set oWMI = GetObject(namespaceFullName)
        Set objClasses = Nothing

        &apos; query can fail, because native client not supported
        Set objClasses = oWMI.ExecQuery(&quot;SELECT FlagName, FlagValue FROM ClientSettingsGeneralFlag&quot;)

        &apos; do nothing, its ok, just skip this settings
        If (Err.Number &lt;&gt; 0) Or (objClasses Is Nothing) Then
            Exit Sub
        End If

        Dim objItem
        For Each objItem in objClasses
            Select Case objItem.FlagName
            Case &quot;Force protocol encryption&quot;
                &apos;m_ncli_ForceProtocolEncryption = objItem.FlagValue
                params.IsForceProtocolEncryption = objItem.FlagValue
            Case &quot;Trust Server Certificate&quot;
                &apos;m_ncli_TrustServerCertificate = objItem.FlagValue
                params.IsTrustServerCertificate = objItem.FlagValue
            End Select
        Next
    End Sub   

    Private Function GetEnabledNativeClientProtocols(namespaceFullName)
        On Error Resume Next
        Err.Clear

        Dim oWMI: Set oWMI = GetObject(namespaceFullName)  
        Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, ProtocolOrder FROM ClientNetworkProtocol&quot;)

        If (oQuery.Count &gt; 0) And (Err.Number Is 0) Then
            Dim protocolsArr: Set protocolsArr = New ArrayList
            Dim protocolItem
            For Each protocolItem In oQuery
                If protocolItem.ProtocolOrder &gt; 0 Then
                    protocolsArr.Add LCase(protocolItem.ProtocolName)
                End If
            Next
            GetEnabledNativeClientProtocols = protocolsArr.ItemsArray
        Else
            GetEnabledNativeClientProtocols = Array()
        End If
    End Function

    Private Sub AddError(oError)
        Dim newSize
        newSize = UBound(ErrorCollection) + 1
        ReDim Preserve ErrorCollection(newSize)
        ErrorCollection(newSize) = &quot;[&quot; &amp; (oError.Number and 65535) &amp; &quot;][&quot; &amp; oError.Source &amp; &quot;] &quot; &amp; oError.Description 
    End Sub

    Private Sub ResetState()
        Dim pr
        ErrorCollection = Array()
        For Each pr In m_selectorRules
            pr.ResetState()
        Next
    End Sub

    Private Sub ThrowIfNotProcessed()
        If Not m_processed Then
            Call Err.Raise(SCRIPT_EVENT_ID, &quot;&quot;, &quot;Drivers are not processed. Call &apos;ProcessDrivers&apos; first.&quot;)
        End If
    End Sub

    Public Property Get HasErrors()
        HasErrors = UBound(ErrorCollection) &gt;= 0
    End Property

    Public Property Get DriverName()
        ThrowIfNotProcessed
        DriverName = m_selectedDriverName
    End Property 

    Public Property Get UseFqdn()
        ThrowIfNotProcessed
        UseFqdn = m_ncli_ForceProtocolEncryption And Not m_ncli_TrustServerCertificate
    End Property

    Public Property Get ClientTcpProtocolEnabled()
        ThrowIfNotProcessed
        ClientTcpProtocolEnabled = m_ncli_tcpProtocolEnabled
    End Property

    Public Property Get ClientSharedMemoryProtocolEnabled()
        ThrowIfNotProcessed
        ClientSharedMemoryProtocolEnabled = m_ncli_smProtocolEnabled
    End Property
End Class

Class ConnectionParams
    Public ComputerName
    Public DriverName
    Public Namespace
    Public IsForceProtocolEncryption
    Public IsTrustServerCertificate
    Public IsTcpProtocolEnabled
    Public IsSharedMemoryProtocolEnabled
    Public Protocols

    Public Default Function Init(sComputerName)
        ComputerName = sComputerName
        DriverName = DriverSelector_DEFAULT_DRIVER_NAME
        Namespace = &quot;&quot;
        IsForceProtocolEncryption = False
        IsTrustServerCertificate = False
        IsTcpProtocolEnabled = True
        IsSharedMemoryProtocolEnabled = True
        Set Init = Me
    End Function
End Class

Class UniqueCollection
    Private m_dict

    Public Default Function Init()
        Set m_dict = CreateObject(&quot;Scripting.Dictionary&quot;)
        Set Init = Me
    End Function

    Public Sub PutItem(item)
       If Not m_dict.Exists(item) Then
            m_dict.add item, &quot;&quot;
       End If
    End Sub
	
	Public Function Exists(item)
		Exists = m_dict.Exists(item)
	End Function
	
    Public Function GetItems()
        GetItems = m_dict.Keys()
    End Function

    Public Sub Clear()
        m_dict.RemoveAll()
    End Sub
End Class

Class SqlServerTcpIpSettings
    Private m_listenAllIPs
    Private m_ipSettings

    Public Default Function Init(listenAllIps, ipSettings)
        m_listenAllIPs = listenAllIps
        Set m_ipSettings = ipSettings
        Set Init = Me
    End Function

    Public Property Get ListenAllIPs()
        ListenAllIPs = m_listenAllIPs
    End Property

    Public Property Get IpSettings()
        Set IpSettings = m_ipSettings
    End Property
End Class

Function EscapeConnStringValue (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeConnStringValue  = &quot;{&quot; + Replace(strValue, &quot;}&quot;, &quot;}}&quot;) + &quot;}&quot;
End Function

Function EscapeWQLString (ByVal strValue)
	ON ERROR RESUME NEXT
	Err.Clear

	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function furlEncode(vString,vEncDec)
    Dim i
    Dim aReserved(24,1)
    &apos;column 1
    aReserved(0,0) = &quot;%&quot; &apos;25
    aReserved(1,0) = &quot;;&quot; &apos;3B
    aReserved(2,0) = &quot;/&quot; &apos;2F
    aReserved(3,0) = &quot;?&quot; &apos;3F
    aReserved(4,0) = &quot;:&quot; &apos;3A
    aReserved(5,0) = &quot;@&quot; &apos;40
    aReserved(6,0) = &quot;&amp;&quot; &apos;26
    aReserved(7,0) = &quot;=&quot; &apos;3D
    aReserved(8,0) = &quot;+&quot; &apos;2B
    aReserved(9,0) = &quot;$&quot; &apos;24
    aReserved(10,0) = &quot;,&quot; &apos;2C
    aReserved(11,0) = &quot; &quot; &apos;20
    aReserved(12,0) = &quot;&quot;&quot;&quot; &apos;22
    aReserved(13,0) = &quot;&lt;&quot; &apos;3C
    aReserved(14,0) = &quot;&gt;&quot; &apos;3E
    aReserved(15,0) = &quot;#&quot; &apos;23
    aReserved(16,0) = &quot;{&quot; &apos;7B
    aReserved(17,0) = &quot;}&quot; &apos;7D
    aReserved(18,0) = &quot;|&quot; &apos;7C
    aReserved(19,0) = &quot;\&quot; &apos;5C
    aReserved(20,0) = &quot;^&quot; &apos;5E
    aReserved(21,0) = &quot;~&quot; &apos;7E
    aReserved(22,0) = &quot;[&quot; &apos;5B
    aReserved(23,0) = &quot;]&quot; &apos;5D
    aReserved(24,0) = &quot;`&quot; &apos;60
    &apos;column 2
    aReserved(0,1) = &quot;%25&quot;
    aReserved(1,1) = &quot;%3B&quot;
    aReserved(2,1) = &quot;%2F&quot;
    aReserved(3,1) = &quot;%3F&quot;
    aReserved(4,1) = &quot;%3A&quot;
    aReserved(5,1) = &quot;%40&quot;
    aReserved(6,1) = &quot;%26&quot;
    aReserved(7,1) = &quot;%3D&quot;
    aReserved(8,1) = &quot;%2B&quot;
    aReserved(9,1) = &quot;%24&quot;
    aReserved(10,1) = &quot;%2C&quot;
    aReserved(11,1) = &quot;%20&quot;
    aReserved(12,1) = &quot;%22&quot;
    aReserved(13,1) = &quot;%3C&quot;
    aReserved(14,1) = &quot;%3E&quot;
    aReserved(15,1) = &quot;%23&quot;
    aReserved(16,1) = &quot;%7B&quot;
    aReserved(17,1) = &quot;%7D&quot;
    aReserved(18,1) = &quot;%7C&quot;
    aReserved(19,1) = &quot;%5C&quot;
    aReserved(20,1) = &quot;%5E&quot;
    aReserved(21,1) = &quot;%7E&quot;
    aReserved(22,1) = &quot;%5B&quot;
    aReserved(23,1) = &quot;%5D&quot;
    aReserved(24,1) = &quot;%60&quot;

    For i = 0 to Ubound(aReserved)
        If vEncDec = &quot;enc&quot; Then
        vString = Replace(vString,aReserved(i,0),aReserved(i,1))
        End If
        If vEncDec = &quot;dec&quot; Then
        vString = Replace(vString,aReserved(i,1),aReserved(i,0))
        End If
    Next

    furlEncode = vString
End Function

Class UtcDateOperations
    Private m_wbemDate

    Private Sub Class_Initialize()
        Set m_wbemDate = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
    End Sub

    Public Function DateToIso8601UtcString(objDate)
        DateToIso8601UtcString = _
            DatePart(&quot;yyyy&quot;, objDate) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;m&quot;, objDate), 2) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;d&quot;, objDate), 2) &amp;_
            &quot;T&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;h&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;n&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;s&quot;, objDate), 2) &amp;_
            &quot;Z&quot;
    End Function

    Public Function Iso8601UtcStringToDate(sDate)
        Dim oRegex: Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{4})-(\d\d)-(\d\d)(?:T|\s)(\d\d):(\d\d):(\d\d)Z$&quot; 
        
        Dim matches: Set matches = oRegex.Execute(sDate)
        If matches.Count = 0 Then
            Err.Raise 4000, &quot;&quot;, &quot;Input date string is in invalid format&quot;
        End If
        
        Dim year: year = CInt(matches(0).SubMatches(0))
        Dim month: month = CInt(matches(0).SubMatches(1))
        Dim day: day = CInt(matches(0).SubMatches(2))

        Dim hour: hour = CInt(matches(0).SubMatches(3))
        Dim minute: minute = CInt(matches(0).SubMatches(4))
        Dim second: second = CInt(matches(0).SubMatches(5))

        Dim resDate: resDate = DateSerial(year, month, day)
        resDate = DateAdd(&quot;h&quot;, hour, resDate)
        resDate = DateAdd(&quot;n&quot;, minute, resDate)
        resDate = DateAdd(&quot;s&quot;, second, resDate)

        Iso8601UtcStringToDate = resDate
    End Function

    Public Function GetUtcNow()
        m_wbemDate.SetVarDate(Now())
        GetUtcNow = CDate(m_wbemDate.GetVarDate(false))
    End function

    Public Function CheckSecondsElapsed(sDate, nSeconds)
        Dim utcNow: utcNow = Me.GetUtcNow
        Dim utcDate: utcDate = Iso8601UtcStringToDate(sDate)
        CheckSecondsElapsed = DateDiff(&quot;s&quot;,utcDate,utcNow) &gt; nSeconds
    End function
End Class

Function GetCacheKey(stateMpPrefix, sKeyName)
    Dim oApi: Set oApi = CreateObject(&quot;MOM.ScriptAPI&quot;)
    Dim regKey: regKey = oAPI.GetScriptStateKeyPath(ManagementGroupID)
    regKey = regKey &amp; &quot;\&quot; &amp; stateMpPrefix &amp; &quot;\&quot; &amp; sKeyName
    GetCacheKey = regKey
End Function

Function GetStringValueFromCache(sKeyName, sValueName, cacheExpirationTime)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)
        
    Dim lErrCode
    Dim sDate: sDate = oReg.ReadStringValue(regKey, sDateValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    Dim sValue: sValue = oReg.ReadStringValue(regKey, sValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    If udo.CheckSecondsElapsed(sDate, cacheExpirationTime) Then
        Exit Function
    End If

    GetStringValueFromCache = sValue
End Function

Function PutStringValueToCache(sKeyName, sValueName, sValue)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    Dim dUtcNow: dUtcNow = udo.GetUtcNow()

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)

    Call oReg.CreateKey(regKey)

    Dim lErrCode
    
    Call oReg.WriteStringValue(regKey, sValueName, sValue)
    Call oReg.WriteStringValue(regKey, sDateValueName, udo.DateToIso8601UtcString(dUtcNow))
End Function

Function GetWMISingleValue(wmiProvider, query, propertyName)
    Dim oQuery: Set oQuery = wmiProvider.ExecQuery(query)
    If oQuery.Count = 0 Then
        Err.Raise 4000, &quot;&quot;, &quot;Query &apos;&quot; &amp; query &amp; &quot;&apos; didn&apos;t return any objects&quot;
    End If
    Dim colSettings: Set colSettings = GetFirstItemFromWMIQuery(oQuery)
    GetWMISingleValue = colSettings.Properties_.Item(propertyName).Value
End Function

Class HostNameData
    Public HostName
    Public IsClustered

    Public Default Function Init(sHostName, bIsClustered)
        Me.HostName = sHostName
        Me.IsClustered = bIsClustered
        Set Init = Me
    End function
End Class

Function GetSqlServerHostName(strDNSComputerName, instanceName, namespace)
    Set GetSqlServerHostName = Nothing
    Dim serviceName: serviceName = GetSQLServiceName(instanceName)
    Dim escapedServiceName: escapedServiceName = EscapeWQLString(serviceName)
    
    Dim wmiProvider: Set wmiProvider = ConnectToWMI(strDNSComputerName, &quot;ROOT\Microsoft\SqlServer\&quot; + namespace)

    Dim isClustered: isClustered = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyNumValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;CLUSTERED&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyNumValue&quot;)

    Dim hostName
    If isClustered = 0 Then
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT HostName FROM SqlService WHERE SQLServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;HostName&quot;)
    Else
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyStrValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;VSNAME&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyStrValue&quot;)
    End If

    Set GetSqlServerHostName = (New HostNameData)(hostName, CBool(isClustered))
End Function

Function EscapeCacheValueName(name)
    EscapeCacheValueName = Replace(name, &quot;_&quot;, &quot;__&quot;)
End Function

Function GetSqlServerHostNameEx(strDNSComputerName, instanceName, namespace)
    Wscript.Echo strDNSComputerName
	Wscript.Echo instanceName
    Wscript.Echo namespace
    Set GetSqlServerHostNameEx = Nothing
    Dim cacheExpirationTime: cacheExpirationTime = 7200
    Dim hostValueName: hostValueName = EscapeCacheValueName(strDNSComputerName)
    Dim isClusteredValueName: isClusteredValueName = hostValueName &amp; &quot;_IsClustered&quot;
    Dim isClusteredStr

    On Error Resume Next
    Call Err.Clear()
    Dim hostName: hostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    If Err.Number = 0 And Not IsEmpty(hostName) Then
        isClusteredStr = GetStringValueFromCache(&quot;SqlHostNames&quot;, isClusteredValueName, cacheExpirationTime)
        If Err.Number = 0 And Not IsEmpty(isClusteredStr) Then
            If isClusteredStr = &quot;0&quot; Or isClusteredStr = &quot;1&quot; Then
                Set GetSqlServerHostNameEx = (New HostNameData)(hostName, CBool(isClusteredStr))
                Exit Function
            End If
        End If
    End If
    Call Err.Clear()

    On Error GoTo 0
    Dim hostNameData: Set hostNameData = GetSqlServerHostName(strDNSComputerName, instanceName, namespace)

    If hostNameData.IsClustered Then 
        isClusteredStr = &quot;1&quot;
    Else 
        isClusteredStr = &quot;0&quot;
    End If

    On Error Resume Next
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, hostValueName, hostNameData.HostName)
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, isClusteredValueName, isClusteredStr)
    
    Call Err.Clear()

    Set GetSqlServerHostNameEx = hostNameData
End function

Function GetLocalHostName()
    Dim wshShell: Set wshShell = CreateObject( &quot;WScript.Shell&quot; )
    GetLocalHostName = wshShell.ExpandEnvironmentStrings(&quot;%COMPUTERNAME%&quot;)
End Function

Function DelimitSqlIdentifier(identifier)
    DelimitSqlIdentifier = &quot;[&quot; + Replace(identifier, &quot;]&quot;, &quot;]]&quot;) + &quot;]&quot;
End Function

Function SqlTcpPortIsEmpty(tcpPort)
    SqlTcpPortIsEmpty = (IsEmpty(tcpPort) Or tcpPort = &quot;&quot; Or tcpPort = &quot;0&quot;)
End Function

Function GetDataSource(server, tcpPort)
    Dim dataSource : dataSource = server
    If Not SqlTcpPortIsEmpty(tcpPort) Then
        Dim nameParts : nameParts = Split(dataSource, &quot;\&quot;)
        dataSource = nameParts(0) &amp; &quot;,&quot; &amp; tcpPort
    End If
    GetDataSource = dataSource
End Function

Function BuildDataSourceFromParts(computerName, instanceName, tcpPort)
    Dim dataSource : dataSource = computerName
    If instanceName &lt;&gt; &quot;MSSQLSERVER&quot; Then
        dataSource = computerName &amp; &quot;\&quot; &amp; instanceName
    End If
    BuildDataSourceFromParts = GetDataSource(dataSource, tcpPort)
End Function

Function GetConnectionString(driverName, dataSource, databaseName, intent)
    GetConnectionString = &quot;Driver=&quot; &amp; EscapeConnStringValue(driverName) &amp; &quot;;Server=&quot; &amp; EscapeConnStringValue(dataSource) &amp; &quot;;Database=&quot; &amp; EscapeConnStringValue(databaseName) &amp; &quot;;Trusted_Connection=yes;ApplicationIntent=&quot; &amp; intent
End Function

Function GetEnabledSqlServerProtocols(namespaceName, computerName, instanceName)
    Dim oWMI: Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot; &amp; namespaceName)  
    Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, Enabled FROM ServerNetworkProtocol WHERE InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos;&quot;)
    If oQuery.Count &gt; 0 Then
        Dim protocolsArr: Set protocolsArr = New ArrayList
        Dim protocolItem
        For Each protocolItem In oQuery
            If protocolItem.Enabled Then
                protocolsArr.Add LCase(protocolItem.ProtocolName)
            End If
        Next
        GetEnabledSqlServerProtocols = protocolsArr.ItemsArray
    Else
        GetEnabledSqlServerProtocols = Array()
    End If
End Function

Function GetSqlServerTcpIpSettings(instanceName, computerName)
    ON ERROR RESUME NEXT
    Dim oWMI, oQuery, tcpItem
    Dim i, j
    Dim uc: Set uc = (new UniqueCollection)()
    Dim isListenAll: isListenAll = False
    Dim ipSettings: Set ipSettings = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot;&amp; SQL_WMI_NAMESPACE)  

    Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND PropertyName = &apos;ListenOnAllIPs&apos;&quot;)

    If oQuery.Count &gt;0 Then
        Dim isListenAllObj: Set isListenAllObj = GetFirstItemFromWMIQuery(oQuery)
        If isListenAllObj.PropertyNumVal = 1 Then
            isListenAll  = True
        End If
    End If

    Dim tcpPorts, tcpPort, processedPort
        
    If isListenAll Then
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;IPAll&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
        If oQuery.Count &gt; 0 Then
            For Each tcpItem In oQuery
                tcpPorts = Split(tcpItem.PropertyStrVal,&quot;,&quot;)
                For Each tcpPort In tcpPorts
            	    processedPort = Trim(tcpPort)
            	    If Not SqlTcpPortIsEmpty(processedPort) Then
                	    uc.PutItem(processedPort)
                    End If
                Next
            Next
            ipSettings.add &quot;IPAll&quot;, uc.GetItems()
        End If
    Else
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName &lt;&gt; &apos;&apos; AND PropertyName = &apos;Enabled&apos; AND PropertyNumVal = 1&quot;) 
        Dim ipItem
        If oQuery.Count &gt; 0 Then
            For Each ipItem In oQuery
                Dim ipAddressName : ipAddressName = ipItem.IPAddressName
                Dim oQuery2 : Set oQuery2 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot; &amp; EscapeWQLString(instanceName) &amp; &quot;&apos; AND IPAddressName = &apos;&quot; &amp; EscapeWQLString(ipAddressName) &amp; &quot;&apos; AND PropertyName = &apos;IpAddress&apos; AND PropertyStrVal != &apos;&apos;&quot;)
                If oQuery2.Count &gt; 0 Then
                    Dim ipAddress : ipAddress = GetFirstItemFromWMIQuery(oQuery2).PropertyStrVal
                    Dim oQuery3: Set oQuery3 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;&quot;&amp; EscapeWQLString(ipAddressName) &amp;&quot;&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
                    If oQuery3.Count &gt; 0 Then 
                        uc.Clear()
                        Dim portItem
                        For Each portItem In oQuery3
                            tcpPorts = Split(portItem.PropertyStrVal,&quot;,&quot;)
                            For Each tcpPort In tcpPorts
                            	processedPort = Trim(tcpPort)
                                If Not SqlTcpPortIsEmpty(processedPort) Then
				                	uc.PutItem(processedPort)
				                End If
                            Next
                            ipSettings.add ipAddress, uc.GetItems()
                        Next
                    End If
                End If
            Next
        End If
    End If
    Set GetSqlServerTcpIpSettings = (new SqlServerTcpIpSettings)(isListenAll, ipSettings)
End Function

Function GetTcpPortsString(ByVal inputDataSource)
    On Error Resume Next
	Dim computerName, instanceName, pathArray
	
	pathArray = Split(inputDataSource, &quot;\&quot;)
    computerName = pathArray(0)
    instanceName = &quot;MSSQLSERVER&quot;
	If (UBound(pathArray) &gt; 0) Then
	    instanceName = pathArray(1)
	End If

    Dim tcpIpSettings: Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, computerName)
    Dim upc : Set upc = (new UniqueCollection)()
    Dim ip, port
    For Each ip In tcpIpSettings.IpSettings.Keys 
        For Each port In tcpIpSettings.IpSettings.Item(ip)
            upc.PutItem port
        Next
    Next
    GetTcpPortsString = Join(upc.GetItems(),&quot;, &quot;)
End Function

Public Sub SqlTestDestination(dbConnection, hostName, instanceName, isADODB)
    Dim queryServerName, queryInstanceName
    Dim destinationTestQuery: destinationTestQuery = &quot;select CAST(SERVERPROPERTY(&apos;MachineName&apos;) AS nvarchar(128)) as ServerName, @@servicename as InstanceName&quot;
    On Error Goto 0
    If 0 = Err.number Then
        Dim queryResult
        If isADODB Then
            Set queryResult = dbConnection.ExecuteQueryTE(destinationTestQuery)
        Else
            Set queryResult = dbConnection.Execute(destinationTestQuery)
        End If
        If Not queryResult.EOF Then
            queryServerName = UCase(queryResult(&quot;ServerName&quot;).Value)
            queryInstanceName = UCase(queryResult(&quot;InstanceName&quot;).Value)
            If (UCase(hostName) = queryServerName) And (UCase(instanceName) = queryInstanceName) Then
                Exit Sub
            End If
        End If
        dbConnection.Close() 
        Err.Raise 16389, &quot;&quot;, &quot;Connection target check failed: connected to &quot; &amp; hostName &amp; &quot;\&quot; &amp; instanceName &amp; &quot;, but got &quot; &amp; queryServerName &amp; &quot;\&quot; &amp; queryInstanceName &amp; &quot;.&quot;
    End If
End Sub

Sub TryToConnectAndValidate(connectionObj, connectionString, timeout, hostName, instanceName, isADODB)
    On Error GoTo 0
    
    If isADODB Then
        connectionObj.Open connectionString, &quot;&quot;, timeout
    Else
        if (connectionObj.Mode &lt;&gt; 0) then
          connectionObj.Close()
        end if
        connectionObj.ConnectionTimeout = timeout
        connectionObj.Open connectionString
    End If
    SqlTestDestination connectionObj, hostName, instanceName, isADODB
End Sub

Function FormatConnectionErrorMessage(dataSource, lastError)
    FormatConnectionErrorMessage = &quot;Connection to data source &apos;&quot; &amp; dataSource &amp; &quot;&apos; failed: &quot; &amp; lastError.Description
End Function

Function SmartConnectWithoutSQLADODB(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName)    
    Set SmartConnectWithoutSQLADODB = SmartConnectWithoutSQLADODBIntent(inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectWithoutSQLADODBIntent(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName, ByVal intent)
    On Error Resume Next
    Set SmartConnectWithoutSQLADODBIntent = Nothing
    Dim dbMasterConnection, dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList
    
    Set dbMasterConnection = CreateObject(&quot;ADODB.Connection&quot;)

    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName 
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    
    If connectionString  &lt;&gt; &quot;&quot; And timeout  &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate dbMasterConnection, connectionString, timeout, netBiosHostName, instanceName, False
        lastError.Save
        If lastError.Number = 0 Then
            Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If

    Dim ds: Set ds = New DriverSelector

	

	
    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Set SmartConnectWithoutSQLADODBIntent = Nothing
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)   

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, machineName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

	
    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate dbMasterConnection, connectionString, 15, netBiosHostName, instanceName, False
    lastError.Save
    If lastError.Number = 0 Then
        Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If

    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
                lastError.Save
                If lastError.Number = 0 Then
                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
                End If
            Next
        Else
    	    &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
	                lastError.Save
	                If lastError.Number = 0 Then
	                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
		                lastError.Save
		                If lastError.Number = 0 Then
		                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Function SmartConnect(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName)    
     SmartConnect = SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, intent)
    On Error Resume Next
    SmartConnectIntent = False
    Dim dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList 
    

    
    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName  
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)

    If connectionString &lt;&gt; &quot;&quot; And timeout &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate cnADOConnection, connectionString, timeout, netBiosHostName, instanceName, True
        lastError.Save
        If lastError.Number = 0 Then
            SmartConnectIntent = True
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If


    Dim ds: Set ds = New DriverSelector

    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, netBiosHostName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate cnADOConnection, connectionString, 15, netBiosHostName, instanceName, True
    lastError.Save
    If lastError.Number = 0 Then
        SmartConnectIntent = True
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If
	
    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
                lastError.Save
                If lastError.Number = 0 Then
                    SmartConnectIntent = True
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
                End If
            Next
        Else
            &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
	                lastError.Save
	                If lastError.Number = 0 Then
	                    SmartConnectIntent = True
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
		                lastError.Save
		                If lastError.Number = 0 Then
		                    SmartConnectIntent = True
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Function ExtractHostNameFromEndpoint(ByVal sEndpoint)
    If sEndpoint = &quot;&quot; Then
        ExtractHostNameFromEndpoint = &quot;&quot;
        Exit Function
    End If
    Dim oRegEx, oMatches
    Set oRegEx = MomCreateObject(&quot;VBScript.RegExp&quot;)
    oRegEx.Pattern = &quot;://(.+):&quot;
    Set oMatches = oRegEx.Execute(sEndpoint)
    If oMatches.Count &gt; 0 Then
        If oMatches(0).SubMatches.Count &gt; 0 Then
            ExtractHostNameFromEndpoint = oMatches(0).SubMatches(0)
        Else
            ExtractHostNameFromEndpoint = sEndpoint
        End If
    Else
        ExtractHostNameFromEndpoint = sEndpoint
    End If
End Function

Function GetMirroringLevelName(ByVal nSafetyLevel, ByVal sWitnessName)
    GetMirroringLevelName = &quot;Unknown state&quot;
    If nSafetyLevel = 1 Then
        GetMirroringLevelName = &quot;High-performance mode&quot;
    Else
        If sWitnessName = &quot;&quot; Then
            GetMirroringLevelName = &quot;High-safety mode without automatic failover&quot;
        Else
            GetMirroringLevelName = &quot;High-safety mode with automatic failover&quot;
        End If
    End If
End Function

Function IsExcluded(ByVal sDatabase, ByVal sExcludeList)
	Dim aExcludes, bMatch, nIndex

	bMatch = False
	If Trim(sExcludeList) = &quot;*&quot; Then
	    bMatch = True
	Else
		aExcludes = Split(sExcludeList, &quot;,&quot;)
		For nIndex = 0 To UBound(aExcludes)
			If LCase(sDatabase) = LCase(Trim(aExcludes(nIndex))) Then
				bMatch = True
			End If
		Next
	End If
	IsExcluded = bMatch
End Function

Function DoDatabaseDiscovery()
    If Len(ExcludeList) &lt; 0 Then 
        WriteToEventLogAndExit(&quot;Database exclusion list invalid in Mirrored DB Discovery. Aborting discovery.&quot;)
    End If

	Dim e
	Set e = New Error

    Dim cnADOConnection
    Set cnADOConnection = SmartConnectWithoutSQLADODB(ConnectionString, sTcpPort, TargetComputer, InstanceName, &quot;master&quot;)
    if cnADOConnection Is Nothing Then
		DoDatabaseDiscovery = SQL_DISCOVERY_CONNECT_FAILURE
        Exit Function
    End If
	    
    &apos; Query for the list of mirrored databases
    Dim oResults
	e.Clear
	On Error Resume Next
		Set oResults = cnADOConnection.Execute(GetMirroredDatabasesQuery)
		e.Save
	On Error Goto 0
	If e.Number &lt;&gt; 0 Then
        DoDatabaseDiscovery = SQL_DISCOVERY_QUERY_FAILURE
        ThrowScriptErrorNoAbort &quot;Query execution failed&quot;, e
        Exit Function
	End If

    Dim oDBInstance, oMirroringGroup, oRelationship
    Dim sDBName, sMirroringGUID, sPartnerInstance, sRole, nState, sWitnessState, nSafetyLevel, sWitnessName
	Do While Not oResults.EOF
		sDBName = oResults(0)

		If Not(IsExcluded(sDBName, ExcludeList)) Then 
            e.Clear
            sMirroringGUID = oResults(1)
            sPartnerInstance = oResults(2)
            sRole = oResults(3)
            nState = oResults(4)
            sWitnessState = oResults(5)
            nSafetyLevel = oResults(6)
            sWitnessName = oResults(7)

			Set oDBInstance = oDiscoveryData.CreateClassInstance(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Database&apos;]$&quot;)
			With oDBInstance
				.AddProperty &quot;$MPElement[Name=&apos;MSCL!Microsoft.SQLServer.Core.DBEngine&apos;]/MachineName$&quot;, TargetComputer
				.AddProperty &quot;$MPElement[Name=&apos;MSCL!Microsoft.SQLServer.Core.DBEngine&apos;]/InstanceName$&quot;, InstanceName
				.AddProperty &quot;$MPElement[Name=&apos;MSCL!Microsoft.SQLServer.Core.Database&apos;]/DatabaseName$&quot;, sDBName
            End With

            Set oMirroringGroup = oDiscoveryData.CreateClassInstance(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]$&quot;)
            With oMirroringGroup
                .AddProperty &quot;$MPElement[Name=&apos;System!System.Entity&apos;]/DisplayName$&quot;, &quot;&apos;&quot; &amp; sDBName &amp; &quot;&apos; database mirror&quot;

                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/MirroringGUID$&quot;, sMirroringGUID
            End With

            Set oRelationship = oDiscoveryData.CreateRelationshipInstance(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.GroupContainsDatabase&apos;]$&quot;)
            oRelationship.Source = oMirroringGroup
            oRelationship.Target = oDBInstance

            With oDBInstance
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Database&apos;]/MirroringGUID$&quot;, sMirroringGUID
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Database&apos;]/MirroringRole$&quot;, sRole
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Database&apos;]/Level$&quot;, GetMirroringLevelName(nSafetyLevel, sWitnessName)
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Database&apos;]/Partner$&quot;, sPartnerInstance
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Database&apos;]/Witness$&quot;, ExtractHostNameFromEndpoint(sWitnessName)
            End With

            If sRole = &quot;PRINCIPAL&quot; Then
                With oMirroringGroup
                    .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/PrincipalComputerName$&quot;, TargetComputer
                    .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/PrincipalInstanceName$&quot;, InstanceName
                End With
            Else
                With oMirroringGroup
                    .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/MirrorComputerName$&quot;, TargetComputer
                    .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/MirrorInstanceName$&quot;, InstanceName
                End With
            End If
            Call oMirroringGroup.AddProperty(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/Level$&quot;, GetMirroringLevelName(nSafetyLevel, sWitnessName))
            Call oMirroringGroup.AddProperty(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/DatabaseName$&quot;, sDBName)

            Call oDiscoveryData.AddInstance(oDBInstance)
            Call oDiscoveryData.AddInstance(oMirroringGroup)
            Call oDiscoveryData.AddInstance(oRelationship)
	    End If
		oResults.MoveNext
	Loop

	Set oResults = Nothing
	cnADOConnection.Close
	DoDatabaseDiscovery = SQL_DISCOVERY_SUCCESS
End Function
&apos; End of Script
</ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </DataSource>
            </MemberModules>
            <Composition>
              <Node ID="DS" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.Discovery.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.SQLServer.Windows.Mirroring.PrincipalToMirrorReference.DiscoveryProvider.DS" Accessibility="Public" Batching="false">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="PrincipalComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="PrincipalInstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MirrorComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MirrorInstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="DatabaseName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Discovery.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
                    <SyncTime>$Config/SyncTime$</SyncTime>
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ConditionDetection ID="Filter" TypeID="System!System.ExpressionFilter">
                <Expression>
                  <And>
                    <Expression>
                      <Or>
                        <Expression>
                          <SimpleExpression>
                            <ValueExpression>
                              <Value Type="String">$Config/PrincipalComputerName$</Value>
                            </ValueExpression>
                            <Operator>NotEqual</Operator>
                            <ValueExpression>
                              <Value Type="String">$Config/MirrorComputerName$</Value>
                            </ValueExpression>
                          </SimpleExpression>
                        </Expression>
                        <Expression>
                          <SimpleExpression>
                            <ValueExpression>
                              <Value Type="String">$Config/PrincipalInstanceName$</Value>
                            </ValueExpression>
                            <Operator>NotEqual</Operator>
                            <ValueExpression>
                              <Value Type="String">$Config/MirrorInstanceName$</Value>
                            </ValueExpression>
                          </SimpleExpression>
                        </Expression>
                      </Or>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <Value Type="String">$Config/PrincipalInstanceName$</Value>
                        </ValueExpression>
                        <Operator>NotEqual</Operator>
                        <ValueExpression>
                          <Value Type="String" />
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                    <Expression>
                      <SimpleExpression>
                        <ValueExpression>
                          <Value Type="String">$Config/MirrorInstanceName$</Value>
                        </ValueExpression>
                        <Operator>NotEqual</Operator>
                        <ValueExpression>
                          <Value Type="String" />
                        </ValueExpression>
                      </SimpleExpression>
                    </Expression>
                  </And>
                </Expression>
              </ConditionDetection>
              <ConditionDetection ID="Mapper" TypeID="System!System.Discovery.RelationshipSnapshotDataMapper">
                <RelationshipId>$MPElement[Name='Microsoft.SQLServer.Windows.Mirroring.PrincipalReferencesMirror']$</RelationshipId>
                <SourceRoleSettings>
                  <Settings>
                    <Setting>
                      <Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name>
                      <Value>$Config/PrincipalComputerName$</Value>
                    </Setting>
                    <Setting>
                      <Name>$MPElement[Name='MSCL!Microsoft.SQLServer.Core.DBEngine']/InstanceName$</Name>
                      <Value>$Config/PrincipalInstanceName$</Value>
                    </Setting>
                    <Setting>
                      <Name>$MPElement[Name='MSCL!Microsoft.SQLServer.Core.Database']/DatabaseName$</Name>
                      <Value>$Config/DatabaseName$</Value>
                    </Setting>
                  </Settings>
                </SourceRoleSettings>
                <TargetRoleSettings>
                  <Settings>
                    <Setting>
                      <Name>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Name>
                      <Value>$Config/MirrorComputerName$</Value>
                    </Setting>
                    <Setting>
                      <Name>$MPElement[Name='MSCL!Microsoft.SQLServer.Core.DBEngine']/InstanceName$</Name>
                      <Value>$Config/MirrorInstanceName$</Value>
                    </Setting>
                    <Setting>
                      <Name>$MPElement[Name='MSCL!Microsoft.SQLServer.Core.Database']/DatabaseName$</Name>
                      <Value>$Config/DatabaseName$</Value>
                    </Setting>
                  </Settings>
                </TargetRoleSettings>
              </ConditionDetection>
            </MemberModules>
            <Composition>
              <Node ID="Mapper">
                <Node ID="Filter">
                  <Node ID="Scheduler" />
                </Node>
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.Discovery.Data</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Microsoft.SQLServer.Windows.Mirroring.Witness.DiscoveryProvider.DS" Accessibility="Internal" RunAs="MSCL!Microsoft.SQLServer.Core.RunAs.Discovery" Batching="false">
        <Configuration>
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MachineName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ConnectionString" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Version" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="ExcludeList" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TcpPorts" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="TimeoutSeconds" type="xsd:int" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="ExcludeList" Selector="$Config/ExcludeList$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.TimedScript.DiscoveryProvider">
                <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
                <SyncTime>$Config/SyncTime$</SyncTime>
                <ScriptName>Microsoft.SQLServer.Windows.Mirroring.Witness.DiscoveryProvider.DS.vbs</ScriptName>
                <Arguments>$MPElement$ $Target/Id$ $Config/MachineName$ $Config/ConnectionString$ $Config/InstanceName$ $Config/Version$ "Exclude:$Config/ExcludeList$" "$Config/TcpPorts$"</Arguments>
                <ScriptBody>&apos;Script Begin
Option Explicit
SetLocale(&quot;en-us&quot;)

&apos;Set Constants
Const ManagementGroupName = &quot;$Target/ManagementGroup/Name$&quot;
Const SQL_DEFAULT = &quot;MSSQLSERVER&quot;
Const DEBUG_MODE = False
Const EVENT_TYPE_ERROR = 1
Const MANAGEMENT_PACK_VERSION = &quot;7.0.20.0&quot;
Const SQL_DISCOVERY_CONNECT_FAILURE = -1
Const SQL_DISCOVERY_QUERY_FAILURE = -2
Const SQL_DISCOVERY_SUCCESS = 0
Const DISCOVERY_ERROR_EVENT_ID = 7105
Const SCRIPT_EVENT_ID = 4211
Const MAX_DRIVER_VERSION_STR = &quot;99999999.99999999.99999999.99999999&quot;
Const DriverSelector_DEFAULT_DRIVER_NAME = &quot;SQL Server&quot;

Dim GlobalErrorList: Set GlobalErrorList = New ArrayList

Dim StartTime,EndTime,sTime
&apos;Capture script start time
StartTime = Now

Dim oAPI
Set oAPI = MOMCreateObject(&quot;MOM.ScriptAPI&quot;)

&apos;Log script event that we are starting discovery
Call oAPI.LogScriptEvent(&quot;Microsoft.SQLServer.Windows.Mirroring.Witness.DiscoveryProvider.DS.vbs&quot;, 4003, 0, &quot;Starting script&quot;)

Dim GetMirroredDatabasesQuery
GetMirroredDatabasesQuery = &quot;SELECT &quot; &amp;_
                                &quot; database_name, &quot; &amp;_
                                &quot; mirroring_guid, &quot; &amp;_
                                &quot; principal_server_name, &quot; &amp;_
                                &quot; mirror_server_name, &quot; &amp;_
                                &quot; partner_sync_state, &quot; &amp;_
                                &quot; safety_level &quot; &amp;_
                            &quot; FROM sys.database_mirroring_witnesses&quot;

&apos; #Include File:DiscoverSQLWindowsMirroringWitness.vbs
&apos; Copyright (c) Microsoft Corporation. All rights reserved.
&apos; Parameters that should be passed to this script
&apos; 0 MPElement ID ($MPElement$)
&apos; 1 Target Id for ME this rule is running against ($Target/Id$)
&apos; 2 Computer Name
&apos; 3 SQL Connection String for the targeted DB Engine
&apos; 4 SQL Instance for the targeted DB Engine 
&apos; 5 SQL Version for the targeted DB Engine
&apos; 6 Excluded database list (prefixed with Exclude:)
&apos; 7 TCP Ports optional

Dim oArgs
Set oArgs = WScript.Arguments
If oArgs.Count &lt; 7 Or oArgs.Count &gt; 8 Then
   Wscript.Quit -1
End If

Dim SourceID, ManagedEntityId, InstanceName, ConnectionString, SQLVersion, TargetComputer, ExcludeList, sTcpPort

SourceId = oArgs(0)
ManagedEntityId = oArgs(1)
TargetComputer = oArgs(2)
ConnectionString = oArgs(3)
InstanceName = oArgs(4)
SQLVersion = oArgs(5)
ExcludeList = Mid(oArgs(6), 9)
sTcpPort = &quot;&quot;
If oArgs.Count = 8 Then
    sTcpPort = oArgs(7)
End If

Dim SQLVersionArr, SQLMajorVersion, SQL_WMI_NAMESPACE
SQLVersionArr = split(SQLVersion,&quot;.&quot;)
SQLMajorVersion = SQLVersionArr(0)
SQL_WMI_NAMESPACE = &quot;ComputerManagement&quot; &amp; SQLMajorVersion

Dim oDiscoveryData
Set oDiscoveryData = oAPI.CreateDiscoveryData(0, SourceId, ManagedEntityId)

Dim errorCode: errorCode = 0

Dim state, serviceName
serviceName = GetSQLServiceName(InstanceName)
state = GetServiceState(TargetComputer, serviceName)
If (state &lt;&gt; &quot;Running&quot;) And (state &lt;&gt; &quot;Unknown&quot;) Then
    oDiscoveryData.IsSnapshot = False
Else
    If DoWitnessDiscovery() &lt; 0 Then 
        errorCode = -1
        oAPI.LogScriptEvent &quot;Management Group: &quot; &amp; ManagementGroupName &amp; &quot;. Script: &quot; &amp; WScript.ScriptName &amp; &quot;. Version: &quot; &amp; MANAGEMENT_PACK_VERSION &amp; &quot;. Instance: &quot; &amp; InstanceName, DISCOVERY_ERROR_EVENT_ID, EVENT_TYPE_ERROR, &quot;Mirroring witness discovery script &apos;&quot; &amp; WScript.ScriptName &amp; &quot;&apos; for instance &apos;&quot; &amp; InstanceName &amp; &quot;&apos; failed.&quot; &amp; vbNewLine &amp; GetGlobalErrorListEventString()
        Call GlobalErrorList.Clear()
    End If
End If

&apos;Capture script runtime for logging
EndTime = Now
sTime = DateDiff(&quot;s&quot;, StartTime, EndTime)
&apos;Log script event that we are ending discovery
Call oAPI.LogScriptEvent(&quot;Microsoft.SQLServer.Windows.Mirroring.Witness.DiscoveryProvider.DS.vbs&quot;, 4003, 0, &quot;Ending script.  Script runtime in seconds: &quot; &amp; sTime)

Call oAPI.Return(oDiscoveryData)

Call GlobalErrorListToEventLog()
WScript.Quit(errorCode)


Function MomCreateObject(ByVal sProgramId)
    Dim oError
    Set oError = New Error
    
	On Error Resume Next
	Set MomCreateObject = CreateObject(sProgramId)
	oError.Save
	On Error Goto 0
	
	If oError.Number &lt;&gt; 0 Then ThrowScriptError &quot;Unable to create automation object &apos;&quot; &amp; sProgramId &amp; &quot;&apos;&quot;, oError
End Function

Public Function GetSQLServiceName(sInstance)
    If sInstance = SQL_DEFAULT Then
        GetSQLServiceName = SQL_DEFAULT
    Else
        GetSQLServiceName = &quot;MSSQL$&quot; &amp; sInstance
    End If
End Function

Function GetServiceState( sTargetComputer, sServiceName)
    On Error Resume Next    

    Dim sNamespace, sQuery, oWMI, objClasses, sState
    sNamespace = &quot;winmgmts://&quot; &amp; sTargetComputer &amp; &quot;/root/cimv2&quot;
    sQuery = &quot;SELECT State FROM Win32_Service where  Name = &quot;&quot;&quot; &amp; EscapeWQLString(sServiceName) &amp; &quot;&quot;&quot;&quot;
    
    Set oWMI = GetObject(sNamespace)
    Set objClasses = oWMI.ExecQuery(sQuery)

    if objClasses.Count &gt;= 1 Then
        sState = GetFirstItemFromWMIQuery(objClasses).Properties_.Item(&quot;State&quot;)
    End If
    
    If Err.number &lt;&gt; 0 Or objClasses.Count = 0 Then
        sState = &quot;Unknown&quot;
    End If 

    Err.Clear
    GetServiceState = sState
End Function

Class Error
    Private m_lNumber
    Private m_sSource
    Private m_sDescription
    Private m_sHelpContext
    Private m_sHelpFile

    Public Sub Save()
        m_lNumber = Err.Number
        m_sSource = Err.Source
        m_sDescription = Err.Description
        m_sHelpContext = Err.HelpContext
        m_sHelpFile = Err.HelpFile
    End Sub

    Public Sub Raise()
        Err.Raise m_lNumber, m_sSource, m_sDescription, m_sHelpFile, m_sHelpContext
    End Sub

    Public Sub Clear()
        m_lNumber = 0
        m_sSource = &quot;&quot;
        m_sDescription = &quot;&quot;
        m_sHelpContext = &quot;&quot;
        m_sHelpFile = &quot;&quot;
    End Sub

    Public Default Property Get Number()
        Number = m_lNumber
    End Property
    Public Property Get Source()
        Source = m_sSource
    End Property
    Public Property Get Description()
        Description = m_sDescription
    End Property
    Public Property Get HelpContext()
        HelpContext = m_sHelpContext
    End Property
    Public Property Get HelpFile()
        HelpFile = m_sHelpFile
    End Property    
End Class

Class ArrayList
    Private m_itemArray

    Private Sub Class_Initialize()
        Me.Clear
    End Sub

    Private Sub AddItemToArray(ByRef itemArray, ByVal item)
        ReDim Preserve itemArray(UBound(itemArray) + 1) 
        itemArray(UBound(itemArray)) = item
    End Sub

    Public Sub Clear()
        m_itemArray = Array()
    End Sub

    Public Sub Add(item)
        AddItemToArray m_itemArray, item
    End Sub

    Public Sub RemoveAt(index)
        If index &lt; 0 Or index &gt; UBound(m_itemArray) Then
            Exit Sub
        End If
        Dim newArr: newArr = Array()
        Dim i
        For i = 0 To UBound(m_itemArray)
            If i &lt;&gt; index Then
                Call AddItemToArray(newArr, m_itemArray(i))
            End If
        Next
        m_itemArray = newArr
    End Sub

    Public Property Get Count()
        Count = UBound(m_itemArray) + 1
    End Property

    Public Property Get ItemsArray()
        ItemsArray = m_itemArray
    End Property

    Public Property Get IsEmpty()
        IsEmpty = UBound(m_itemArray) &lt; 0
    End Property
End Class

Class ScriptLogger
    Dim sourceLogEvent
    
    Private Sub Class_Initialize()
        sourceLogEvent = &quot;Management Group: &quot; + ManagementGroupName + &quot;. Script: &quot; + WScript.ScriptName + &quot;. Version: &quot; + MANAGEMENT_PACK_VERSION
    End Sub
    
    Private Sub Class_Terminate()
    End Sub
    
    Public Property Get ErrorEventType
        ErrorEventType = 1
    End Property
    
    Public Property Get WarningEventType
        WarningEventType = 2
    End Property
    
    Public Property Get InfoEventType
        InfoEventType = 4
    End Property

    Private Function LogEvent (message, eventType)
        On Error Resume Next
        Dim oAPI
        Set oAPI = CreateObject(&quot;MOM.ScriptAPI&quot;)
        Call oAPI.LogScriptEvent(sourceLogEvent, SCRIPT_EVENT_ID, eventType, message)
    End Function

    Public Function LogDebug(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
            LogEvent message, Me.InfoEventType
        End If
    End Function
    
    Public Function LogError(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.ErrorEventType
    End Function
    
    Public Function LogWarning(message)
        if DEBUG_MODE Then
            WScript.StdOut.WriteLine message
        End If
        LogEvent message, Me.WarningEventType
    End Function
    
    Public Function LogFormattedError(customMessage)
        If Err.number &lt;&gt; 0 Then
            Me.LogError FormatErrorMessage(customMessage, &quot;&quot;)
        End If
    End Function
    
    Private Function ScriptInfo()
        Dim commandLineInfo  : commandLineInfo = WScript.ScriptFullName
        Dim argument
        For Each argument In WScript.Arguments
            commandLineInfo = commandLineInfo &amp; &quot; &quot;&quot;&quot; &amp; argument &amp; &quot;&quot;&quot;&quot;
        Next
        ScriptInfo = commandLineInfo
    End Function
End Class

Function FormatErrorMessage(customMessage, instanceName)
    FormatErrorMessage = customMessage
    If Err.number &lt;&gt; 0 Then
        Dim msg
        msg =_
        &quot; Error Number: &quot; &amp; CStr(Err.number) &amp; VbCrLf &amp; _
        &quot; Description: &quot; &amp; Err.Description

        If Not IsEmpty(instanceName) And instanceName &lt;&gt; &quot;&quot; Then
            msg = msg &amp; VbCrLf &amp; &quot; Instance: &quot; &amp; instanceName
        End If
        If customMessage &lt;&gt; &quot;&quot; Then
            msg = customMessage &amp; VbCrLf &amp; msg &amp; VbCrLf
        End If       
        FormatErrorMessage = msg
    End If
End Function

Function FormatDbErrorMessage(message, instanceName, dbName)
    FormatDbErrorMessage = message &amp; VbCrLf &amp; _
    &quot; Instance: &quot; &amp; instanceName &amp; VbCrLf &amp; _
    &quot; Database: &quot; &amp; dbName
End Function

Function ThrowScriptErrorNoAbort(ByVal sMessage, ByVal oErr)
    On Error Resume Next
    Dim errorText: errorText =  sMessage &amp; &quot;: &quot; &amp; oErr.Description
    GlobalErrorList.Add errorText
End Function

Function ThrowScriptError(Byval sMessage, ByVal oErr)
    On Error Resume Next
    ThrowScriptErrorNoAbort sMessage, oErr
    GlobalErrorListToEventLog()
    Quit()
End Function

Sub HandleError(customMessage)
    Dim localLogger
    If Err.number &lt;&gt; 0 Then
        Set localLogger = new ScriptLogger
        Call localLogger.LogFormattedError(customMessage)
        Call Wscript.Quit(0)
    End If
End Sub

Function HandleErrorContinue(customMessage)
    HandleErrorContinue = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinue = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, &quot;&quot;))
        Call Err.Clear()
    End If
End Function

Function HandleErrorContinueEx(customMessage, instanceName)
    HandleErrorContinueEx = True
    If Err.number &lt;&gt; 0 Then
        HandleErrorContinueEx = False
        Call GlobalErrorList.Add(FormatErrorMessage(customMessage, instanceName))
        Call Err.Clear()
    End If
End Function

Function HandleSqlErrorContinue(adoConnection, customMessage, instanceName)
    HandleSqlErrorContinue = True   
    If Err.Number &lt;&gt; 0 Then
        HandleSqlErrorContinue = False
        Dim sqlErr
        Dim e: Set e = new Error
        e.Save
        On Error Resume Next
        If adoConnection.Errors.Count &gt; 0 Then
            Set sqlErr = adoConnection.Errors(0)
            adoConnection.Errors.Clear
            Call Err.Raise(sqlErr.Number, sqlErr.Source, sqlErr.Description)
        Else
            Call e.Raise()
        End If
        Call HandleErrorContinueEx(customMessage, instanceName)
    End If
End Function

Function GetGlobalErrorListEventString()
    GetGlobalErrorListEventString = &quot;&quot;
    If Not GlobalErrorList.IsEmpty Then
        GetGlobalErrorListEventString = &quot;The next errors occurred:&quot;&amp; vbNewLine &amp; Join(GlobalErrorList.ItemsArray, vbNewLine &amp; vbNewLine)
    End If
End Function

Function GlobalErrorListToEventLog()
    On Error Resume Next
    If Not GlobalErrorList.IsEmpty Then
        Dim localLogger: Set localLogger = New ScriptLogger
        localLogger.LogWarning GetGlobalErrorListEventString()
    End If
End Function

Function Quit()
    WScript.Quit()
End Function

Sub WriteToEventLogAndExit(ByVal message)
    oAPI.LogScriptEvent &quot;Management Group: &quot; &amp; ManagementGroupName &amp; &quot;. Script: &quot; &amp; WScript.ScriptName &amp; &quot;. Version: &quot; &amp; MANAGEMENT_PACK_VERSION, 4002, EVENT_TYPE_ERROR, message   
    WScript.Quit()
End Sub

Function EscapeWQLString (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function ConnectToWMI(ComputerName, strNamespace)
    Set ConnectToWMI = Nothing
	Set ConnectToWMI = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; ComputerName &amp; &quot;\&quot; &amp; strNamespace)
End Function

Function WMIGetProperty(oWmi, sPropName, nCIMType, ErrAction)
    Dim sValue, oWmiProp
    
    If Not IsValidObject(oWmi) Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;Accessing property on invalid WMI object.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        Exit Function
    End If
    
    On Error Resume Next
    Set oWmiProp = oWmi.Properties_.Item(sPropName)
    If Err.Number &lt;&gt; 0 Then
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
    End If
    On Error GoTo 0
    
    If IsValidObject(oWmiProp) Then
        sValue = oWmiProp.Value
        
        If IsNull(sValue) Then
            &apos;
            &apos; If value is null, return blank to avoid any issues
            &apos;
            WMIGetProperty = &quot;&quot;
            
        Else
            
            Select Case (oWmiProp.CIMType)
                Case wbemCimtypeString, wbemCimtypeSint16, wbemCimtypeSint32, wbemCimtypeReal32, wbemCimtypeReal64, wbemCimtypeSint8, wbemCimtypeUint8, wbemCimtypeUint16, wbemCimtypeUint32, wbemCimtypeSint64, wbemCimtypeUint64:
                    If Not oWmiProp.IsArray Then
                        WMIGetProperty = Trim(CStr(sValue))
                    Else
                        WMIGetProperty = Join(sValue, &quot;, &quot;)
                    End If

                Case wbemCimtypeBoolean:
                    If sValue = 1 Or UCase(sValue) = &quot;TRUE&quot; Then
                        WMIGetProperty = &quot;True&quot;
                    Else
                        WMIGetProperty = &quot;False&quot;
                    End If

                Case wbemCimtypeDatetime:
                    Dim sTmpStrDate
                
                    &apos;
                    &apos; First attempt to convert the whole wmi date string
                    &apos;
                    sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                  Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                  Left(sValue, 4) &amp; &quot; &quot; &amp; _
                                  Mid (sValue, 9, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 11, 2) &amp; &quot;:&quot; &amp; _
                                  Mid(sValue, 13, 2)
                    If IsDate(sTmpStrDate) Then
                        WMIGetProperty = CDate(sTmpStrDate)
                    Else
                    
                        &apos;
                        &apos; Second, attempt just to convert the YYYYMMDD
                        &apos;
                        sTmpStrDate = Mid(sValue, 5, 2) &amp; &quot;/&quot; &amp; _
                                      Mid(sValue, 7, 2) &amp; &quot;/&quot; &amp; _
                                      Left(sValue, 4)
                        If IsDate(sTmpStrDate) Then
                            WMIGetProperty = CDate(sTmpStrDate)
                        Else
                            &apos;
                            &apos; Nothing works - return passed in string
                            &apos;
                            WMIGetProperty = sValue
                        End If
                    
                    End If
                
                Case Else:
                    WMIGetProperty = &quot;&quot;
            End Select
        End If
    Else
        
        If (ErrAction And ErrAction_ThrowError) = ErrAction_ThrowError Then _
            ThrowScriptErrorNoAbort &quot;An error occurred while accessing WMI property: &apos;&quot; &amp; sPropName &amp; &quot;&apos;.&quot;, Err
        
        If (ErrAction And ErrAction_Abort) = ErrAction_Abort Then _
            Quit()
        
        WMIGetProperty = &quot;&quot;
        
    End If
    
    
    If (ErrAction And ErrAction_Trace) = ErrAction_Trace Then _
        WScript.Echo &quot;  + &quot; &amp; sPropName &amp; &quot; :: &apos;&quot; &amp; WMIGetProperty &amp; &quot;&apos;&quot;
    
End Function

Function WMIExecQuery(ByVal sNamespace, ByVal sQuery)
    &apos;
    &apos; WMIExecQuery :: Executes the WMI query and returns the result set.
    &apos;
    &apos;
    Dim oWMI, oQuery, nInstanceCount
    Dim e
    Set e = New Error
    On Error Resume Next
    Set oWMI = GetObject(sNamespace)
    e.Save
    On Error GoTo 0
    If IsEmpty(oWMI) Then
        ThrowScriptErrorNoAbort &quot;Unable to open WMI Namespace &apos;&quot; &amp; sNamespace &amp; &quot;&apos;.  Check to see if the WMI service is enabled and running, and ensure this WMI namespace exists.&quot;, e
        ThrowEmptyDiscoveryData
    End If
    
    On Error Resume Next
        Set oQuery = oWMI.ExecQuery(sQuery)
        e.Save
    On Error GoTo 0
    If IsEmpty(oQuery) Or e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; returned an invalid result set.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    &apos;Determine if we queried a valid WMI class - Count will return 0 or empty
    On Error Resume Next
    nInstanceCount = oQuery.Count
    e.Save
    On Error GoTo 0
    If e.Number &lt;&gt; 0 Then
        ThrowScriptError &quot;The Query &apos;&quot; &amp; sQuery &amp; &quot;&apos; did not return any valid instances.  Please check to see if this is a valid WMI Query.&quot;, e
    End If
    
    Set WMIExecQuery = oQuery
    
End Function

Function GetFirstItemFromWMIQuery(ByRef oQuery)
    ON ERROR RESUME NEXT
    Err.Clear
    Dim oResult: Set oResult = Nothing
    Set oResult = oQuery.ItemIndex(0)
    if Err.number &lt;&gt; 0 then
        Err.Clear
        Dim oObject
        For Each oObject in oQuery 
            Set oResult = oObject
            Exit For
        Next    
    end if
    Set GetFirstItemFromWMIQuery = oResult
End Function

Class Registry
    Public HKEY_CLASSES_ROOT
    Public HKEY_CURRENT_USER
    Public HKEY_LOCAL_MACHINE
    Public HKEY_USERS
    Public HKEY_CURRENT_CONFIG
    Public HKEY_DYN_DATA 

    Public ERROR_ACCESS_DENIED
    Public ERROR_KEY_NOT_FOUND
    Public ERROR_VALUE_NOT_FOUND
    Public SUCCESS
    
    Private m_oReg
    Private m_lHive
    
    Private Sub Class_Initialize()
        HKEY_CLASSES_ROOT = &amp;H80000000
        HKEY_CURRENT_USER = &amp;H80000001 
        HKEY_LOCAL_MACHINE = &amp;H80000002
        HKEY_USERS = &amp;H80000003 
        HKEY_CURRENT_CONFIG = &amp;H80000005
        HKEY_DYN_DATA = &amp;H80000006
        
        ERROR_ACCESS_DENIED = 5
        ERROR_KEY_NOT_FOUND = 2
        ERROR_VALUE_NOT_FOUND = 1
        SUCCESS = 0
        
        m_lHive = HKEY_LOCAL_MACHINE
    End Sub
    
    Public Sub Connect(ByVal sHostName)
        Set m_oReg = GetObject(&quot;winmgmts://&quot; &amp; sHostName &amp; &quot;/root/default:StdRegProv&quot;)
    End Sub
    
    Public Property Get Hive()
        Hive = m_lHive
    End Property
    
    Public Property Let Hive(ByVal lHive)
        m_lHive = lHive
    End Property
    
    Public Function ReadDWORDValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim lValue
        lResult = m_oReg.GetDWORDValue(m_lHive, sKeyPath, sValueName, lValue)
        ReadDWORDValue = lValue
    End Function
    
    Public Function ReadStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim sValue
        lResult = m_oReg.GetStringValue(m_lHive, sKeyPath, sValueName, sValue)
        ReadStringValue = sValue
    End Function
    
    Public Function ReadMultiStringValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aValues
        lResult = m_oReg.GetMultiStringValue(m_lHive, sKeyPath, sValueName, aValues)
        ReadMultiStringValue = aValues
    End Function
    
    Public Function EnumKeys(ByVal sKeyPath, ByRef lResult)
        Dim aSubKeys
        lResult = m_oReg.EnumKey(m_lHive, sKeyPath, aSubKeys)
        EnumKeys = aSubKeys
    End Function

    Public Function EnumValues(ByVal sKeyPath, ByRef lResult)
        Dim aNames, aTypes
        lResult = m_oReg.EnumValues(m_lHive, sKeyPath, aNames, aTypes)
        EnumValues = aNames
    End Function
    
    Public Function CreateKey(ByVal sKeyPath)
        CreateKey = m_oReg.CreateKey(m_lHive, sKeyPath)
    End Function
    
    Public Function WriteStringValue(ByVal sKeyPath, ByVal sValueName, ByVal sValue)
        WriteStringValue = m_oReg.SetStringValue(m_lHive, sKeyPath, sValueName, sValue)
    End Function
    
    Public Function DeleteValue(ByVal sKeyPath, ByVal sValueName)
        DeleteValue = m_oReg.DeleteValue(m_lHive, sKeyPath, sValueName)
    End Function
    
    Public Function ReadBinaryValue(ByVal sKeyPath, ByVal sValueName, ByRef lResult)
        Dim aData
        lResult = m_oReg.GetBinaryValue(m_lHive, sKeyPath, sValueName, aData)
        ReadBinaryValue = aData
    End Function

End Class

Function ArraysAreIntersected(ByRef arrA, ByRef arrB)
    Dim itemA, itemB
    ArraysAreIntersected = False
    For Each itemA in arrA
        For Each itemB in arrB
            If itemA = itemB Then
                ArraysAreIntersected = True
                Exit Function
            End If
        Next
    Next
End Function

Function ArrayContains(ByRef arr, ByRef searchItem)
    ArrayContains = False
    Dim item
    For Each item In arr
        If item = searchItem Then
            ArrayContains = True
            Exit Function
        End If
    Next
End Function

Function GetDriverVersionObj(oVersion)
    Dim tpName, vVersion
    tpName = TypeName(oVersion)
    Select Case tpName
    Case &quot;DriverVersion&quot;
        Set vVersion = oVersion
    Case &quot;String&quot;
        Set vVersion = (new DriverVersion)(oVersion)
    Case Else
        Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Parameter is not an instance of type DriverVersion.&quot;)
    End Select
    Set GetDriverVersionObj = vVersion
End Function

Class DriverVersion
    Private m_major
    Private m_minor
    Private m_build
    Private m_revision
    
    Public Default Function Init(versionStr)
        Parse(versionStr)
        Set Init = Me
    End Function

    Private Sub Parse(vStr)
        Dim parts, versionRegex, oRegex, matches
        Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{1,8})(.\d{1,8}){0,3}$&quot;
        Set matches = oRegex.Execute(vStr)
        If matches.Count = 0 Then
            Call Err.Raise(7100, &quot;DriverVersion&quot;, &quot;Invalid version string.&quot;)
        End If
        parts = Split(vStr, &quot;.&quot;)
        m_major = CLng(parts(0))
        m_minor = 0
        m_build = 0
        m_revision = 0
        IF UBound(parts) &gt;= 1 Then
            m_minor = CLng(parts(1))
            If UBound(parts) &gt;= 2 Then
                m_build = CLng(parts(2))
                If UBound(parts) &gt;= 3 Then
                    m_revision = CLng(parts(3))
                End If
            End If
        End If
    End Sub

    Public Function CompareTo(v)
        Dim d
        d = m_major - v.Major
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_minor - v.Minor
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_build - v.Build
        If d &lt;&gt; 0 Then
            CompareTo = d
            Exit Function
        End If
        d = m_revision - v.Revision
        CompareTo = d
    End Function
    
    Public Function ToString()
        ToString = &quot;&quot; &amp; m_major &amp; &quot;.&quot; &amp; m_minor &amp; &quot;.&quot; &amp; m_build &amp; &quot;.&quot; &amp; m_revision
    End Function

    Public Property Get Major()
        Major = m_major
    End Property

    Public Property Get Minor()
       Minor = m_minor
    End Property

    Public Property Get Build()
       Build = m_build
    End Property

    Public Property Get Revision()
       Revision = m_revision
    End Property
End Class

Class VersionRange
    Private m_startVersion
    Private m_endVersion

    Public Default Function Init(sStartVersion, sEndVersion)
        Set m_startVersion = GetDriverVersionObj(sStartVersion)
        Set m_endVersion = GetDriverVersionObj(sEndVersion)
        Set Init = Me
    End Function

    Public Property Get StartVersion()
        Set StartVersion = m_startVersion
    End Property

    Public Property Get EndVersion()
        Set EndVersion = m_endVersion
    End Property
End Class

Class DriverItem
    Private m_name
    Private m_nameVersion
    Private m_driverVersion
    Private m_parseObject

    Public Default Function Init(sName, oNameVersion, oDriverVersion, ByRef oParseObject)
        m_Name = sName
        Set m_nameVersion = GetDriverVersionObj(oNameVersion)
        Set m_driverVersion = GetDriverVersionObj(oDriverVersion)
        Set m_parseObject = oParseObject
        Set Init = Me
    End Function 

    Public Property Get Name()
        Name = m_name
    End Property

    Public Property Get NameVersion()
        Set NameVersion = m_nameVersion
    End Property

    Public Property Get DriverVersion()
        Set DriverVersion = m_driverVersion
    End Property
    
    Public Property Get ParseObject()
        Set ParseObject = m_parseObject
    End Property
End Class

Class DriverSelectorRule
    Private m_nameRegexStr
    Private m_nameRegex
    Private m_versionRegexStr
    Private m_versionRegex
    Private m_nameMinVersion
    Private m_nameMaxVersion
    Private m_computerId
    Private m_driverVersionArr

    Public DriverCollection
    Public IsNativeClient

    Public Default Function Init(sNameRegex, sVersionRegex, sNameMinVersion, sNameMaxVersion, oVersionRangeArray)
        m_computerId = &quot;.&quot;
        m_nameRegexStr = sNameRegex
        Set m_nameRegex = New RegExp
        m_nameRegex.Pattern = m_nameRegexStr
        m_versionRegexStr = sVersionRegex
        If Not IsNull(m_versionRegexStr) Then
            If Len(m_versionRegexStr) &gt; 0 Then
                Set m_versionRegex = New RegExp
                m_versionRegex.Pattern = m_versionRegexStr
                m_versionRegex.Global = True
            End If
        End If
        Set m_nameMinVersion = GetDriverVersionObj(sNameMinVersion)
        Set m_nameMaxVersion = GetDriverVersionObj(sNameMaxVersion)
        m_driverVersionArr = oVersionRangeArray

        DriverCollection = Array()
        IsNativeClient = False
        Set Init = Me
    End Function

     Private Function CheckVersion(oVersion, vMinVersion, vMaxVersion)
        Dim vVersion: Set vVersion = GetDriverVersionObj(oVersion)
        CheckVersion = vVersion.CompareTo(vMinVersion) &gt;= 0 And (vVersion.ToString() = MAX_DRIVER_VERSION_STR Or vMinVersion.CompareTo(vMaxVersion) = 0 Or vVersion.CompareTo(vMaxVersion) &lt; 0)
    End Function

    Public Function MatchName(sDriverName)
        Dim matches
        Set matches = m_nameRegex.Execute(sDriverName)
        If matches.Count &gt; 0 Then
            MatchName = True
            Exit Function
        End If
        MatchName = False
    End Function

    Public Function GetNameVersion(sDriverName)
        Dim sVersion, matches
        If Not IsNull(m_versionRegexStr) Then
            Set matches = m_versionRegex.Execute(sDriverName)
            If matches.Count &gt; 0 Then
                sVersion = matches(0).Value
            End If   
        End If
        If Not IsNull(sVersion) Then
            Set GetNameVersion = GetDriverVersionObj(sVersion)
        Else
            Set GetNameVersion = GetDriverVersionObj(&quot;0&quot;)
        End If
    End Function

    Public Function CheckNameVersion(oVersion)
        CheckNameVersion = CheckVersion(oVersion, m_nameMinVersion, m_nameMaxVersion)
    End Function

    Public Function CheckDriverVersion(oVersion)
        CheckDriverVersion = False
        Dim driverVersionItem
        For Each driverVersionItem In m_driverVersionArr
             If CheckVersion(oVersion, driverVersionItem.StartVersion, driverVersionItem.EndVersion) Then
                CheckDriverVersion = True
                Exit For
            End If
        Next
    End Function

    Public Function GetDriverVersion(sDriverName)
        Dim computerId, driverPath, sDllVersion, objFSO, oRegistry
        Dim HKEY_LOCAL_MACHINE: HKEY_LOCAL_MACHINE = &amp;H80000002
        Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\&quot; &amp; sDriverName, &quot;Driver&quot;, driverPath   
        Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;) 
        sDllVersion =  objFSO.GetFileVersion(driverPath)
        Set GetDriverVersion = (new DriverVersion)(sDllVersion)
    End Function

    Public Sub AddDriver(ByRef oDriver)
        ReDim Preserve DriverCollection(UBound(DriverCollection) + 1) 
        Set DriverCollection(UBound(DriverCollection)) = oDriver
    End Sub

    Public Sub ResetState()
        DriverCollection = Array()
    End Sub

    Public Property Get DriverNameRegex()
        DriverNameRegex = m_nameRegexStr
    End Property

    Public Property Get NameMinVersion()
        Set NameMinVersion= m_nameMinVersion
    End Property

    Public Property Get NameMaxVersion()
        Set NameMaxVersion = m_nameMaxVersion
    End Property

    Public Property Get VersionRangeCollection()
        VersionRangeCollection = m_driverVersionArr
    End Property

    Public Property Get CollectionIsEmpty()
        CollectionIsEmpty = UBound(DriverCollection) &lt; 0
    End Property
End Class

Class DriverSelector
	Private m_computerId
    Private m_selectorRules(3)
    Private m_selectedDriverName
    Private m_processed
    Private HKEY_LOCAL_MACHINE
    Private m_defaultDriverName

    Private m_ncli_ForceProtocolEncryption
    Private m_ncli_TrustServerCertificate

    Private m_ncli_tcpProtocolEnabled
    Private m_ncli_smProtocolEnabled

    Public ErrorCollection

    Private Sub Class_Initialize()
        Set m_selectorRules(0) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;,&quot;\d{1,8}(\.\d{1,8})?$&quot;, &quot;11.0&quot;, &quot;11.0&quot;,_
            Array(_
               (new VersionRange)(&quot;2011.110.6020.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2011.110.5592.0&quot;, &quot;2011.110.6000.0&quot;),_
               (new VersionRange)(&quot;2011.110.5347.0&quot;, &quot;2011.110.5522.0&quot;)))
        m_selectorRules(0).IsNativeClient = True
        Set m_selectorRules(1) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;11.0&quot;, MAX_DRIVER_VERSION_STR,_
            Array(_
               (new VersionRange)(&quot;2014.120.4219.0&quot;, MAX_DRIVER_VERSION_STR),_
               (new VersionRange)(&quot;2014.120.2546.0&quot;, &quot;2014.120.4000.0&quot;)))
        Set m_selectorRules(2) = (new DriverSelectorRule)(&quot;^SQL\sServer\sNative\sClient\s\d{1,8}(\.\d{1,8})?$&quot;, &quot;\d{1,8}(\.\d{1,8})?$&quot;,&quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
        m_selectorRules(2).IsNativeClient = True
        Set m_selectorRules(3) = (new DriverSelectorRule)(&quot;^ODBC\sDriver\s\d{1,8}(\.\d{1,8})?\sfor\sSQL\sServer$&quot;, &quot;\d{1,8}(\.\d{1,8})?(?=\sfor\sSQL\sServer$)&quot;, &quot;0&quot;, MAX_DRIVER_VERSION_STR, Array((new VersionRange)(&quot;0&quot;, MAX_DRIVER_VERSION_STR)))
		
        m_computerId = &quot;.&quot;
        m_defaultDriverName = &quot;SQL Server&quot;
        HKEY_LOCAL_MACHINE = &amp;H80000002
        m_ncli_ForceProtocolEncryption = False
        m_ncli_TrustServerCertificate = False
        m_ncli_tcpProtocolEnabled  = True
        m_processed = False
        Call ResetState()
    End Sub

    &apos; Select most appropriate driver from filtered installed system (ODBC) drivers.
    &apos; select all available drivers
    &apos; Filter by driver name and version
    &apos; Intersected: check client and server have shared protocols
    &apos; tcp and np (Named Pipes) can work by network, sm can work only locally
    &apos; driver priorities: sm, tcp; np not used
    &apos; 
    &apos; For native client need common client and server protocols
    &apos; 
    &apos; Select latest namespace with highest version
    &apos; Select client protocols
    &apos; Select server protocols (enabled)
    &apos; Intersect client and server protocols
    &apos; Select odbc drivers related to inresected protocols
    &apos; We have 3 possible drivers:
    &apos; - ODBC (all protocols enabled)
    &apos; - Native Client (tcp, sm, np protocols)
    &apos;      only native client can choose protocols through registry settings
    &apos; - Microsoft SQL Server (all protocols enabled)
	Public Sub ProcessDrivers(enabledServerProtocols)
        Dim ri, i, isSelected, currentSelect, oError
        Set oError = New Error
        Call ResetState()
        On Error Resume Next

        Dim client: Set client = GetClientParameters()

        Dim ncProtocolsAreIntersected: ncProtocolsAreIntersected = ArraysAreIntersected(enabledServerProtocols, client.Protocols)
		Call ProcessSystemOdbcDrivers(ncProtocolsAreIntersected)

        oError.Save
        If oError.Number &lt;&gt; 0 Then
            Call AddError(oError)
            m_selectedDriverName = m_defaultDriverName
            m_processed = true
            Exit Sub
        End If
        On Error GoTo 0
        
        Dim driver: Set driver = SelectFreshDriver(m_selectorRules)

        If Not driver Is Nothing Then
            If driver.ParseObject.IsNativeClient Then
                client.IsTcpProtocolEnabled = ArrayContains(client.Protocols, &quot;tcp&quot;)
                client.IsSharedMemoryProtocolEnabled = ArrayContains(client.Protocols, &quot;sm&quot;)
            End If
        End If

        If Not driver Is Nothing Then
            client.DriverName = driver.Name
        End If

        &apos; for compatibility fill deprecated
        m_selectedDriverName = client.DriverName
        m_ncli_ForceProtocolEncryption = client.IsForceProtocolEncryption
        m_ncli_TrustServerCertificate = client.IsTrustServerCertificate
        m_ncli_tcpProtocolEnabled = client.IsTcpProtocolEnabled
        m_ncli_smProtocolEnabled = client.IsSharedMemoryProtocolEnabled

        m_processed = True
	End Sub

    Private Function SelectFreshDriver(rules)
        Set SelectFreshDriver = Nothing
        Dim selected: Set selected = Nothing
        Dim rule: Set selected = Nothing
        Dim driver: Set selected = Nothing

        For Each rule In rules
            For Each driver In rule.DriverCollection
                &apos; select first if not selected
                If selected Is Nothing Then
                    Set selected = driver
                Else
                    &apos; select fresh, compare driver with selected by name and
                    &apos; version
                    if driver.NameVersion.CompareTo(selected.NameVersion) &gt;= 0 And _
                        driver.DriverVersion.CompareTo(selected.DriverVersion) &gt;= 0 Then
                        Set selected = driver
                    End If
                End If
            Next

            &apos; all rules have order by priority, if rule contains drivers, then
            &apos; selected with high priority
            if Not selected Is Nothing Then
                Exit For
            End If
        Next

        Set SelectFreshDriver = selected
    End Function

    Private Function GetClientParameters()
        Set GetClientParameters = Nothing
        Dim params: Set params = (New ConnectionParams)(&quot;.&quot;)
        params.Namespace = GetNsNameWithHighestVersion()
        Call GetNativeClientSettings(params.Namespace, params)
        params.Protocols = GetEnabledNativeClientProtocols(params.Namespace)
        Set GetClientParameters = params
    End Function
	
    Private Sub ProcessOdbcDriver(driverName, protocolsAreIntersected)
        Dim isInstalled, oRegistry, oNameVersion, oDriverVersion
        Set oRegistry = GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)
        
        oRegistry.GetStringValue HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverName, isInstalled 
        Dim selectorRule
        For Each selectorRule In m_selectorRules
            If (isInstalled &lt;&gt; &quot;Installed&quot;) Then
                Exit For
            End If
            If selectorRule.MatchName(driverName) Then
                If (Not selectorRule.IsNativeClient) Or (selectorRule.IsNativeClient And protocolsAreIntersected) Then
                    Set oNameVersion = selectorRule.GetNameVersion(driverName)
                    If (selectorRule.CheckNameVersion(oNameVersion)) Then
                        Set oDriverVersion = selectorRule.GetDriverVersion(driverName)
                        If (selectorRule.CheckDriverVersion(oDriverVersion)) Then
                            selectorRule.AddDriver((new DriverItem)(driverName, oNameVersion, oDriverVersion, selectorRule))
                            Exit For
                        End If
                    End If
                End If
            End If
        Next
    End Sub

    &apos; Get available drivers in the system and fill rules drivers
    &apos; TODO: rename method
	Private Sub ProcessSystemOdbcDrivers(protocolsAreIntersected)
        Dim oRegistry, driverNames, paramValueTypes, i, oError
        Set oError = New Error
		Set oRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; m_computerId &amp; &quot;\root\default:StdRegProv&quot;)
		Call oRegistry.EnumValues(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers&quot;, driverNames, paramValueTypes)
		On Error Resume Next

        Dim driverName
        For Each driverName In driverNames
            oError.Clear
            Call ProcessOdbcDriver(driverName, protocolsAreIntersected)
            oError.Save
            If oError.Number &lt;&gt; 0 Then
                Call AddError(oError)
            End If
		Next
	End Sub
	
    Private Function GetNsNameWithHighestVersion()
        Dim rootNs: rootNs = &quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\Microsoft\SqlServer&quot;
        Dim oWMI: Set oWMI = GetObject(rootNs)
        Dim namespaces: Set namespaces = oWMI.ExecQuery(&quot;SELECT Name FROM __NAMESPACE WHERE Name LIKE &apos;ComputerManagement%&apos;&quot;)
        Dim currentName: currentName = &quot;&quot;
        Dim objItem
	    For Each objItem In namespaces
            If objItem.Name &gt; currentName Then
                currentName = objItem.Name
            End If
        Next
        GetNsNameWithHighestVersion = rootNs &amp; &quot;\&quot; &amp; currentName
    End Function

    Private Sub GetNativeClientSettings(namespaceFullName, params)
        On Error Resume Next
        Err.Clear

        Dim sNamespace, oWMI, objClasses, sState, sTargetComputer
        Set oWMI = GetObject(namespaceFullName)
        Set objClasses = Nothing

        &apos; query can fail, because native client not supported
        Set objClasses = oWMI.ExecQuery(&quot;SELECT FlagName, FlagValue FROM ClientSettingsGeneralFlag&quot;)

        &apos; do nothing, its ok, just skip this settings
        If (Err.Number &lt;&gt; 0) Or (objClasses Is Nothing) Then
            Exit Sub
        End If

        Dim objItem
        For Each objItem in objClasses
            Select Case objItem.FlagName
            Case &quot;Force protocol encryption&quot;
                &apos;m_ncli_ForceProtocolEncryption = objItem.FlagValue
                params.IsForceProtocolEncryption = objItem.FlagValue
            Case &quot;Trust Server Certificate&quot;
                &apos;m_ncli_TrustServerCertificate = objItem.FlagValue
                params.IsTrustServerCertificate = objItem.FlagValue
            End Select
        Next
    End Sub   

    Private Function GetEnabledNativeClientProtocols(namespaceFullName)
        On Error Resume Next
        Err.Clear

        Dim oWMI: Set oWMI = GetObject(namespaceFullName)  
        Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, ProtocolOrder FROM ClientNetworkProtocol&quot;)

        If (oQuery.Count &gt; 0) And (Err.Number Is 0) Then
            Dim protocolsArr: Set protocolsArr = New ArrayList
            Dim protocolItem
            For Each protocolItem In oQuery
                If protocolItem.ProtocolOrder &gt; 0 Then
                    protocolsArr.Add LCase(protocolItem.ProtocolName)
                End If
            Next
            GetEnabledNativeClientProtocols = protocolsArr.ItemsArray
        Else
            GetEnabledNativeClientProtocols = Array()
        End If
    End Function

    Private Sub AddError(oError)
        Dim newSize
        newSize = UBound(ErrorCollection) + 1
        ReDim Preserve ErrorCollection(newSize)
        ErrorCollection(newSize) = &quot;[&quot; &amp; (oError.Number and 65535) &amp; &quot;][&quot; &amp; oError.Source &amp; &quot;] &quot; &amp; oError.Description 
    End Sub

    Private Sub ResetState()
        Dim pr
        ErrorCollection = Array()
        For Each pr In m_selectorRules
            pr.ResetState()
        Next
    End Sub

    Private Sub ThrowIfNotProcessed()
        If Not m_processed Then
            Call Err.Raise(SCRIPT_EVENT_ID, &quot;&quot;, &quot;Drivers are not processed. Call &apos;ProcessDrivers&apos; first.&quot;)
        End If
    End Sub

    Public Property Get HasErrors()
        HasErrors = UBound(ErrorCollection) &gt;= 0
    End Property

    Public Property Get DriverName()
        ThrowIfNotProcessed
        DriverName = m_selectedDriverName
    End Property 

    Public Property Get UseFqdn()
        ThrowIfNotProcessed
        UseFqdn = m_ncli_ForceProtocolEncryption And Not m_ncli_TrustServerCertificate
    End Property

    Public Property Get ClientTcpProtocolEnabled()
        ThrowIfNotProcessed
        ClientTcpProtocolEnabled = m_ncli_tcpProtocolEnabled
    End Property

    Public Property Get ClientSharedMemoryProtocolEnabled()
        ThrowIfNotProcessed
        ClientSharedMemoryProtocolEnabled = m_ncli_smProtocolEnabled
    End Property
End Class

Class ConnectionParams
    Public ComputerName
    Public DriverName
    Public Namespace
    Public IsForceProtocolEncryption
    Public IsTrustServerCertificate
    Public IsTcpProtocolEnabled
    Public IsSharedMemoryProtocolEnabled
    Public Protocols

    Public Default Function Init(sComputerName)
        ComputerName = sComputerName
        DriverName = DriverSelector_DEFAULT_DRIVER_NAME
        Namespace = &quot;&quot;
        IsForceProtocolEncryption = False
        IsTrustServerCertificate = False
        IsTcpProtocolEnabled = True
        IsSharedMemoryProtocolEnabled = True
        Set Init = Me
    End Function
End Class

Class UniqueCollection
    Private m_dict

    Public Default Function Init()
        Set m_dict = CreateObject(&quot;Scripting.Dictionary&quot;)
        Set Init = Me
    End Function

    Public Sub PutItem(item)
       If Not m_dict.Exists(item) Then
            m_dict.add item, &quot;&quot;
       End If
    End Sub
	
	Public Function Exists(item)
		Exists = m_dict.Exists(item)
	End Function
	
    Public Function GetItems()
        GetItems = m_dict.Keys()
    End Function

    Public Sub Clear()
        m_dict.RemoveAll()
    End Sub
End Class

Class SqlServerTcpIpSettings
    Private m_listenAllIPs
    Private m_ipSettings

    Public Default Function Init(listenAllIps, ipSettings)
        m_listenAllIPs = listenAllIps
        Set m_ipSettings = ipSettings
        Set Init = Me
    End Function

    Public Property Get ListenAllIPs()
        ListenAllIPs = m_listenAllIPs
    End Property

    Public Property Get IpSettings()
        Set IpSettings = m_ipSettings
    End Property
End Class

Function EscapeConnStringValue (ByVal strValue)
	On Error Resume Next
	Err.Clear
	EscapeConnStringValue  = &quot;{&quot; + Replace(strValue, &quot;}&quot;, &quot;}}&quot;) + &quot;}&quot;
End Function

Function EscapeWQLString (ByVal strValue)
	ON ERROR RESUME NEXT
	Err.Clear

	EscapeWQLString = Replace(Replace(strValue, &quot;\&quot;, &quot;\\&quot;), &quot;&apos;&quot;, &quot;\&apos;&quot;) 
End Function

Function furlEncode(vString,vEncDec)
    Dim i
    Dim aReserved(24,1)
    &apos;column 1
    aReserved(0,0) = &quot;%&quot; &apos;25
    aReserved(1,0) = &quot;;&quot; &apos;3B
    aReserved(2,0) = &quot;/&quot; &apos;2F
    aReserved(3,0) = &quot;?&quot; &apos;3F
    aReserved(4,0) = &quot;:&quot; &apos;3A
    aReserved(5,0) = &quot;@&quot; &apos;40
    aReserved(6,0) = &quot;&amp;&quot; &apos;26
    aReserved(7,0) = &quot;=&quot; &apos;3D
    aReserved(8,0) = &quot;+&quot; &apos;2B
    aReserved(9,0) = &quot;$&quot; &apos;24
    aReserved(10,0) = &quot;,&quot; &apos;2C
    aReserved(11,0) = &quot; &quot; &apos;20
    aReserved(12,0) = &quot;&quot;&quot;&quot; &apos;22
    aReserved(13,0) = &quot;&lt;&quot; &apos;3C
    aReserved(14,0) = &quot;&gt;&quot; &apos;3E
    aReserved(15,0) = &quot;#&quot; &apos;23
    aReserved(16,0) = &quot;{&quot; &apos;7B
    aReserved(17,0) = &quot;}&quot; &apos;7D
    aReserved(18,0) = &quot;|&quot; &apos;7C
    aReserved(19,0) = &quot;\&quot; &apos;5C
    aReserved(20,0) = &quot;^&quot; &apos;5E
    aReserved(21,0) = &quot;~&quot; &apos;7E
    aReserved(22,0) = &quot;[&quot; &apos;5B
    aReserved(23,0) = &quot;]&quot; &apos;5D
    aReserved(24,0) = &quot;`&quot; &apos;60
    &apos;column 2
    aReserved(0,1) = &quot;%25&quot;
    aReserved(1,1) = &quot;%3B&quot;
    aReserved(2,1) = &quot;%2F&quot;
    aReserved(3,1) = &quot;%3F&quot;
    aReserved(4,1) = &quot;%3A&quot;
    aReserved(5,1) = &quot;%40&quot;
    aReserved(6,1) = &quot;%26&quot;
    aReserved(7,1) = &quot;%3D&quot;
    aReserved(8,1) = &quot;%2B&quot;
    aReserved(9,1) = &quot;%24&quot;
    aReserved(10,1) = &quot;%2C&quot;
    aReserved(11,1) = &quot;%20&quot;
    aReserved(12,1) = &quot;%22&quot;
    aReserved(13,1) = &quot;%3C&quot;
    aReserved(14,1) = &quot;%3E&quot;
    aReserved(15,1) = &quot;%23&quot;
    aReserved(16,1) = &quot;%7B&quot;
    aReserved(17,1) = &quot;%7D&quot;
    aReserved(18,1) = &quot;%7C&quot;
    aReserved(19,1) = &quot;%5C&quot;
    aReserved(20,1) = &quot;%5E&quot;
    aReserved(21,1) = &quot;%7E&quot;
    aReserved(22,1) = &quot;%5B&quot;
    aReserved(23,1) = &quot;%5D&quot;
    aReserved(24,1) = &quot;%60&quot;

    For i = 0 to Ubound(aReserved)
        If vEncDec = &quot;enc&quot; Then
        vString = Replace(vString,aReserved(i,0),aReserved(i,1))
        End If
        If vEncDec = &quot;dec&quot; Then
        vString = Replace(vString,aReserved(i,1),aReserved(i,0))
        End If
    Next

    furlEncode = vString
End Function

Class UtcDateOperations
    Private m_wbemDate

    Private Sub Class_Initialize()
        Set m_wbemDate = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
    End Sub

    Public Function DateToIso8601UtcString(objDate)
        DateToIso8601UtcString = _
            DatePart(&quot;yyyy&quot;, objDate) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;m&quot;, objDate), 2) &amp; &quot;-&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;d&quot;, objDate), 2) &amp;_
            &quot;T&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;h&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;n&quot;, objDate), 2) &amp; &quot;:&quot; &amp;_
            Right(&quot;0&quot; &amp; DatePart(&quot;s&quot;, objDate), 2) &amp;_
            &quot;Z&quot;
    End Function

    Public Function Iso8601UtcStringToDate(sDate)
        Dim oRegex: Set oRegex = New RegExp
        oRegex.Pattern = &quot;^(\d{4})-(\d\d)-(\d\d)(?:T|\s)(\d\d):(\d\d):(\d\d)Z$&quot; 
        
        Dim matches: Set matches = oRegex.Execute(sDate)
        If matches.Count = 0 Then
            Err.Raise 4000, &quot;&quot;, &quot;Input date string is in invalid format&quot;
        End If
        
        Dim year: year = CInt(matches(0).SubMatches(0))
        Dim month: month = CInt(matches(0).SubMatches(1))
        Dim day: day = CInt(matches(0).SubMatches(2))

        Dim hour: hour = CInt(matches(0).SubMatches(3))
        Dim minute: minute = CInt(matches(0).SubMatches(4))
        Dim second: second = CInt(matches(0).SubMatches(5))

        Dim resDate: resDate = DateSerial(year, month, day)
        resDate = DateAdd(&quot;h&quot;, hour, resDate)
        resDate = DateAdd(&quot;n&quot;, minute, resDate)
        resDate = DateAdd(&quot;s&quot;, second, resDate)

        Iso8601UtcStringToDate = resDate
    End Function

    Public Function GetUtcNow()
        m_wbemDate.SetVarDate(Now())
        GetUtcNow = CDate(m_wbemDate.GetVarDate(false))
    End function

    Public Function CheckSecondsElapsed(sDate, nSeconds)
        Dim utcNow: utcNow = Me.GetUtcNow
        Dim utcDate: utcDate = Iso8601UtcStringToDate(sDate)
        CheckSecondsElapsed = DateDiff(&quot;s&quot;,utcDate,utcNow) &gt; nSeconds
    End function
End Class

Function GetCacheKey(stateMpPrefix, sKeyName)
    Dim oApi: Set oApi = CreateObject(&quot;MOM.ScriptAPI&quot;)
    Dim regKey: regKey = oAPI.GetScriptStateKeyPath(ManagementGroupID)
    regKey = regKey &amp; &quot;\&quot; &amp; stateMpPrefix &amp; &quot;\&quot; &amp; sKeyName
    GetCacheKey = regKey
End Function

Function GetStringValueFromCache(sKeyName, sValueName, cacheExpirationTime)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)
        
    Dim lErrCode
    Dim sDate: sDate = oReg.ReadStringValue(regKey, sDateValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    Dim sValue: sValue = oReg.ReadStringValue(regKey, sValueName, lErrCode)

    If lErrCode &lt;&gt; oReg.SUCCESS Then
        Exit Function
    End If

    If udo.CheckSecondsElapsed(sDate, cacheExpirationTime) Then
        Exit Function
    End If

    GetStringValueFromCache = sValue
End Function

Function PutStringValueToCache(sKeyName, sValueName, sValue)
    Dim stateMpPrefix: stateMpPrefix = &quot;SQLWindowsMP&quot;
    Dim sDateValueName: sDateValueName = sValueName &amp; &quot;_CreationTime&quot;

    Dim udo: Set udo = New UtcDateOperations
    Dim oReg: Set oReg = New Registry
   
    Dim regKey: regKey = GetCacheKey(stateMpPrefix, sKeyName)

    Dim dUtcNow: dUtcNow = udo.GetUtcNow()

    oReg.Hive = oReg.HKEY_LOCAL_MACHINE
    oReg.Connect(&quot;.&quot;)

    Call oReg.CreateKey(regKey)

    Dim lErrCode
    
    Call oReg.WriteStringValue(regKey, sValueName, sValue)
    Call oReg.WriteStringValue(regKey, sDateValueName, udo.DateToIso8601UtcString(dUtcNow))
End Function

Function GetWMISingleValue(wmiProvider, query, propertyName)
    Dim oQuery: Set oQuery = wmiProvider.ExecQuery(query)
    If oQuery.Count = 0 Then
        Err.Raise 4000, &quot;&quot;, &quot;Query &apos;&quot; &amp; query &amp; &quot;&apos; didn&apos;t return any objects&quot;
    End If
    Dim colSettings: Set colSettings = GetFirstItemFromWMIQuery(oQuery)
    GetWMISingleValue = colSettings.Properties_.Item(propertyName).Value
End Function

Class HostNameData
    Public HostName
    Public IsClustered

    Public Default Function Init(sHostName, bIsClustered)
        Me.HostName = sHostName
        Me.IsClustered = bIsClustered
        Set Init = Me
    End function
End Class

Function GetSqlServerHostName(strDNSComputerName, instanceName, namespace)
    Set GetSqlServerHostName = Nothing
    Dim serviceName: serviceName = GetSQLServiceName(instanceName)
    Dim escapedServiceName: escapedServiceName = EscapeWQLString(serviceName)
    
    Dim wmiProvider: Set wmiProvider = ConnectToWMI(strDNSComputerName, &quot;ROOT\Microsoft\SqlServer\&quot; + namespace)

    Dim isClustered: isClustered = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyNumValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;CLUSTERED&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyNumValue&quot;)

    Dim hostName
    If isClustered = 0 Then
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT HostName FROM SqlService WHERE SQLServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;HostName&quot;)
    Else
        hostName = GetWmiSingleValue(wmiProvider, &quot;SELECT PropertyStrValue FROM SqlServiceAdvancedProperty WHERE PropertyName = &apos;VSNAME&apos; AND SqlServiceType = 1 AND ServiceName = &apos;&quot; &amp; escapedServiceName &amp; &quot;&apos;&quot;, &quot;PropertyStrValue&quot;)
    End If

    Set GetSqlServerHostName = (New HostNameData)(hostName, CBool(isClustered))
End Function

Function EscapeCacheValueName(name)
    EscapeCacheValueName = Replace(name, &quot;_&quot;, &quot;__&quot;)
End Function

Function GetSqlServerHostNameEx(strDNSComputerName, instanceName, namespace)
    Set GetSqlServerHostNameEx = Nothing
    Dim cacheExpirationTime: cacheExpirationTime = 7200
    Dim hostValueName: hostValueName = EscapeCacheValueName(strDNSComputerName)
    Dim isClusteredValueName: isClusteredValueName = hostValueName &amp; &quot;_IsClustered&quot;
    Dim isClusteredStr

    On Error Resume Next
    Call Err.Clear()
    Dim hostName: hostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    If Err.Number = 0 And Not IsEmpty(hostName) Then
        isClusteredStr = GetStringValueFromCache(&quot;SqlHostNames&quot;, isClusteredValueName, cacheExpirationTime)
        If Err.Number = 0 And Not IsEmpty(isClusteredStr) Then
            If isClusteredStr = &quot;0&quot; Or isClusteredStr = &quot;1&quot; Then
                Set GetSqlServerHostNameEx = (New HostNameData)(hostName, CBool(isClusteredStr))
                Exit Function
            End If
        End If
    End If
    Call Err.Clear()

    On Error GoTo 0
    Dim hostNameData: Set hostNameData = GetSqlServerHostName(strDNSComputerName, instanceName, namespace)

    If hostNameData.IsClustered Then 
        isClusteredStr = &quot;1&quot;
    Else 
        isClusteredStr = &quot;0&quot;
    End If

    On Error Resume Next
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, hostValueName, hostNameData.HostName)
    Call PutStringValueToCache(&quot;SqlHostNames&quot;, isClusteredValueName, isClusteredStr)
    
    Call Err.Clear()

    Set GetSqlServerHostNameEx = hostNameData
End function

Function GetLocalHostName()
    Dim wshShell: Set wshShell = CreateObject( &quot;WScript.Shell&quot; )
    GetLocalHostName = wshShell.ExpandEnvironmentStrings(&quot;%COMPUTERNAME%&quot;)
End Function

Function DelimitSqlIdentifier(identifier)
    DelimitSqlIdentifier = &quot;[&quot; + Replace(identifier, &quot;]&quot;, &quot;]]&quot;) + &quot;]&quot;
End Function

Function SqlTcpPortIsEmpty(tcpPort)
    SqlTcpPortIsEmpty = (IsEmpty(tcpPort) Or tcpPort = &quot;&quot; Or tcpPort = &quot;0&quot;)
End Function

Function GetDataSource(server, tcpPort)
    Dim dataSource : dataSource = server
    If Not SqlTcpPortIsEmpty(tcpPort) Then
        Dim nameParts : nameParts = Split(dataSource, &quot;\&quot;)
        dataSource = nameParts(0) &amp; &quot;,&quot; &amp; tcpPort
    End If
    GetDataSource = dataSource
End Function

Function BuildDataSourceFromParts(computerName, instanceName, tcpPort)
    Dim dataSource : dataSource = computerName
    If instanceName &lt;&gt; &quot;MSSQLSERVER&quot; Then
        dataSource = computerName &amp; &quot;\&quot; &amp; instanceName
    End If
    BuildDataSourceFromParts = GetDataSource(dataSource, tcpPort)
End Function

Function GetConnectionString(driverName, dataSource, databaseName, intent)
    GetConnectionString = &quot;Driver=&quot; &amp; EscapeConnStringValue(driverName) &amp; &quot;;Server=&quot; &amp; EscapeConnStringValue(dataSource) &amp; &quot;;Database=&quot; &amp; EscapeConnStringValue(databaseName) &amp; &quot;;Trusted_Connection=yes;ApplicationIntent=&quot; &amp; intent
End Function

Function GetEnabledSqlServerProtocols(namespaceName, computerName, instanceName)
    Dim oWMI: Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot; &amp; namespaceName)  
    Dim oQuery: Set oQuery = oWMI.ExecQuery(&quot;SELECT ProtocolName, Enabled FROM ServerNetworkProtocol WHERE InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos;&quot;)
    If oQuery.Count &gt; 0 Then
        Dim protocolsArr: Set protocolsArr = New ArrayList
        Dim protocolItem
        For Each protocolItem In oQuery
            If protocolItem.Enabled Then
                protocolsArr.Add LCase(protocolItem.ProtocolName)
            End If
        Next
        GetEnabledSqlServerProtocols = protocolsArr.ItemsArray
    Else
        GetEnabledSqlServerProtocols = Array()
    End If
End Function

Function GetSqlServerTcpIpSettings(instanceName, computerName)
    ON ERROR RESUME NEXT
    Dim oWMI, oQuery, tcpItem
    Dim i, j
    Dim uc: Set uc = (new UniqueCollection)()
    Dim isListenAll: isListenAll = False
    Dim ipSettings: Set ipSettings = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set oWMI = GetObject(&quot;winmgmts:\\&quot; &amp; computerName &amp; &quot;\root\Microsoft\SqlServer\&quot;&amp; SQL_WMI_NAMESPACE)  

    Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND PropertyName = &apos;ListenOnAllIPs&apos;&quot;)

    If oQuery.Count &gt;0 Then
        Dim isListenAllObj: Set isListenAllObj = GetFirstItemFromWMIQuery(oQuery)
        If isListenAllObj.PropertyNumVal = 1 Then
            isListenAll  = True
        End If
    End If

    Dim tcpPorts, tcpPort, processedPort
        
    If isListenAll Then
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;IPAll&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
        If oQuery.Count &gt; 0 Then
            For Each tcpItem In oQuery
                tcpPorts = Split(tcpItem.PropertyStrVal,&quot;,&quot;)
                For Each tcpPort In tcpPorts
            	    processedPort = Trim(tcpPort)
            	    If Not SqlTcpPortIsEmpty(processedPort) Then
                	    uc.PutItem(processedPort)
                    End If
                Next
            Next
            ipSettings.add &quot;IPAll&quot;, uc.GetItems()
        End If
    Else
        Set oQuery = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName &lt;&gt; &apos;&apos; AND PropertyName = &apos;Enabled&apos; AND PropertyNumVal = 1&quot;) 
        Dim ipItem
        If oQuery.Count &gt; 0 Then
            For Each ipItem In oQuery
                Dim ipAddressName : ipAddressName = ipItem.IPAddressName
                Dim oQuery2 : Set oQuery2 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot; &amp; EscapeWQLString(instanceName) &amp; &quot;&apos; AND IPAddressName = &apos;&quot; &amp; EscapeWQLString(ipAddressName) &amp; &quot;&apos; AND PropertyName = &apos;IpAddress&apos; AND PropertyStrVal != &apos;&apos;&quot;)
                If oQuery2.Count &gt; 0 Then
                    Dim ipAddress : ipAddress = GetFirstItemFromWMIQuery(oQuery2).PropertyStrVal
                    Dim oQuery3: Set oQuery3 = oWMI.ExecQuery(&quot;SELECT * FROM ServerNetworkProtocolProperty WHERE ProtocolName = &apos;Tcp&apos; AND InstanceName = &apos;&quot;&amp; EscapeWQLString(instanceName) &amp;&quot;&apos; AND IPAddressName = &apos;&quot;&amp; EscapeWQLString(ipAddressName) &amp;&quot;&apos; AND (PropertyName = &apos;TcpPort&apos; OR PropertyName = &apos;TcpDynamicPorts&apos;) AND PropertyStrVal &lt;&gt; &apos;&apos;&quot;)
                    If oQuery3.Count &gt; 0 Then 
                        uc.Clear()
                        Dim portItem
                        For Each portItem In oQuery3
                            tcpPorts = Split(portItem.PropertyStrVal,&quot;,&quot;)
                            For Each tcpPort In tcpPorts
                            	processedPort = Trim(tcpPort)
                                If Not SqlTcpPortIsEmpty(processedPort) Then
				                	uc.PutItem(processedPort)
				                End If
                            Next
                            ipSettings.add ipAddress, uc.GetItems()
                        Next
                    End If
                End If
            Next
        End If
    End If
    Set GetSqlServerTcpIpSettings = (new SqlServerTcpIpSettings)(isListenAll, ipSettings)
End Function

Function GetTcpPortsString(ByVal inputDataSource)
    On Error Resume Next
	Dim computerName, instanceName, pathArray
	
	pathArray = Split(inputDataSource, &quot;\&quot;)
    computerName = pathArray(0)
    instanceName = &quot;MSSQLSERVER&quot;
	If (UBound(pathArray) &gt; 0) Then
	    instanceName = pathArray(1)
	End If

    Dim tcpIpSettings: Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, computerName)
    Dim upc : Set upc = (new UniqueCollection)()
    Dim ip, port
    For Each ip In tcpIpSettings.IpSettings.Keys 
        For Each port In tcpIpSettings.IpSettings.Item(ip)
            upc.PutItem port
        Next
    Next
    GetTcpPortsString = Join(upc.GetItems(),&quot;, &quot;)
End Function

Public Sub SqlTestDestination(dbConnection, hostName, instanceName, isADODB)
    Dim queryServerName, queryInstanceName
    Dim destinationTestQuery: destinationTestQuery = &quot;select CAST(SERVERPROPERTY(&apos;MachineName&apos;) AS nvarchar(128)) as ServerName, @@servicename as InstanceName&quot;
    On Error Goto 0
    If 0 = Err.number Then
        Dim queryResult
        If isADODB Then
            Set queryResult = dbConnection.ExecuteQueryTE(destinationTestQuery)
        Else
            Set queryResult = dbConnection.Execute(destinationTestQuery)
        End If
        If Not queryResult.EOF Then
            queryServerName = UCase(queryResult(&quot;ServerName&quot;).Value)
            queryInstanceName = UCase(queryResult(&quot;InstanceName&quot;).Value)
            If (UCase(hostName) = queryServerName) And (UCase(instanceName) = queryInstanceName) Then
                Exit Sub
            End If
        End If
        dbConnection.Close() 
        Err.Raise 16389, &quot;&quot;, &quot;Connection target check failed: connected to &quot; &amp; hostName &amp; &quot;\&quot; &amp; instanceName &amp; &quot;, but got &quot; &amp; queryServerName &amp; &quot;\&quot; &amp; queryInstanceName &amp; &quot;.&quot;
    End If
End Sub

Sub TryToConnectAndValidate(connectionObj, connectionString, timeout, hostName, instanceName, isADODB)
    On Error GoTo 0
    
    If isADODB Then
        connectionObj.Open connectionString, &quot;&quot;, timeout
    Else
        if (connectionObj.Mode &lt;&gt; 0) then
          connectionObj.Close()
        end if
        connectionObj.ConnectionTimeout = timeout
        connectionObj.Open connectionString
    End If
    SqlTestDestination connectionObj, hostName, instanceName, isADODB
End Sub

Function FormatConnectionErrorMessage(dataSource, lastError)
    FormatConnectionErrorMessage = &quot;Connection to data source &apos;&quot; &amp; dataSource &amp; &quot;&apos; failed: &quot; &amp; lastError.Description
End Function

Function SmartConnectWithoutSQLADODB(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName)    
    Set SmartConnectWithoutSQLADODB = SmartConnectWithoutSQLADODBIntent(inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectWithoutSQLADODBIntent(ByVal inputDataSource, ByVal tcpPort, ByVal machineName, ByVal instanceName, ByVal databaseName, ByVal intent)
    On Error Resume Next
    Set SmartConnectWithoutSQLADODBIntent = Nothing
    Dim dbMasterConnection, dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList
    
    Set dbMasterConnection = CreateObject(&quot;ADODB.Connection&quot;)

    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName 
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)
    
    If connectionString  &lt;&gt; &quot;&quot; And timeout  &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate dbMasterConnection, connectionString, timeout, netBiosHostName, instanceName, False
        lastError.Save
        If lastError.Number = 0 Then
            Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If

    Dim ds: Set ds = New DriverSelector

    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Set SmartConnectWithoutSQLADODBIntent = Nothing
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)   

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, machineName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

	
    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate dbMasterConnection, connectionString, 15, netBiosHostName, instanceName, False
    lastError.Save
    If lastError.Number = 0 Then
        Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If

    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
                lastError.Save
                If lastError.Number = 0 Then
                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
                End If
            Next
        Else
    	    &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
	                lastError.Save
	                If lastError.Number = 0 Then
	                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate dbMasterConnection, connectionString, 10, netBiosHostName, instanceName, False
		                lastError.Save
		                If lastError.Number = 0 Then
		                    Set SmartConnectWithoutSQLADODBIntent = dbMasterConnection
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Function SmartConnect(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName)    
     SmartConnect = SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, &quot;ReadOnly&quot;)
End Function

Function SmartConnectIntent(cnADOConnection, inputDataSource, tcpPort, machineName, instanceName, databaseName, intent)
    On Error Resume Next
    SmartConnectIntent = False
    Dim dataSource, connectionString, errorMessage
    Dim targetName : targetName = inputDataSource
    Dim lastError : Set lastError = new Error
    Dim errorMessageList : Set errorMessageList = New ArrayList 
    

    
    Dim cacheExpirationTime: cacheExpirationTime = (2 ^ 31) -1
    Dim hostValueName: hostValueName = EscapeCacheValueName(machineName)
    Dim instanceValueName: instanceValueName = EscapeCacheValueName(instanceName)
    Dim paramsPath: paramsPath = &quot;SmartConnectParams&quot; &amp; &quot;\&quot; &amp; hostValueName &amp; &quot;\&quot; &amp; instanceValueName  
    Dim connectionStringPath: connectionStringPath = paramsPath &amp; &quot;\&quot; &amp; databaseName  
    connectionString = GetStringValueFromCache(connectionStringPath, &quot;TargetDataSource&quot;, cacheExpirationTime)
    Dim timeout: timeout = GetStringValueFromCache(paramsPath , &quot;ConnectionTimeout&quot;, cacheExpirationTime)
    Dim netBiosHostName: netBiosHostName = GetStringValueFromCache(&quot;SqlHostNames&quot;, hostValueName, cacheExpirationTime)

    If connectionString &lt;&gt; &quot;&quot; And timeout &lt;&gt; &quot;&quot; And netBiosHostName  &lt;&gt; &quot;&quot; Then
        lastError.Clear
        TryToConnectAndValidate cnADOConnection, connectionString, timeout, netBiosHostName, instanceName, True
        lastError.Save
        If lastError.Number = 0 Then
            SmartConnectIntent = True
            Exit Function
        Else
            errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
        End If
    End If


    Dim ds: Set ds = New DriverSelector

    Dim netBiosHostNameData: Set netBiosHostNameData = GetSqlServerHostNameEx(machineName, instanceName, SQL_WMI_NAMESPACE)
    lastError.Save

    If lastError.Number &lt;&gt; 0 Then
        GlobalErrorList.Add &quot;Cannot get target instance machine&apos;s NetBios host name.&quot; &amp;_ 
         &quot;Computer name: &quot; &amp; machineName &amp; vbNewLine &amp;_
         &quot;Error number: &quot; &amp; lastError.Number &amp; vbNewLine &amp;_
         &quot;Error description:&quot; &amp; lastError.Description
        Exit Function
    End If

    netBiosHostName = netBiosHostNameData.HostName
    Dim dnsHostName: dnsHostName = Split(machineName, &quot;.&quot;)(0)

    Dim enabledServerProtocols: enabledServerProtocols = GetEnabledSqlServerProtocols(SQL_WMI_NAMESPACE, netBiosHostName, instanceName)
    If Not HandleErrorContinueEx(&quot;Cannot get a list of enabled Sql Server protocols&quot;, instanceName) Then
        Exit Function
    End If

    ds.ProcessDrivers(enabledServerProtocols)
    Dim selectedDriverName: selectedDriverName = ds.DriverName
    Dim useFqdn: useFqdn = ds.UseFqdn
    Dim hasErrors: hasErrors = ds.HasErrors

    Dim connStr: connStr = inputDataSource

    Call Err.Clear()

    &apos; Sql Server Shared Memory protocol require usage of host&apos;s NetBios name.
    &apos; Shared Memory usually the first in the driver&apos;s priority list.
    &apos; Rebuild data source string in the case of standalone Sql Server instance, NetBios host name differs 
    &apos; from DNS host name and enabled Shared Memory on Client and Server

    If netBiosHostName &lt;&gt; dnsHostName And Not netBiosHostNameData.IsClustered And ArrayContains(enabledServerProtocols, &quot;sm&quot;) And ds.ClientSharedMemoryProtocolEnabled Then
        Dim localHostName: localHostName = GetLocalHostName()
        If Not HandleErrorContinue(&quot;Cannot get local machine&apos;s NetBios name&quot;) Then
            Exit Function
        End If
        If netBiosHostName = localHostName Then
            connStr = &quot;lpc:&quot; &amp; BuildDataSourceFromParts(netBiosHostName, instanceName, &quot;&quot;)
        End If
    End If

    &apos;Connect using Sql Browser
    dataSource = GetDataSource(connStr, &quot;&quot;)
    connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
    lastError.Clear
    TryToConnectAndValidate cnADOConnection, connectionString, 15, netBiosHostName, instanceName, True
    lastError.Save
    If lastError.Number = 0 Then
        SmartConnectIntent = True
        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 15)
        Exit Function
    Else
        errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
    End If
	
    &apos;Try to connect through tcp/ip protocol only if it is enabled
    If ArrayContains(enabledServerProtocols, &quot;tcp&quot;) And ds.ClientTcpProtocolEnabled Then
        Dim dsComputerName: dsComputerName = Split(inputDataSource, &quot;\&quot;)(0)
        Dim tcpIpSettings : Set tcpIpSettings = GetSqlServerTcpIpSettings(instanceName, dsComputerName)
	
        If useFqdn Then
            targetName = machineName
        Else
            targetName = dsComputerName
        End if

        Dim ip, port
	
	    &apos;Use ports configured for all interfaces
        If tcpIpSettings.ListenAllIPs Then
            For Each port In tcpIpSettings.IpSettings.item(&quot;IPAll&quot;)
                dataSource = GetDataSource(targetName, port)
                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
                lastError.Clear
                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
                lastError.Save
                If lastError.Number = 0 Then
                    SmartConnectIntent = True
                    Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                    Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
                    Exit Function
                Else
                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
                End If
            Next
        Else
            &apos;Use one port from each interface
    	    Dim upc : Set upc = (new UniqueCollection)()
            For Each ip In tcpIpSettings.IpSettings.Keys
        	    port = tcpIpSettings.IpSettings.Item(ip)(0)
        	    If Not upc.Exists(port) Then
        		    upc.PutItem port 	
	                dataSource = GetDataSource(targetName, port)
	                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
	                lastError.Clear
	                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
	                lastError.Save
	                If lastError.Number = 0 Then
	                    SmartConnectIntent = True
                        Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                        Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
	                    Exit Function
	                Else
	                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError)
	                End If
	            End If
            Next
            &apos;Go through all interfaces and ports
            If Not useFqdn Then
        	    For Each ip In tcpIpSettings.IpSettings.Keys 
        		    For Each port In tcpIpSettings.IpSettings.Item(ip)     	
		                dataSource = GetDataSource(ip, port)
		                connectionString = GetConnectionString(selectedDriverName, dataSource, databaseName, intent)
		                lastError.Clear
		                TryToConnectAndValidate cnADOConnection, connectionString, 10, netBiosHostName, instanceName, True
		                lastError.Save
		                If lastError.Number = 0 Then
		                    SmartConnectIntent = True
                            Call PutStringValueToCache(connectionStringPath, &quot;TargetDataSource&quot;, connectionString)
                            Call PutStringValueToCache(paramsPath, &quot;ConnectionTimeout&quot;, 10)
		                    Exit Function
		                Else
		                    errorMessageList.Add FormatConnectionErrorMessage(dataSource, lastError) 
		                End If
		    	    Next
        	    Next
            End If
        End If
    End If
    GlobalErrorList.Add &quot;Cannot connect to the target Sql Server instance. Connection log:&quot; &amp; vbNewLine &amp; Join(errorMessageList.ItemsArray, vbNewLine)
End Function

Function ExtractHostNameFromEndpoint(ByVal sEndpoint)
    If sEndpoint = &quot;&quot; Then
        ExtractHostNameFromEndpoint = &quot;&quot;
        Exit Function
    End If
    Dim oRegEx, oMatches
    Set oRegEx = MomCreateObject(&quot;VBScript.RegExp&quot;)
    oRegEx.Pattern = &quot;://(.+):&quot;
    Set oMatches = oRegEx.Execute(sEndpoint)
    If oMatches.Count &gt; 0 Then
        If oMatches(0).SubMatches.Count &gt; 0 Then
            ExtractHostNameFromEndpoint = oMatches(0).SubMatches(0)
        Else
            ExtractHostNameFromEndpoint = sEndpoint
        End If
    Else
        ExtractHostNameFromEndpoint = sEndpoint
    End If
End Function

Function GetMirroringLevelName(ByVal nSafetyLevel, ByVal sWitnessName)
    GetMirroringLevelName = &quot;Unknown state&quot;
    If nSafetyLevel = 1 Then
        GetMirroringLevelName = &quot;High-performance mode&quot;
    Else
        If sWitnessName = &quot;&quot; Then
            GetMirroringLevelName = &quot;High-safety mode without automatic failover&quot;
        Else
            GetMirroringLevelName = &quot;High-safety mode with automatic failover&quot;
        End If
    End If
End Function

Function IsExcluded(ByVal sDatabase, ByVal sExcludeList)
	Dim aExcludes, bMatch, nIndex

	bMatch = False
	If Trim(sExcludeList) = &quot;*&quot; Then
	    bMatch = True
	Else
		aExcludes = Split(sExcludeList, &quot;,&quot;)
		For nIndex = 0 To UBound(aExcludes)
			If LCase(sDatabase) = LCase(Trim(aExcludes(nIndex))) Then
				bMatch = True
			End If
		Next
	End If
	IsExcluded = bMatch
End Function

Function DoWitnessDiscovery()
    If Len(ExcludeList) &lt; 0 Then 
        WriteToEventLogAndExit(&quot;Database exclusion list invalid in Mirroring Witness Discovery. Aborting discovery.&quot;)
    End If

	Dim e
	Set e = New Error

    Dim cnADOConnection
    Set cnADOConnection = SmartConnectWithoutSQLADODB(ConnectionString, sTcpPort, TargetComputer, InstanceName, &quot;master&quot;)
    if cnADOConnection Is Nothing Then
        DoWitnessDiscovery = SQL_DISCOVERY_CONNECT_FAILURE
        Exit Function
    End If
	    
    &apos; Query for the list of mirrored databases
    Dim oResults
	e.Clear
	On Error Resume Next
		Set oResults = cnADOConnection.Execute(GetMirroredDatabasesQuery)
		e.Save
	On Error Goto 0
	If e.Number &lt;&gt; 0 Then
        DoWitnessDiscovery = SQL_DISCOVERY_QUERY_FAILURE
        ThrowScriptErrorNoAbort &quot;Query execution failed&quot;, e
        Exit Function
	End If

    Dim bWitnessRoleCreated, oWitnessRole
    bWitnessRoleCreated = False
    Dim oWitnessInstance, oMirroringGroup, oRelationship
    Dim sDBName, sMirroringGUID, sPrincipalInstance, sMirrorInstance, nState, nSafetyLevel
	Do While Not oResults.EOF
		sDBName = oResults(0)

		If Not(IsExcluded(sDBName, ExcludeList)) Then 
            sMirroringGUID = oResults(1)
            sPrincipalInstance = oResults(2)
            sMirrorInstance = oResults(3)
            nState = oResults(4)
            nSafetyLevel = oResults(5)

            If Not bWitnessRoleCreated Then
                Set oWitnessRole = oDiscoveryData.CreateClassInstance(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.WitnessRole&apos;]$&quot;)
                With oWitnessRole
                    .AddProperty &quot;$MPElement[Name=&apos;System!System.Entity&apos;]/DisplayName$&quot;, &quot;Witness Role&quot;

				    .AddProperty &quot;$MPElement[Name=&apos;MSCL!Microsoft.SQLServer.Core.DBEngine&apos;]/MachineName$&quot;, TargetComputer
				    .AddProperty &quot;$MPElement[Name=&apos;MSCL!Microsoft.SQLServer.Core.DBEngine&apos;]/InstanceName$&quot;, InstanceName
                End With
          	    Call oDiscoveryData.AddInstance(oWitnessRole)
                bWitnessRoleCreated = True
            End If

			Set oWitnessInstance = oDiscoveryData.CreateClassInstance(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Witness&apos;]$&quot;)
			With oWitnessInstance
                .AddProperty &quot;$MPElement[Name=&apos;System!System.Entity&apos;]/DisplayName$&quot;, &quot;Witness for &apos;&quot; &amp; sDBName &amp; &quot;&apos; database&quot;

				.AddProperty &quot;$MPElement[Name=&apos;MSCL!Microsoft.SQLServer.Core.DBEngine&apos;]/MachineName$&quot;, TargetComputer
				.AddProperty &quot;$MPElement[Name=&apos;MSCL!Microsoft.SQLServer.Core.DBEngine&apos;]/InstanceName$&quot;, InstanceName
				.AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Witness&apos;]/MirroringGUID$&quot;, sMirroringGUID

                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Witness&apos;]/DatabaseName$&quot;, sDBName
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Witness&apos;]/Principal$&quot;, ExtractHostNameFromEndpoint(sPrincipalInstance)
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Witness&apos;]/Mirror$&quot;, ExtractHostNameFromEndpoint(sMirrorInstance)
                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Witness&apos;]/Level$&quot;, GetMirroringLevelName(nSafetyLevel, ConnectionString)
			End With
          	Call oDiscoveryData.AddInstance(oWitnessInstance)

            Set oMirroringGroup = oDiscoveryData.CreateClassInstance(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]$&quot;)
            With oMirroringGroup
                .AddProperty &quot;$MPElement[Name=&apos;System!System.Entity&apos;]/DisplayName$&quot;, &quot;&apos;&quot; &amp; sDBName &amp; &quot;&apos; database mirror&quot;

                .AddProperty &quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.Group&apos;]/MirroringGUID$&quot;, sMirroringGUID
            End With
            Call oDiscoveryData.AddInstance(oMirroringGroup)

            Set oRelationship = oDiscoveryData.CreateRelationshipInstance(&quot;$MPElement[Name=&apos;Microsoft.SQLServer.Windows.Mirroring.GroupContainsWitness&apos;]$&quot;)
            oRelationship.Source = oMirroringGroup
            oRelationship.Target = oWitnessInstance
            Call oDiscoveryData.AddInstance(oRelationship)
	    End If
		oResults.MoveNext
	Loop

	Set oResults = Nothing
	cnADOConnection.Close
	DoWitnessDiscovery = SQL_DISCOVERY_SUCCESS
End Function
&apos; End of Script
</ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </DataSource>
            </MemberModules>
            <Composition>
              <Node ID="DS" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.Discovery.Data</OutputType>
      </DataSourceModuleType>
    </ModuleTypes>
    <MonitorTypes>
      <UnitMonitorType ID="Microsoft.SQLServer.Windows.Mirroring.ScriptedThreeStateType.MonitorType" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="Good" NoDetection="false" />
          <MonitorTypeState ID="NeitherGoodNorBad" NoDetection="false" />
          <MonitorTypeState ID="Bad" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ConnectionString" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MachineName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TcpPorts" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Version" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="ScriptBody" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	
          <xsd:element name="GoodExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="NeitherGoodNorBadExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="BadExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Microsoft.SQLServer.Windows.Mirroring.ScriptedStateProvider.DS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <ScriptName>$Config/ScriptName$</ScriptName>
              <ConnectionString>$Config/ConnectionString$</ConnectionString>
              <MachineName>$Config/MachineName$</MachineName>
              <InstanceName>$Config/InstanceName$</InstanceName>
              <TcpPorts>$Config/TcpPorts$</TcpPorts>
              <Version>$Config/Version$</Version>
              <ScriptBody>$Config/ScriptBody$</ScriptBody>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </DataSource>
            <ConditionDetection ID="FilterGood" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/GoodExpression$</Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterNeitherGoodNorBad" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/NeitherGoodNorBadExpression$</Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterBad" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/BadExpression$</Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Good">
              <Node ID="FilterGood">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="NeitherGoodNorBad">
              <Node ID="FilterNeitherGoodNorBad">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Bad">
              <Node ID="FilterBad">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Microsoft.SQLServer.Windows.Mirroring.ScriptedTwoStateType.MonitorType" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="Good" NoDetection="false" />
          <MonitorTypeState ID="Bad" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="IntervalSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="SyncTime" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ScriptName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ConnectionString" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MachineName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	
          <xsd:element name="InstanceName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TcpPorts" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Version" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />		  
          <xsd:element name="ScriptBody" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	 
          <xsd:element name="GoodExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="BadExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Microsoft.SQLServer.Windows.Mirroring.ScriptedStateProvider.DSTwoLevelHostTcp.DS">
              <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
              <SyncTime>$Config/SyncTime$</SyncTime>
              <ScriptName>$Config/ScriptName$</ScriptName>
              <ConnectionString>$Config/ConnectionString$</ConnectionString>
              <MachineName>$Config/MachineName$</MachineName>
              <InstanceName>$Config/InstanceName$</InstanceName>
              <TcpPorts>$Config/TcpPorts$</TcpPorts>
              <Version>$Config/Version$</Version>
              <ScriptBody>$Config/ScriptBody$</ScriptBody>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </DataSource>
            <ConditionDetection ID="FilterGood" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/GoodExpression$</Expression>
            </ConditionDetection>
            <ConditionDetection ID="FilterBad" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/BadExpression$</Expression>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="Good">
              <Node ID="FilterGood">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="Bad">
              <Node ID="FilterBad">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
        </MonitorImplementation>
      </UnitMonitorType>
    </MonitorTypes>
  </TypeDefinitions>
  <Monitoring>
    <Discoveries>
      <Discovery ID="Microsoft.SQLServer.Windows.Mirroring.Database.Discovery" Enabled="true" Target="MSWD!Microsoft.SQLServer.Windows.DBEngine" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Microsoft.SQLServer.Windows.Mirroring.Database">
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Database" PropertyID="MirroringGUID" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Database" PropertyID="MirroringRole" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Database" PropertyID="Level" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Database" PropertyID="Partner" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Database" PropertyID="Witness" />
          </DiscoveryClass>
          <DiscoveryClass TypeID="Microsoft.SQLServer.Windows.Mirroring.Group">
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Group" PropertyID="MirroringGUID" />
          </DiscoveryClass>
          <DiscoveryRelationship TypeID="Microsoft.SQLServer.Windows.Mirroring.GroupContainsDatabase" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Microsoft.SQLServer.Windows.Mirroring.Database.DiscoveryProvider.DS">
          <IntervalSeconds>86400</IntervalSeconds>
          <SyncTime />
          <MachineName>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/MachineName$</MachineName>
          <ConnectionString>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/ConnectionString$</ConnectionString>
          <InstanceName>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/InstanceName$</InstanceName>
          <Version>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/Version$</Version>		  
          <ExcludeList />
          <TcpPorts>$Target/Property[Type="MSWD!Microsoft.SQLServer.Windows.DBEngine"]/TcpPorts$</TcpPorts>			  
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Microsoft.SQLServer.Windows.Mirroring.PrincipalToMirrorReference.Discovery" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Group" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Microsoft.SQLServer.Windows.Mirroring.PrincipalReferencesMirror" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Microsoft.SQLServer.Windows.Mirroring.PrincipalToMirrorReference.DiscoveryProvider.DS">
          <IntervalSeconds>86400</IntervalSeconds>
          <SyncTime />
          <PrincipalComputerName>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Group"]/PrincipalComputerName$</PrincipalComputerName>
          <PrincipalInstanceName>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Group"]/PrincipalInstanceName$</PrincipalInstanceName>
          <MirrorComputerName>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Group"]/MirrorComputerName$</MirrorComputerName>
          <MirrorInstanceName>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Group"]/MirrorInstanceName$</MirrorInstanceName>
          <DatabaseName>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Group"]/DatabaseName$</DatabaseName>
        </DataSource>
      </Discovery>
      <Discovery ID="Microsoft.SQLServer.Windows.Mirroring.Witness.Discovery" Enabled="true" Target="MSWD!Microsoft.SQLServer.Windows.DBEngine" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryClass TypeID="Microsoft.SQLServer.Windows.Mirroring.Witness">
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Witness" PropertyID="MirroringGUID" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Witness" PropertyID="DatabaseName" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Witness" PropertyID="Principal" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Witness" PropertyID="Mirror" />
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Witness" PropertyID="Level" />
          </DiscoveryClass>
          <DiscoveryClass TypeID="Microsoft.SQLServer.Windows.Mirroring.Group">
            <Property TypeID="Microsoft.SQLServer.Windows.Mirroring.Group" PropertyID="MirroringGUID" />
          </DiscoveryClass>
          <DiscoveryRelationship TypeID="Microsoft.SQLServer.Windows.Mirroring.GroupContainsWitness" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="Microsoft.SQLServer.Windows.Mirroring.Witness.DiscoveryProvider.DS">
          <IntervalSeconds>86400</IntervalSeconds>
          <SyncTime />
          <MachineName>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/MachineName$</MachineName>
          <ConnectionString>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/ConnectionString$</ConnectionString>
          <InstanceName>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/InstanceName$</InstanceName>
          <Version>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/Version$</Version>			  
          <ExcludeList />
          <TcpPorts>$Target/Property[Type="MSWD!Microsoft.SQLServer.Windows.DBEngine"]/TcpPorts$</TcpPorts>		  
          <TimeoutSeconds>300</TimeoutSeconds>
        </DataSource>
      </Discovery>
      <Discovery ID="Microsoft.SQLServer.Windows.Mirroring.Service.Discovery" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Service" ConfirmDelivery="true" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="Microsoft.SQLServer.Windows.Mirroring.ServiceContainsGroup" />
        </DiscoveryTypes>
        <DataSource ID="DS" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$Target/Id$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="Microsoft.SQLServer.Windows.Mirroring.Group"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="Microsoft.SQLServer.Windows.Mirroring.ServiceContainsGroup"]$</RelationshipClass>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
    </Discoveries>
    <Monitors>
      <UnitMonitor ID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Database" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RunAs="MSCL!Microsoft.SQLServer.Core.RunAs.Monitoring" TypeID="Microsoft.SQLServer.Windows.Mirroring.ScriptedThreeStateType.MonitorType" ConfirmDelivery="false">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/InstanceName$</AlertParameter2>
            <AlertParameter3>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/MachineName$</AlertParameter3>
            <AlertParameter4>$Data/Context/Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']$</AlertParameter4>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Good" MonitorTypeStateID="Good" HealthState="Success" />
          <OperationalState ID="NeitherGoodNorBad" MonitorTypeStateID="NeitherGoodNorBad" HealthState="Warning" />
          <OperationalState ID="Bad" MonitorTypeStateID="Bad" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>901</IntervalSeconds>
          <SyncTime />		
          <ScriptName>Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor.vbs</ScriptName>
          <ConnectionString>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/ConnectionString$</ConnectionString>		  
          <MachineName>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/MachineName$</MachineName>
          <InstanceName>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/InstanceName$</InstanceName>
          <TcpPorts>$Target/Host/Property[Type="MSWD!Microsoft.SQLServer.Windows.DBEngine"]/TcpPorts$</TcpPorts>
          <Version>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/Version$</Version>		
          <ScriptBody>'#Include File:Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor.vbs
'Copyright (c) Microsoft Corporation. All rights reserved.
' This script takes a single parameter
' Param 0: The SQL connection string to connect to

Const SQL_MONITORING_CONNECT_FAILURE = -1
Const SQL_MONITORING_QUERY_FAILURE = -2
Const SQL_MONITORING_SUCCESS = 0

Const SCRIPT_EVENT_ID = 4211

Dim GetDatabasesStatusQuery
GetDatabasesStatusQuery = "SELECT " &amp;_
                                " d.name, " &amp;_
                                " dm.mirroring_state_desc " &amp;_
                            " FROM sys.databases d " &amp;_
                                " INNER JOIN sys.database_mirroring dm ON dm.database_id = d.database_id " &amp;_
                            " WHERE dm.mirroring_guid IS NOT NULL"

Call GetDBHealth()

&apos;Log script event for completion
EndTime = Now
sTime = DateDiff("s", StartTime, EndTime)
Call oAPI.LogScriptEvent("Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor.vbs", 4005, 0, "Ending script.  Script runtime in seconds: " &amp; sTime)


Sub GetDBHealth()
    If WScript.Arguments.Count = 5 Then
        Dim oBag
	    Set oBag = oAPI.CreatePropertyBag()
        
        Dim state, serviceName

        serviceName = GetSQLServiceName(WScript.Arguments(2))
        state = GetServiceState(WScript.Arguments(1), serviceName)

        if (state &lt;&gt; "Running") And (state &lt;&gt; "Unknown") Then
            Call oAPI.Return(oBag)
            WScript.Quit() 
        End If

        Dim nResult
	    nResult = DBHealth(WScript.Arguments(0), oBag, WScript.Arguments(1), WScript.Arguments(2), WScript.Arguments(3))
        Call oAPI.Return(oBag)
        Call GlobalErrorListToEventLog()
    Else
        Wscript.Quit()
    End If
End Sub

Function DBHealth(ByVal sSQLConnectionString, ByRef oBag, ByVal sComputerName, ByVal sInstanceName, ByVal sTcpPort)
	Dim e
	Set e = New Error

    Dim cnADOConnection
    Set cnADOConnection = SmartConnectWithoutSQLADODB(sSQLConnectionString, sTcpPort, sComputerName, sInstanceName, "master")
    if cnADOConnection Is Nothing Then
		DBHealth = SQL_MONITORING_CONNECT_FAILURE
        Exit Function
    End If
	    
    Dim oResults
	e.Clear
	On Error Resume Next
		Set oResults = cnADOConnection.Execute(GetDatabasesStatusQuery)
		e.Save
	On Error Goto 0
	If e.Number &lt;&gt; 0 Then
		DBHealth = SQL_MONITORING_QUERY_FAILURE
        ThrowScriptErrorNoAbort "Query execution failed", e
		If (oResults &lt;&gt; null) Then oResults.Close
        cnADOConnection.Close
		Exit Function
	End If

	Do While Not oResults.EOF
		Call oBag.AddValue(oResults(0) &amp; "-State", CStr(oResults(1)))
		oResults.MoveNext
	Loop
	
	cnADOConnection.Close
    DBHealth = SQL_MONITORING_SUCCESS
End Function
</ScriptBody>
          <TimeoutSeconds>300</TimeoutSeconds>
          <GoodExpression>
            <SimpleExpression>
              <ValueExpression>
                <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
              </ValueExpression>
              <Operator>Equal</Operator>
              <ValueExpression>
                <Value Type="String">SYNCHRONIZED</Value>
              </ValueExpression>
            </SimpleExpression>
          </GoodExpression>
          <NeitherGoodNorBadExpression>
            <Or>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">SYNCHRONIZING</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">UNSYNCHRONIZED</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">PENDING_FAILOVER</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">SUSPENDED</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </Or>
          </NeitherGoodNorBadExpression>
          <BadExpression>
            <SimpleExpression>
              <ValueExpression>
                <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
              </ValueExpression>
              <Operator>Equal</Operator>
              <ValueExpression>
                <Value Type="String">DISCONNECTED</Value>
              </ValueExpression>
            </SimpleExpression>
          </BadExpression>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Database" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RunAs="MSCL!Microsoft.SQLServer.Core.RunAs.Monitoring" TypeID="Microsoft.SQLServer.Windows.Mirroring.ScriptedThreeStateType.MonitorType" ConfirmDelivery="false">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$</AlertParameter1>
            <AlertParameter2>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/InstanceName$</AlertParameter2>
            <AlertParameter3>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/MachineName$</AlertParameter3>
            <AlertParameter4>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Database"]/Witness$</AlertParameter4>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Good" MonitorTypeStateID="Good" HealthState="Success" />
          <OperationalState ID="NeitherGoodNorBad" MonitorTypeStateID="NeitherGoodNorBad" HealthState="Warning" />
          <OperationalState ID="Bad" MonitorTypeStateID="Bad" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>901</IntervalSeconds>
          <SyncTime />		
          <ScriptName>Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor.vbs</ScriptName>
          <ConnectionString>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/ConnectionString$</ConnectionString>
          <MachineName>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/MachineName$</MachineName>
          <InstanceName>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/InstanceName$</InstanceName>
          <TcpPorts>$Target/Host/Property[Type="MSWD!Microsoft.SQLServer.Windows.DBEngine"]/TcpPorts$</TcpPorts>
          <Version>$Target/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/Version$</Version>		  
          <ScriptBody>'#Include File:Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor.vbs
'Copyright (c) Microsoft Corporation. All rights reserved.
' This script takes a single parameter
' Param 0: The SQL connection string to connect to

Const SQL_MONITORING_CONNECT_FAILURE = -1
Const SQL_MONITORING_QUERY_FAILURE = -2
Const SQL_MONITORING_SUCCESS = 0

Const SCRIPT_EVENT_ID = 4211

Dim GetWitnessStatusQuery
GetWitnessStatusQuery = "SELECT " &amp;_
                            " d.name, " &amp;_
                            " CASE WHEN dm.mirroring_witness_name = '' THEN 'NO-WITNESS' ELSE ISNULL(dm.mirroring_witness_state_desc, 'UNKNOWN') END " &amp;_
                        " FROM sys.databases d " &amp;_
                            " INNER JOIN sys.database_mirroring dm ON dm.database_id = d.database_id " &amp;_
                        " WHERE dm.mirroring_guid IS NOT NULL"

Call GetWitnessAccessibility()

&apos;Log script event for completion
EndTime = Now
sTime = DateDiff("s", StartTime, EndTime)
Call oAPI.LogScriptEvent("Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor.vbs", 4005, 0, "Ending script.  Script runtime in seconds: " &amp; sTime)


Sub GetWitnessAccessibility()
    If WScript.Arguments.Count = 5 Then
        Dim oBag
	    Set oBag = oAPI.CreatePropertyBag()
        
        Dim state, serviceName

        serviceName = GetSQLServiceName(WScript.Arguments(2))
        state = GetServiceState(WScript.Arguments(1), serviceName)

        if (state &lt;&gt; "Running") And (state &lt;&gt; "Unknown") Then
            Call oAPI.Return(oBag)
            WScript.Quit() 
        End If

	    Dim nResult
	    nResult = WitnessAccessibility(WScript.Arguments(0), oBag, WScript.Arguments(1), WScript.Arguments(2), WScript.Arguments(3))
		Call oAPI.Return(oBag)
        Call GlobalErrorListToEventLog()
    Else
        Wscript.Quit()
    End If
End Sub

Function WitnessAccessibility(ByVal sSQLConnectionString, ByRef oBag, ByVal sComputerName, ByVal sInstanceName, ByVal sTcpPort)
	Dim e
	Set e = New Error

    Dim cnADOConnection
    Set cnADOConnection = SmartConnectWithoutSQLADODB(sSQLConnectionString, sTcpPort, sComputerName, sInstanceName, "master")
    if cnADOConnection Is Nothing Then
		WitnessAccessibility = SQL_MONITORING_CONNECT_FAILURE
        Exit Function
    End If
	    
    Dim oResults
	e.Clear
	On Error Resume Next
		Set oResults = cnADOConnection.Execute(GetWitnessStatusQuery)
		e.Save
	On Error Goto 0
	If e.Number &lt;&gt; 0 Then
		WitnessAccessibility = SQL_MONITORING_QUERY_FAILURE
        ThrowScriptErrorNoAbort "Query execution failed", e
		If (oResults &lt;&gt; null) Then oResults.Close
        cnADOConnection.Close
		Exit Function
	End If

	Do While Not oResults.EOF
		Call oBag.AddValue(oResults(0) &amp; "-State", CStr(oResults(1)))
		oResults.MoveNext
	Loop
	
	cnADOConnection.Close
    WitnessAccessibility = SQL_MONITORING_SUCCESS
End Function
</ScriptBody>
          <TimeoutSeconds>300</TimeoutSeconds>
          <GoodExpression>
            <Or>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">CONNECTED</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">NO-WITNESS</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </Or>
          </GoodExpression>
          <NeitherGoodNorBadExpression>
            <SimpleExpression>
              <ValueExpression>
                <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
              </ValueExpression>
              <Operator>Equal</Operator>
              <ValueExpression>
                <Value Type="String">UNKNOWN</Value>
              </ValueExpression>
            </SimpleExpression>
          </NeitherGoodNorBadExpression>
          <BadExpression>
            <SimpleExpression>
              <ValueExpression>
                <XPathQuery Type="String">Property[@Name='$Target/Property[Type="MSCL!Microsoft.SQLServer.Core.Database"]/DatabaseName$-State']</XPathQuery>
              </ValueExpression>
              <Operator>Equal</Operator>
              <ValueExpression>
                <Value Type="String">DISCONNECTED</Value>
              </ValueExpression>
            </SimpleExpression>
          </BadExpression>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Witness" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RunAs="MSCL!Microsoft.SQLServer.Core.RunAs.Monitoring" TypeID="Microsoft.SQLServer.Windows.Mirroring.ScriptedTwoStateType.MonitorType" ConfirmDelivery="false">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>Error</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Witness"]/DatabaseName$</AlertParameter1>
            <AlertParameter2>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Witness"]/Principal$</AlertParameter2>
            <AlertParameter3>$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Witness"]/Mirror$</AlertParameter3>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Good" MonitorTypeStateID="Good" HealthState="Success" />
          <OperationalState ID="Bad" MonitorTypeStateID="Bad" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>901</IntervalSeconds>
          <SyncTime />		
          <ScriptName>Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor.vbs</ScriptName>
          <ConnectionString>$Target/Host/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/ConnectionString$</ConnectionString>		  
          <MachineName>$Target/Host/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/MachineName$</MachineName>
          <InstanceName>$Target/Host/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/InstanceName$</InstanceName>
          <TcpPorts>$Target/Host/Host/Property[Type="MSWD!Microsoft.SQLServer.Windows.DBEngine"]/TcpPorts$</TcpPorts>
          <Version>$Target/Host/Host/Property[Type="MSCL!Microsoft.SQLServer.Core.DBEngine"]/Version$</Version>
          <ScriptBody>'#Include File:Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor.vbs
'Copyright (c) Microsoft Corporation. All rights reserved.
' This script takes a single parameter
' Param 0: The SQL connection string to connect to

Const SQL_MONITORING_CONNECT_FAILURE = -1
Const SQL_MONITORING_QUERY_FAILURE = -2
Const SQL_MONITORING_SUCCESS = 0

Const SCRIPT_EVENT_ID = 4211

Dim GetPartnersStatusQuery
GetPartnersStatusQuery = "SELECT " &amp;_
                            " mirroring_guid, " &amp;_
                            " partner_sync_state_desc " &amp;_
                        " FROM sys.database_mirroring_witnesses "

Call GetPartnersStatus()

&apos;Log script event for completion
EndTime = Now
sTime = DateDiff("s", StartTime, EndTime)
Call oAPI.LogScriptEvent("Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor.vbs", 4006, 0, "Ending script.  Script runtime in seconds: " &amp; sTime)


Sub GetPartnersStatus()
    If WScript.Arguments.Count = 5 Then
        Dim oBag
	    Set oBag = oAPI.CreatePropertyBag()
        
        Dim state, serviceName

        serviceName = GetSQLServiceName(WScript.Arguments(2))
        state = GetServiceState(WScript.Arguments(1), serviceName)

        if (state &lt;&gt; "Running") And (state &lt;&gt; "Unknown") Then
            Call oAPI.Return(oBag)
            WScript.Quit() 
        End If

	    Dim nResult
	    nResult = PartnersStatus(WScript.Arguments(0), oBag, WScript.Arguments(1), WScript.Arguments(2), WScript.Arguments(3))
        Call oAPI.Return(oBag)
        Call GlobalErrorListToEventLog()
    Else
        Wscript.Quit()
    End If
End Sub

Function PartnersStatus(ByVal sSQLConnectionString, ByRef oBag, ByVal sComputerName, ByVal sInstanceName, ByVal sTcpPort)
	Dim e
	Set e = New Error

    Dim cnADOConnection
    Set cnADOConnection = SmartConnectWithoutSQLADODB(sSQLConnectionString, sTcpPort, sComputerName, sInstanceName, "master")
    if cnADOConnection Is Nothing Then
		PartnersStatus = SQL_MONITORING_CONNECT_FAILURE
        Exit Function
    End If
    	    
    Dim oResults
	e.Clear
	On Error Resume Next
		Set oResults = cnADOConnection.Execute(GetPartnersStatusQuery)
		e.Save
	On Error Goto 0
	If e.Number &lt;&gt; 0 Then
		PartnersStatus = SQL_MONITORING_QUERY_FAILURE
        ThrowScriptErrorNoAbort "Query execution failed", e
		If (oResults &lt;&gt; null) Then oResults.Close
        cnADOConnection.Close
		Exit Function
	End If

	Do While Not oResults.EOF
		Call oBag.AddValue(oResults(0), CStr(oResults(1)))
		oResults.MoveNext
	Loop
	
	cnADOConnection.Close
    PartnersStatus = SQL_MONITORING_SUCCESS
End Function
</ScriptBody>
          <TimeoutSeconds>300</TimeoutSeconds>
          <GoodExpression>
            <SimpleExpression>
              <ValueExpression>
                <XPathQuery Type="String">Property[@Name='$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Witness"]/MirroringGUID$']</XPathQuery>
              </ValueExpression>
              <Operator>Equal</Operator>
              <ValueExpression>
                <Value Type="String">IN_SYNC</Value>
              </ValueExpression>
            </SimpleExpression>
          </GoodExpression>
          <BadExpression>
            <SimpleExpression>
              <ValueExpression>
                <XPathQuery Type="String">Property[@Name='$Target/Property[Type="Microsoft.SQLServer.Windows.Mirroring.Witness"]/MirroringGUID$']</XPathQuery>
              </ValueExpression>
              <Operator>Equal</Operator>
              <ValueExpression>
                <Value Type="String">OUT_OF_SYNC</Value>
              </ValueExpression>
            </SimpleExpression>
          </BadExpression>
        </Configuration>
      </UnitMonitor>
      <DependencyMonitor ID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.AvailabilityRollup" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Group" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Microsoft.SQLServer.Windows.Mirroring.GroupContainsDatabase" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
      <DependencyMonitor ID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.ConfigurationRollup" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Group" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" RelationshipType="Microsoft.SQLServer.Windows.Mirroring.GroupContainsDatabase" MemberMonitor="Health!System.Health.ConfigurationState">
        <Category>ConfigurationHealth</Category>
        <Algorithm>WorstOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
      <DependencyMonitor ID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.PerformanceRollup" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Group" ParentMonitorID="Health!System.Health.PerformanceState" Remotable="true" Priority="Normal" RelationshipType="Microsoft.SQLServer.Windows.Mirroring.GroupContainsDatabase" MemberMonitor="Health!System.Health.PerformanceState">
        <Category>PerformanceHealth</Category>
        <Algorithm>WorstOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
      <DependencyMonitor ID="Microsoft.SQLServer.Windows.Mirroring.WitnessToGroup.AvailabilityRollup" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Group" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Microsoft.SQLServer.Windows.Mirroring.GroupContainsWitness" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
      <DependencyMonitor ID="Microsoft.SQLServer.Windows.Mirroring.WitnessToWitnessRole.AvailabilityRollup" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.WitnessRole" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" RelationshipType="Microsoft.SQLServer.Windows.Mirroring.WitnessRoleHostsWitness" MemberMonitor="Health!System.Health.AvailabilityState">
        <Category>AvailabilityHealth</Category>
        <Algorithm>WorstOf</Algorithm>
        <MemberUnAvailable>Error</MemberUnAvailable>
      </DependencyMonitor>
    </Monitors>
  </Monitoring>
  <Presentation>
    <Views>
      <View ID="Microsoft.SQLServer.Windows.Mirroring.Alert.View" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Service" TypeID="SC!Microsoft.SystemCenter.AlertViewType" Visible="true">
        <Category>Operations</Category>
        <Criteria>
          <ResolutionState>
            <State>0</State>
          </ResolutionState>
        </Criteria>
        <Presentation>
          <ColumnInfo Index="0" SortIndex="0" Width="22" Grouped="true" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Severity</Name>
            <Id>Severity</Id>
          </ColumnInfo>
          <ColumnInfo Index="1" SortIndex="-1" Width="54" Grouped="false" Sorted="false" IsSortable="false" Visible="true" SortOrder="Ascending">
            <Name>Icon</Name>
            <Id>Icon</Id>
          </ColumnInfo>
          <ColumnInfo Index="2" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Path</Name>
            <Id>MonitoringObjectPath</Id>
          </ColumnInfo>
          <ColumnInfo Index="3" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Source</Name>
            <Id>MonitoringObjectDisplayName</Id>
          </ColumnInfo>
          <ColumnInfo Index="4" SortIndex="-1" Width="22" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Maintenance Mode</Name>
            <Id>MonitoringObjectInMaintenanceMode</Id>
          </ColumnInfo>
          <ColumnInfo Index="5" SortIndex="-1" Width="250" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Name</Name>
            <Id>Name</Id>
          </ColumnInfo>
          <ColumnInfo Index="6" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Resolution State</Name>
            <Id>ResolutionState</Id>
          </ColumnInfo>
          <ColumnInfo Index="7" SortIndex="1" Width="150" Grouped="false" Sorted="true" IsSortable="true" Visible="true" SortOrder="Descending">
            <Name>Created</Name>
            <Id>TimeRaised</Id>
          </ColumnInfo>
          <ColumnInfo Index="8" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Age</Name>
            <Id>Age</Id>
          </ColumnInfo>
          <ColumnInfo Index="9" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Type</Name>
            <Id>Category</Id>
          </ColumnInfo>
          <ColumnInfo Index="10" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Owner</Name>
            <Id>Owner</Id>
          </ColumnInfo>
          <ColumnInfo Index="11" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Priority</Name>
            <Id>Priority</Id>
          </ColumnInfo>
          <ColumnInfo Index="12" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Latency</Name>
            <Id>Latency</Id>
          </ColumnInfo>
          <ColumnInfo Index="13" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Description</Name>
            <Id>Description</Id>
          </ColumnInfo>
          <ColumnInfo Index="14" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Connector</Name>
            <Id>ConnectorId</Id>
          </ColumnInfo>
          <ColumnInfo Index="15" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Forwarding Status</Name>
            <Id>ConnectorStatus</Id>
          </ColumnInfo>
          <ColumnInfo Index="16" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Class</Name>
            <Id>Class</Id>
          </ColumnInfo>
          <ColumnInfo Index="17" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Time in State</Name>
            <Id>TimeInState</Id>
          </ColumnInfo>
          <ColumnInfo Index="18" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 1</Name>
            <Id>CustomField1</Id>
          </ColumnInfo>
          <ColumnInfo Index="19" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 2</Name>
            <Id>CustomField2</Id>
          </ColumnInfo>
          <ColumnInfo Index="20" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 3</Name>
            <Id>CustomField3</Id>
          </ColumnInfo>
          <ColumnInfo Index="21" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 4</Name>
            <Id>CustomField4</Id>
          </ColumnInfo>
          <ColumnInfo Index="22" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 5</Name>
            <Id>CustomField5</Id>
          </ColumnInfo>
          <ColumnInfo Index="23" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 6</Name>
            <Id>CustomField6</Id>
          </ColumnInfo>
          <ColumnInfo Index="24" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 7</Name>
            <Id>CustomField7</Id>
          </ColumnInfo>
          <ColumnInfo Index="25" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 8</Name>
            <Id>CustomField8</Id>
          </ColumnInfo>
          <ColumnInfo Index="26" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 9</Name>
            <Id>CustomField9</Id>
          </ColumnInfo>
          <ColumnInfo Index="27" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Custom Field 10</Name>
            <Id>CustomField10</Id>
          </ColumnInfo>
          <ColumnInfo Index="28" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Resolved By</Name>
            <Id>ResolvedBy</Id>
          </ColumnInfo>
          <ColumnInfo Index="29" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Time Resolved</Name>
            <Id>TimeResolved</Id>
          </ColumnInfo>
          <ColumnInfo Index="30" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Last State Change</Name>
            <Id>TimeResolutionStateLastModified</Id>
          </ColumnInfo>
          <ColumnInfo Index="31" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Last Modified</Name>
            <Id>LastModified</Id>
          </ColumnInfo>
          <ColumnInfo Index="32" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Last Modified By</Name>
            <Id>LastModifiedBy</Id>
          </ColumnInfo>
          <ColumnInfo Index="33" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Management Group</Name>
            <Id>ManagementGroup</Id>
          </ColumnInfo>
          <ColumnInfo Index="34" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Site</Name>
            <Id>SiteName</Id>
          </ColumnInfo>
          <ColumnInfo Index="35" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Repeat Count</Name>
            <Id>RepeatCount</Id>
          </ColumnInfo>
          <ColumnInfo Index="36" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Ticket ID</Name>
            <Id>TicketId</Id>
          </ColumnInfo>
        </Presentation>
      </View>
      <View ID="Microsoft.SQLServer.Windows.Mirroring.MirroringGroups.State.View" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Group" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
        <Criteria>
          <InMaintenanceMode>false</InMaintenanceMode>
        </Criteria>
        <Presentation>
          <ColumnInfo Index="0" SortIndex="0" Width="100" Grouped="false" Sorted="true" IsSortable="true" Visible="true" SortOrder="Descending">
            <Name>State</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group-*-fdd518b2-8b74-b38f-2705-338b0154b81b-*-Health</Id>
          </ColumnInfo>
          <ColumnInfo Index="1" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>In Maintenance Mode</Name>
            <Id>InMaintenanceMode</Id>
          </ColumnInfo>
          <ColumnInfo Index="2" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Name</Name>
            <Id>Name</Id>
          </ColumnInfo>
          <ColumnInfo Index="3" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Path</Name>
            <Id>Path</Id>
          </ColumnInfo>
          <ColumnInfo Index="4" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Display Name</Name>
            <Id>System.Entity/DisplayName</Id>
          </ColumnInfo>
          <ColumnInfo Index="5" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Mirroring Level</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group/Level</Id>
          </ColumnInfo>
          <ColumnInfo Index="6" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Principal Computer Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group/PrincipalComputerName</Id>
          </ColumnInfo>
          <ColumnInfo Index="7" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Principal SQL Instance Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group/PrincipalInstanceName</Id>
          </ColumnInfo>
          <ColumnInfo Index="8" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Mirror Computer Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group/MirrorComputerName</Id>
          </ColumnInfo>
          <ColumnInfo Index="9" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Mirror SQL Instance Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group/MirrorInstanceName</Id>
          </ColumnInfo>
          <ColumnInfo Index="10" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Database Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group/DatabaseName</Id>
          </ColumnInfo>
          <ColumnInfo Index="11" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Mirroring GUID</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Group/MirroringGUID</Id>
          </ColumnInfo>
          <ColumnInfo Index="12" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>SQL Windows Mirrored DB</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Database</Id>
          </ColumnInfo>
          <ColumnInfo Index="13" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>SQL Windows Mirrored DB Witness</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Witness</Id>
          </ColumnInfo>
        </Presentation>
        <Target />
      </View>
      <View ID="Microsoft.SQLServer.Windows.Mirroring.Database.State.View" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Database" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
        <Criteria>
          <InMaintenanceMode>false</InMaintenanceMode>
        </Criteria>
        <Presentation>
          <ColumnInfo Index="0" SortIndex="0" Width="100" Grouped="false" Sorted="true" IsSortable="true" Visible="true" SortOrder="Descending">
            <Name>State</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Database</Id>
          </ColumnInfo>
          <ColumnInfo Index="1" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Maintenance Mode</Name>
            <Id>InMaintenanceMode</Id>
          </ColumnInfo>
          <ColumnInfo Index="2" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Name</Name>
            <Id>Name</Id>
          </ColumnInfo>
          <ColumnInfo Index="3" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Path</Name>
            <Id>Path</Id>
          </ColumnInfo>
          <ColumnInfo Index="4" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Display Name</Name>
            <Id>System.Entity/DisplayName</Id>
          </ColumnInfo>
          <ColumnInfo Index="5" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Database Name</Name>
            <Id>Microsoft.SQLServer.Core.Database/DatabaseName</Id>
          </ColumnInfo>
          <ColumnInfo Index="6" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Collation</Name>
            <Id>Microsoft.SQLServer.Core.Database/Collation</Id>
          </ColumnInfo>
          <ColumnInfo Index="7" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Recovery Model</Name>
            <Id>Microsoft.SQLServer.Core.Database/RecoveryModel</Id>
          </ColumnInfo>
          <ColumnInfo Index="8" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Updateability</Name>
            <Id>Microsoft.SQLServer.Core.Database/Updateability</Id>
          </ColumnInfo>
          <ColumnInfo Index="9" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Database Autogrow Set</Name>
            <Id>Microsoft.SQLServer.Core.Database/DatabaseAutogrow</Id>
          </ColumnInfo>
          <ColumnInfo Index="10" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Log Autogrow Set</Name>
            <Id>Microsoft.SQLServer.Core.Database/LogAutogrow</Id>
          </ColumnInfo>
          <ColumnInfo Index="11" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>User Access</Name>
            <Id>Microsoft.SQLServer.Core.Database/UserAccess</Id>
          </ColumnInfo>
          <ColumnInfo Index="12" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Owner</Name>
            <Id>Microsoft.SQLServer.Core.Database/Owner</Id>
          </ColumnInfo>
          <ColumnInfo Index="13" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Mirroring GUID</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Database/MirroringGUID</Id>
          </ColumnInfo>
          <ColumnInfo Index="14" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Mirroring Role</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Database/MirroringRole</Id>
          </ColumnInfo>
          <ColumnInfo Index="15" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Mirroring Level</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Database/Level</Id>
          </ColumnInfo>
          <ColumnInfo Index="16" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Partner Instance</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Database/Partner</Id>
          </ColumnInfo>
          <ColumnInfo Index="17" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Witness Instance</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Database/Witness</Id>
          </ColumnInfo>
        </Presentation>
        <Target />
      </View>
      <View ID="Microsoft.SQLServer.Windows.Mirroring.Witness.State.View" Accessibility="Public" Enabled="true" Target="Microsoft.SQLServer.Windows.Mirroring.Witness" TypeID="SC!Microsoft.SystemCenter.StateViewType" Visible="true">
        <Category>Operations</Category>
        <Criteria>
          <InMaintenanceMode>false</InMaintenanceMode>
        </Criteria>
        <Presentation>
          <ColumnInfo Index="0" SortIndex="0" Width="100" Grouped="false" Sorted="true" IsSortable="true" Visible="true" SortOrder="Descending">
            <Name>State</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Witness</Id>
          </ColumnInfo>
          <ColumnInfo Index="1" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Maintenance Mode</Name>
            <Id>InMaintenanceMode</Id>
          </ColumnInfo>
          <ColumnInfo Index="2" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Name</Name>
            <Id>Name</Id>
          </ColumnInfo>
          <ColumnInfo Index="3" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Path</Name>
            <Id>Path</Id>
          </ColumnInfo>
          <ColumnInfo Index="4" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Display Name</Name>
            <Id>System.Entity/DisplayName</Id>
          </ColumnInfo>
          <ColumnInfo Index="5" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Database Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Witness/DatabaseName</Id>
          </ColumnInfo>
          <ColumnInfo Index="6" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Principal Computer Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Witness/Principal</Id>
          </ColumnInfo>
          <ColumnInfo Index="7" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Mirror Computer Name</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Witness/Mirror</Id>
          </ColumnInfo>
          <ColumnInfo Index="8" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="true" SortOrder="Ascending">
            <Name>Mirroring Level</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Witness/Level</Id>
          </ColumnInfo>
          <ColumnInfo Index="9" SortIndex="-1" Width="100" Grouped="false" Sorted="false" IsSortable="true" Visible="false" SortOrder="Ascending">
            <Name>Mirroring GUID</Name>
            <Id>Microsoft.SQLServer.Windows.Mirroring.Witness/MirroringGUID</Id>
          </ColumnInfo>
        </Presentation>
        <Target />
      </View>
    </Views>
    <Folders>
      <Folder ID="Microsoft.SQLServer.Windows.Mirroring.Folder.Root" Accessibility="Public" ParentFolder="MSCL!Microsoft.SQLServer.Core.Folder.Root" />
    </Folders>
    <FolderItems>
      <FolderItem ElementID="Microsoft.SQLServer.Windows.Mirroring.Alert.View" ID="Microsoft.SQLServer.Windows.Mirroring.Alert.View.FolderItem" Folder="Microsoft.SQLServer.Windows.Mirroring.Folder.Root" />
      <FolderItem ElementID="Microsoft.SQLServer.Windows.Mirroring.MirroringGroups.State.View" ID="Microsoft.SQLServer.Windows.Mirroring.MirroringGroups.State.View.FolderItem" Folder="Microsoft.SQLServer.Windows.Mirroring.Folder.Root" />
      <FolderItem ElementID="Microsoft.SQLServer.Windows.Mirroring.Database.State.View" ID="Microsoft.SQLServer.Windows.Mirroring.Database.State.View.FolderItem" Folder="Microsoft.SQLServer.Windows.Mirroring.Folder.Root" />
      <FolderItem ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness.State.View" ID="Microsoft.SQLServer.Windows.Mirroring.Witness.State.View.FolderItem" Folder="Microsoft.SQLServer.Windows.Mirroring.Folder.Root" />
    </FolderItems>
    <StringResources>
      <StringResource ID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor.AlertMessage" />
      <StringResource ID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor.AlertMessage" />
      <StringResource ID="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor.AlertMessage" />
    </StringResources>
  </Presentation>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="true">
      <DisplayStrings>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring">
          <Name>Microsoft SQL Server on Windows Mirroring</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.ScriptedThreeStateType.MonitorType">
          <Name>MSSQL Windows: Mirroring Scripted Three State Unit Monitor Type</Name>
          <Description>Unit Monitor Type to determine Microsoft SQL Server Windows Mirroring objects status.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.ScriptedThreeStateType.MonitorType" SubElementID="IntervalSeconds">
          <Name>Interval (seconds)</Name>
          <Description>The recurring interval of time in seconds in which to run the workflow.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.ScriptedThreeStateType.MonitorType" SubElementID="TimeoutSeconds">
          <Name>Timeout (seconds)</Name>
          <Description>Specifies the time the workflow is allowed to run before being closed and marked as failed.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.ScriptedTwoStateType.MonitorType">
          <Name>MSSQL Windows: Mirroring Scripted Two State Unit Monitor Type</Name>
          <Description>Unit Monitor Type to determine Microsoft SQL Server Windows Mirroring objects status.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.ScriptedTwoStateType.MonitorType" SubElementID="IntervalSeconds">
          <Name>Interval (seconds)</Name>
          <Description>The recurring interval of time in seconds in which to run the workflow.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.ScriptedTwoStateType.MonitorType" SubElementID="TimeoutSeconds">
          <Name>Timeout (seconds)</Name>
          <Description>Specifies the time the workflow is allowed to run before being closed and marked as failed.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor">
          <Name>Database Mirror Status</Name>
          <Description>This monitor checks if database mirror is synchronized.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor" SubElementID="Good">
          <Name>Synchronized</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor" SubElementID="NeitherGoodNorBad">
          <Name>Unsynchronized/Suspended</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor" SubElementID="Bad">
          <Name>Disconnected</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor.AlertMessage">
          <Name>Database Mirror is not Synchronized</Name>
          <Description>Database mirror '{0}' in SQL Server instance '{1}' on computer '{2}' reporting '{3}' state.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor">
          <Name>Database Mirror Witness Status</Name>
          <Description>This monitor checks if database mirror witness is accessible.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor" SubElementID="Good">
          <Name>Connected</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor" SubElementID="NeitherGoodNorBad">
          <Name>Unknown</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor" SubElementID="Bad">
          <Name>Disconnected</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor.AlertMessage">
          <Name>Database Mirror Witness is not accessible</Name>
          <Description>Database mirror '{0}' in SQL Server instance '{1}' on computer '{2}' has lost connection to its witness '{3}'.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor">
          <Name>Database Mirroring Partners Status</Name>
          <Description>This monitor checks if database mirror is synchronized.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor" SubElementID="Good">
          <Name>Synchronized</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor" SubElementID="Bad">
          <Name>Not Synchronized</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor.AlertMessage">
          <Name>Database mirroring partners are not synchronized</Name>
          <Description>Database mirror '{0}' is not synchronized. Mirroring partners are '{1}' and '{2}'.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.AvailabilityRollup">
          <Name>Mirrored Database Availability Rollup</Name>
          <Description>This monitor rolls up the Mirrored Database availability health to the Mirroring Group.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.ConfigurationRollup">
          <Name>Mirrored Database Configuration Rollup</Name>
          <Description>This monitor rolls up the Mirrored Database configuration health to the Mirroring Group.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.PerformanceRollup">
          <Name>Mirrored Database Performance Rollup</Name>
          <Description>This monitor rolls up the Mirrored Database performance health to the Mirroring Group.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessToGroup.AvailabilityRollup">
          <Name>Mirroring Witness Availability Rollup</Name>
          <Description>This monitor rolls up the Mirroring Witness availability health to the Mirroring Group.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessToWitnessRole.AvailabilityRollup">
          <Name>Mirroring Witness Availability Rollup</Name>
          <Description>This monitor rolls up the Mirroring Witness availability health to the Mirroring Witness Role.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Folder.Root">
          <Name>Mirroring</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Alert.View">
          <Name>Active Alerts</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.MirroringGroups.State.View">
          <Name>Mirror Groups</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database">
          <Name>SQL Windows Mirrored DB</Name>
          <Description>Microsoft SQL Server Windows Mirrored Database</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database" SubElementID="MirroringGUID">
          <Name>Mirroring GUID</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database" SubElementID="MirroringRole">
          <Name>Mirroring Role</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database" SubElementID="Level">
          <Name>Mirroring Level</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database" SubElementID="Partner">
          <Name>Partner Instance</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database" SubElementID="Witness">
          <Name>Witness Instance</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessRole">
          <Name>SQL Windows Mirroring Witness Role</Name>
          <Description>Microsoft SQL Server Windows Database Mirroring Witness Role.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness">
          <Name>SQL Windows Mirrored DB Witness</Name>
          <Description>Microsoft SQL Server Windows Mirrored Database Witness</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness" SubElementID="MirroringGUID">
          <Name>Mirroring GUID</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness" SubElementID="DatabaseName">
          <Name>Database Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness" SubElementID="Principal">
          <Name>Principal Computer Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness" SubElementID="Mirror">
          <Name>Mirror Computer Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness" SubElementID="Level">
          <Name>Mirroring Level</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group">
          <Name>SQL Windows Mirroring Group</Name>
          <Description>Microsoft SQL Server Windows Mirroring Group</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group" SubElementID="Level">
          <Name>Mirroring Level</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group" SubElementID="PrincipalComputerName">
          <Name>Principal Computer Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group" SubElementID="PrincipalInstanceName">
          <Name>Principal SQL Instance Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group" SubElementID="MirrorComputerName">
          <Name>Mirror Computer Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group" SubElementID="MirrorInstanceName">
          <Name>Mirror SQL Instance Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group" SubElementID="DatabaseName">
          <Name>Database Name</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Group" SubElementID="MirroringGUID">
          <Name>Mirroring GUID</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Service">
          <Name>SQL Windows Mirroring Service</Name>
          <Description>Microsoft SQL Server Windows Mirroring Service</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database.Discovery">
          <Name>Discover Mirrored Databases for a Database Engine</Name>
          <Description>This object discovery discovers all mirrored databases running for a given instance of SQL Server Windows DB Engine. By default all mirrored databases are discovered and monitored. You can override the discovery to exclude one or more databases from being discovered using the Exclude List. This list takes a comma-separated list of database names or the * character to exclude all databases.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.PrincipalToMirrorReference.Discovery">
          <Name>Discover Database Mirroring direction</Name>
          <Description>This object discovery discovers SQL Server Windows Database Mirroring direction.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness.Discovery">
          <Name>Discover Mirrored Databases Witnesses</Name>
          <Description>This object discovery discovers all mirrored databases witnesses running for a given instance of SQL Server Windows DB Engine. By default witnesses for all mirrored databases are discovered and monitored. You can override the discovery to exclude one or more databases from being discovered using the Exclude List. This list takes a comma-separated list of database names or the * character to exclude all databases.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Service.Discovery">
          <Name>Discover SQL Server Windows Mirroring Service</Name>
          <Description>This object discovery populates Microsoft SQL Server Windows Mirroring Service with Mirroring Groups.</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.DBEngineHostsWitnessRole">
          <Name>Microsoft SQL Server Windows DB Engine hosts Database Mirroring Witness Role</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessRoleHostsWitness">
          <Name>Microsoft SQL Server Windows Database Mirroring Witness Role hosts Mirrored Database Witness</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.GroupContainsDatabase">
          <Name>Microsoft SQL Server Windows Mirroring Group contains Mirrored Database</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.GroupContainsWitness">
          <Name>Microsoft SQL Server Windows Mirroring Group contains Mirrored Database Witness</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.ServiceContainsGroup">
          <Name>Microsoft SQL Server Windows Mirroring Service contains Mirroring Group</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.PrincipalReferencesMirror">
          <Name>Microsoft SQL Server Windows Database Mirroring Direction</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Database.State.View">
          <Name>Mirror Database</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness.State.View">
          <Name>Mirror Witness</Name>
        </DisplayString>
      </DisplayStrings>
      <KnowledgeArticles>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseState.Monitor" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor checks the status of the database mirror as reported by Microsoft® SQL Server™. This is done by running a query against the master database of the SQL Server instance and returning the state of the database mirror. If you receive an alert from this monitor, action is required in order to bring the database mirroring back to an operational state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>An unhealthy state indicates that the SQL Server™ database mirror is currently unavailable. All states except the SYNCHRONIZED state will cause an unhealthy state. The possible states are detailed below:</maml:para>
              <maml:para />
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>SQL Database Mirror State</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>MOM Health State</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>SYNCHRONIZED</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>When the mirror server becomes sufficiently caught up to the principal server, the mirroring state changes to SYNCHRONIZED. The database remains in this state as long as the principal server continues to send changes to the mirror server and the mirror server continues to apply changes to the mirror database.</maml:para>
                    <maml:para>If transaction safety is set to FULL, automatic failover and manual failover are both supported in the SYNCHRONIZED state, there is no data loss after a failover.</maml:para>
                    <maml:para>If transaction safety is off, some data loss is always possible, even in the SYNCHRONIZED state.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>HEALTHY</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>SYNCHRONIZING</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The contents of the mirror database are lagging behind the contents of the principal database. The principal server is sending log records to the mirror server, which is applying the changes to the mirror database to roll it forward.</maml:para>
                    <maml:para>At the start of a database mirroring session, the database is in the SYNCHRONIZING state. The principal server is serving the database, and the mirror is trying to catch up.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>WARNING</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>SUSPENDED</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The mirror copy of the database is not available. The principal database is running without sending any logs to the mirror server, a condition known as running exposed. This is the state after a failover.</maml:para>
                    <maml:para>A session can also become SUSPENDED as a result of redo errors or if the administrator pauses the session.</maml:para>
                    <maml:para>SUSPENDED is a persistent state that survives partner shutdowns and startups.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>WARNING</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>PENDING_FAILOVER</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>This state is found only on the principal server after a failover has begun, but the server has not transitioned into the mirror role.</maml:para>
                    <maml:para>When the failover is initiated, the principal database goes into the PENDING_FAILOVER state, quickly terminates any user connections, and takes over the mirror role soon thereafter.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>WARNING</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>DISCONNECTED</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The partner has lost communication with the other partner.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>CRITICAL</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
              <maml:para>To find the exact state that was reported for the database, examine the context of the state change or alert.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve the issue try the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Make sure mirroring configuration is complete and mirroring process is up and running.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Check physical link between the servers.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Configure firewall rules on both principal and mirror servers according to endpoints configuration.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Alert Priority</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines Alert Priority.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Normal</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Alert Severity</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines Alert Severity.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>MatchMonitorHealth</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Interval (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The recurring interval of time in seconds in which to run the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>900</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Synchronization Time</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The synchronization time specified by using a 24-hour format. May be omitted.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Timeout (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Specifies the time the workflow is allowed to run before being closed and marked as failed.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>300</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessState.Monitor" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor checks the status of the database mirroring witness as reported by Microsoft® SQL Server™. This is done by running a query against the master database of the SQL Server instance and returning the state of the database mirroring witness. If you receive an alert from this monitor, action is required in order to bring the database mirroring witness back to an operational state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>An unhealthy state indicates that the SQL Server™ database mirroring witness is currently unavailable. All states except CONNECTED and NO-WITNESS will cause an unhealthy state. The possible states are detailed below:</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Mirroring Witness State</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>MOM Health State</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>CONNECTED</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>This is normal operational state. Mirroring Partner can access the Witness server.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>HEALTHY</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>NO-WITNESS</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>This is a custom state that is shown when Mirroring is configured without witness. This state indicates that there is no Witness specified for the mirroring session. It is normal operational state for High-Performance Mode and High-Safety Mode Without Automatic Failover.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>HEALTHY</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>UNKNOWN</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>There are some issues with connection between Mirroring Partner and Witness server.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>WARNING</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>DISCONNECTED</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>There is no connection between Mirroring Partner and Witness server.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>CRITICAL</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve the issue try the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Make sure mirroring configuration is complete and mirroring process is up and running.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Check physical link between Mirroring Partner and Witness server.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Configure firewall rules on both servers according to endpoints configuration.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Alert Priority</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines Alert Priority.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Normal</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Alert Severity</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines Alert Severity.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>MatchMonitorHealth</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Interval (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The recurring interval of time in seconds in which to run the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>900</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Synchronization Time</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The synchronization time specified by using a 24-hour format. May be omitted.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Timeout (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Specifies the time the workflow is allowed to run before being closed and marked as failed.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>300</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.PartnersState.Monitor" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This monitor checks the status of the database mirroring session as reported by Microsoft® SQL Server™. This is done by running a query against the master database of the SQL Server instance and returning the state of the database mirroring session. If you receive an alert from this monitor, action is required in order to bring the database mirroring session back to an operational state.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Causes</maml:title>
              <maml:para>An unhealthy state indicates that the SQL Server™ database mirroring session is not in operational state. The possible states are detailed below:</maml:para>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Mirroring Partners State</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>MOM Health State</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>IN_SYNC</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>This is normal operational state. Mirroring Partners are synchronized and mirroring is performing normally.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>HEALTHY</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>OUT_OF_SYNC</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Mirroring Partners are out of sync.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>CRITICAL</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Resolutions</maml:title>
              <maml:para>To resolve the issue try the following:</maml:para>
              <maml:list>
                <maml:listItem>
                  <maml:para>Make sure mirroring configuration is complete and mirroring process is up and running.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Check physical link between Mirroring Partners.</maml:para>
                </maml:listItem>
                <maml:listItem>
                  <maml:para>Configure firewall rules on both Mirroring Partners according to endpoints configuration.</maml:para>
                </maml:listItem>
              </maml:list>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Interval (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The recurring interval of time in seconds in which to run the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>900</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Synchronization Time</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The synchronization time specified by using a 24-hour format. May be omitted.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Timeout (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Specifies the time the workflow is allowed to run before being closed and marked as failed.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>300</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Alert Severity</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines Alert Severity.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Error</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Alert Priority</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines Alert Priority.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Normal</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.AvailabilityRollup" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>No</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.ConfigurationRollup" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>No</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.DatabaseToGroup.PerformanceRollup" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>No</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessToGroup.AvailabilityRollup" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>No</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.WitnessToWitnessRole.AvailabilityRollup" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Generates Alerts</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Defines whether the workflow generates an Alert.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>No</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.Service.Discovery" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This object discovery populates Microsoft SQL Server Windows Mirroring Service with Mirroring Groups.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.Database.Discovery" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This object discovery discovers all mirrored databases running for a given instance of SQL Server Windows DB Engine. By default all mirrored databases are discovered and monitored. You can override the discovery to exclude one or more databases from being discovered using the Exclude List. This list takes a comma-separated list of database names or the * character to exclude all databases.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>Exclude List: A comma-separated list of database names that should be excluded from discovery. You can use the wildcard * to exclude all databases.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Exclude List</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>A comma-separated list of database names that should be excluded from discovery. You can use the wildcard * to exclude all databases.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Interval (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The recurring interval of time in seconds in which to run the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>14400</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Synchronization Time</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The synchronization time specified by using a 24-hour format. May be omitted.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Timeout (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Specifies the time the workflow is allowed to run before being closed and marked as failed.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>300</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.PrincipalToMirrorReference.Discovery" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This object discovery discovers Microsoft SQL Server Windows Database Mirroring direction.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Interval (sec)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>14400</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Synchronization Time</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
        <KnowledgeArticle ElementID="Microsoft.SQLServer.Windows.Mirroring.Witness.Discovery" Visible="true">
          <MamlContent>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Summary</maml:title>
              <maml:para>This object discovery discovers all mirrored databases witnesses running for a given instance of SQL Server Windows DB Engine. By default witnesses for all mirrored databases are discovered and monitored. You can override the discovery to exclude one or more databases from being discovered using the Exclude List. This list takes a comma-separated list of database names or the * character to exclude all databases.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Configuration</maml:title>
              <maml:para>Exclude List: A comma-separated list of database names that should be excluded from discovery. You can use the wildcard * to exclude all databases.</maml:para>
            </maml:section>
            <maml:section xmlns:maml="http://schemas.microsoft.com/maml/2004/10">
              <maml:title>Overridable Parameters</maml:title>
              <maml:table>
                <maml:row>
                  <maml:entry>
                    <maml:para>Name</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Description</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Default Value</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Enabled</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Enables or disables the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Yes</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Exclude List</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>A comma-separated list of database names that should be excluded from discovery. You can use the wildcard * to exclude all databases.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Interval (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The recurring interval of time in seconds in which to run the workflow.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>14400</maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Synchronization Time</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>The synchronization time specified by using a 24-hour format. May be omitted.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para> </maml:para>
                  </maml:entry>
                </maml:row>
                <maml:row>
                  <maml:entry>
                    <maml:para>Timeout (seconds)</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>Specifies the time the workflow is allowed to run before being closed and marked as failed.</maml:para>
                  </maml:entry>
                  <maml:entry>
                    <maml:para>300</maml:para>
                  </maml:entry>
                </maml:row>
              </maml:table>
            </maml:section>
          </MamlContent>
        </KnowledgeArticle>
      </KnowledgeArticles>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>